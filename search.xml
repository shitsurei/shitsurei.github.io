<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2015年观影十佳</title>
    <url>/2015tenfilms.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这篇影评是我本科期间写的，这次借着搭建博客的机会，搬运上来。<br>那时候还在吉大影协里任职，临近15年年末，大佬让我们都写一写自己年度的观影十佳，挑一些写的还不错的发微信公众号上。对于优秀的电影，我向来是不太愿意去影院里观看的，因为好的电影需要自己尽可能的带入进去，才能体会和思考作者力图表达的深意，这是需要一个安静的环境的，再者有些电影确实让人动容，一个人的时候不必太刻意掩饰自己的情绪；反倒是些博人一笑的无厘头喜剧，在影院中观看更有气氛，这么看来我竟给烂片贡献了不少票房了 😆</p>
<a id="more"></a>

<h2 id="小说-诗意的年代"><a href="#小说-诗意的年代" class="headerlink" title="小说/诗意的年代"></a>小说/诗意的年代</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/xiaoshuo.jpg" alt="小说/诗意的年代"></p>
<blockquote>
<p>导演: 吕乐<br>编剧: 刘仪伟 / 吕乐<br>主演: 王志文 / 王彤 / 王朔 / 余华 / 阿城<br>类型: 剧情<br>制片国家/地区: 中国大陆<br>语言: 汉语普通话<br>上映日期: 2007-03-23(香港电影节)<br>片长: 90分钟又名: 诗意的年代 / The Obscure<br>IMDb链接: tt0989890</p>
</blockquote>
<p>上个世纪末，吕乐出于对文学的情结拍摄了这部探讨诗意的电影，在当时的国产电影氛围中也算得上独树一帜，结合了纪录片和故事片的拍摄手法，并且在结构和情节上将两者巧妙结合，实属先锋之作。或许是当时的观众还接受不了电影中出现一群有头有脸的文人作家齐聚一堂，各自表述，而影片过半才出现情节和故事，所以这部影片在未送审之前就被早早毙掉了，这也让我想起姜文的《一步之遥》在上映时影院里的观众因为难以忍受冗长的歌舞就早早退场了。在当今这个浮躁的商业电影环境中，我以为我们更应该对于电影多一分包容，对于电影的形式也要多一分理解，这部上世纪九十年代末的电影就行一杯清茶，值得我们静下心来，细细品尝。</p>
<hr>
<h2 id="心迷宫"><a href="#心迷宫" class="headerlink" title="心迷宫"></a>心迷宫</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/xinmigong.jpg" alt="心迷宫"></p>
<blockquote>
<p>导演: 忻钰坤<br>编剧: 忻钰坤 / 冯元良 / 鲁妮凡<br>主演: 霍卫民 / 王笑天 / 罗芸 / 杨瑜珍 / 孙黎 / 更多…<br>类型: 剧情 / 悬疑 / 犯罪<br>制片国家/地区: 中国大陆<br>语言: 汉语普通话<br>上映日期: 2015-10-16(中国大陆) / 2014-07-21(FIRST青年影展) / 2014-08-28(威尼斯电影节)<br>片长: 110分钟(中国大陆) / 119分钟(威尼斯电影节)<br>又名: 殡棺 / The Coffin in the Mountain / Deep in the Heart<br>IMDb链接: tt4078856</p>
</blockquote>
<p>如果说2015年的优秀电影里能有一部国产电影的话，那就非这部《心迷宫》莫属了。没有明星大腕，没有卖肉卖萌，而且还是部农村片。初次听到这样的宣传不论谁也会为这部即将在院线中上映的电影捏一把汗，毕竟在如今这个把拍电影当“风投”的时代，没有前期的大力宣传，没有吸引人眼球的看点，很难在市场中站得住脚。但作为第八届first影展参展电影确实是充满了独立电影的气质，小成本，处女座，第八届FIRST青年电影展最佳剧情长片，最佳导演……这些才是这部电影应有的标签。在这个千篇一律的电影圈钱时代，有点情怀的《老炮儿》都能让人吹上天，而这部在叙事结构上都有所创新的电影，颇有宁浩最开始的胆识。最后用纸巾老师的话来结尾——你们农村人真会玩。多说无益，快去看快去看快去看……</p>
<hr>
<h2 id="国际市场"><a href="#国际市场" class="headerlink" title="国际市场"></a>国际市场</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/guojishichang.jpg" alt="国际市场"></p>
<blockquote>
<p>导演: 尹齐均<br>编剧: 朴秀真<br>主演: 黄政民 / 金允珍 / 吴达洙 / 张荣男 / 郑镇荣 / 更多…<br>类型: 剧情 / 家庭<br>官方网站: <a href="http://www.kukje2014.co.kr/" target="_blank" rel="noopener">http://www.kukje2014.co.kr/</a><br>制片国家/地区: 韩国<br>语言: 韩语 / 英语 / 德语<br>上映日期: 2014-12-17(韩国)<br>片长: 126分钟<br>又名: 半世纪的诺言(港) / 国际市场：半世纪的诺言(台) / 给父亲的承诺 / Ode to My Father / The International Market<br>IMDb链接: tt3812366</p>
</blockquote>
<p>比起韩剧，韩国的电影总能甩出中国几条街，一定程度上可以说韩国电影代表了亚洲电影的最高水准，这也看得出电影制度对于电影产业的重要作用，自从韩国1999年修订了《电影振兴法》，引入电影分级制度，将电影的管辖权下放，从此韩国电影焕发出了让人望洋兴叹的创造力，那年之后《JSA》《杀人回忆》《老男孩》《我的野蛮女友》等等优秀的电影层出不穷，这也是国内不断呼吁电影分级制度的原因之一。而这次韩国推出的主旋律电影《国际市场》更是一部高水准的作品，影片表现了韩国一代人的心路历程，国家的分裂，外派的劳工，家庭的守护，为国家不懈的奋斗，时代的变迁等等，几乎设计了所有你能想象到的点，一部《阿甘正传》一般的电影，却又具备韩国电影独特的点，那就是有血有肉，真情实感，一个为国家奋斗一生的热血青年，终有一天也会变成讨人嫌弃的糟老头子。笑，众人陪笑，哭，独自垂泪。电影会引发有很多对自己国家和历史的反思，例如三八线是一道伤疤，难道台湾海峡就不是吗，为什么韩国可以拍出这样的电影而中国不可以，这让我想起《一九四二》上映之后还有很多人骂，骂冯小刚，骂电影太血腥，实在是让人心寒，更有人讥讽说为何不拍1960，这种狠好人不死，狠好人不当烈士的心态实在是让人恶心。</p>
<hr>
<h2 id="消失的爱人"><a href="#消失的爱人" class="headerlink" title="消失的爱人"></a>消失的爱人</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/gonegirl.jpg" alt="gone girl"></p>
<blockquote>
<p>导演: 大卫·芬奇<br>编剧: 吉莉安·弗琳<br>主演: 本·阿弗莱克 / 裴淳华 / 尼尔·帕特里克·哈里斯 / 凯莉·库恩 / 泰勒·派瑞 / 更多…<br>类型: 剧情 / 悬疑 / 惊悚 / 犯罪<br>制片国家/地区: 美国<br>语言: 英语<br>上映日期: 2014-09-26(纽约电影节) / 2014-10-03(美国)<br>片长: 149分钟<br>又名: 失踪的女孩 / 失踪女孩 / 失踪罪(港) / 控制(台)<br>IMDb链接: tt2267998</p>
</blockquote>
<p>芬奇导演一向以人物和故事取胜，而每一部影片中的人物总要走向黑化，十足的BBC神剧《黑镜》风格。很多人都说这部影片想要映射的点在媒体，媒体对于舆论的误导和个人隐私的侵害，媒体的发达使得个人隐私不复存在，而集体行动的逻辑又缺乏反思，使得别有用心的很容易就将其引导，但在进一步思考这其中的问题，仅仅是媒体的一面之词就可以决定舆论吗，更多的还是一种政治正确一般束缚人性的社会规范，芬奇总是试图在解构我们传统意义上的一些社会规范和制度安排，这部电影体现的便是婚姻制度，诚然，爱情很美好，但是现代社会每个个体追求独立，追求个性自由和解放，人格的独一无二在婚姻制度面前必然遭到一定对抗和妥协，在我们看来就叫做“磨合”，看似平平无奇，实则也埋下了隐患。可以想象，有一天个体已经独立到丧失了婚姻制度中两个人之间的依赖性，婚姻在也给不了人安全感和归属感，那么这无疑是一副枷锁，剩下的只是维持一副表面的政治正确罢了，就如同《黑镜》S1E1最后一幕首相夫人对待首相的态度一般，这便是这部影片所讲述的故事。</p>
<hr>
<h2 id="山河故人"><a href="#山河故人" class="headerlink" title="山河故人"></a>山河故人</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/shanheguren.jpg" alt="山河故人"></p>
<blockquote>
<p>导演: 贾樟柯<br>编剧: 贾樟柯<br>主演: 赵涛 / 张译 / 梁景东 / 董子健 / 张艾嘉 / 更多…<br>类型: 剧情 / 家庭<br>制片国家/地区: 中国大陆 / 法国 / 日本<br>语言: 英语 / 山西话 / 汉语普通话 / 上海话<br>上映日期: 2015-10-30(中国大陆) / 2015-05-20(戛纳电影节)<br>片长: 126分钟(中国大陆) / 131分钟(法国)<br>又名: 山河恋人 / Mountains May Depart<br>IMDb链接: tt3740778</p>
</blockquote>
<p>贾樟柯给人的感觉一向是一种充满野性的乡土气息，与姜文相比正好是两种相对的风格，一个像天上的云，一个像脚下的土，但是从这部影片看来，贾樟柯也开始不满足于自己只是充满乡土气息的作品而开始有所尝试，有趣的一点是贾樟柯和姜文一样都是有野心的，姜文的野心表现的更早更明显，从《太阳照常升起》就开始往电影里注入一个一个隐喻，到《一步之遥》的时候已经表现出一种荒诞的风格，一部完全由隐喻组成的电影，也怪不得有人要骂了；而贾樟柯在这部电影里也参杂了些许隐喻，钥匙，河，关刀少年，飞机事故，枪和敌人，三角和几何……有隐喻就会出现过度解读，就会出现两极分化的评价，这是不可避免的。有人说从这部影片看来贾樟柯要走向商业化，这我并不同意，追求在镜头语言，在场景布局上追求更加高水准并不算做一个商业元素吧。</p>
<hr>
<h2 id="悲惨世界"><a href="#悲惨世界" class="headerlink" title="悲惨世界"></a>悲惨世界</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/miserable.jpg" alt="miserable"></p>
<blockquote>
<p>导演: 汤姆·霍珀<br>编剧: 威廉姆·尼克尔森 / 赫伯特·克莱茨莫 / 克洛德-米歇尔·勋伯格 / 阿兰·布伯里勒 / 维克多·雨果<br>主演: 休·杰克曼 / 罗素·克劳 / 安妮·海瑟薇 / 阿曼达·塞弗里德 / 埃迪·雷德梅恩 / 更多…<br>类型: 剧情 / 爱情 / 音乐<br>官方网站: <a href="http://www.lesmiserablesfilm.com" target="_blank" rel="noopener">www.lesmiserablesfilm.com</a><br>制片国家/地区: 美国 / 英国<br>语言: 英语<br>上映日期: 2013-02-28(中国大陆) / 2012-12-24(美国)<br>片长: 157分钟<br>又名: 孤星泪(港) / 音乐剧《悲惨世界》电影版 / Les Miserables<br>IMDb链接: tt1707386</p>
</blockquote>
<p>看过的音乐剧不多，就不妄加评价了，但是作为名著改编作品，并且是已经多次改变音乐剧的作品，本身已经是站在巨人的肩膀上摘苹果了，所以不管从改编的详略得当，音乐的一脉相承，专业舞台剧演员的表演都是高水准，如果希望感受这么一场史诗级的画面和音乐，这部影片一定不要错过，就观影体验来说这无疑是我今年看过的一部数一数二的作品，很后悔没有在影院亲身感受一下。</p>
<hr>
<h2 id="万箭穿心"><a href="#万箭穿心" class="headerlink" title="万箭穿心"></a>万箭穿心</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/wanjianchuanxin.jpg" alt="万箭穿心"></p>
<blockquote>
<p>导演: 王竞<br>编剧: 吴楠<br>主演: 颜丙燕 / 陈刚 / 焦刚 / 李现 / 赵倩 / 更多…<br>类型: 剧情 / 家庭<br>制片国家/地区: 中国大陆<br>语言: 汉语普通话 / 武汉方言<br>上映日期: 2012-11-16(中国大陆)<br>片长: 118分钟<br>又名: 风水 / Feng Shui<br>IMDb链接: tt2513344</p>
</blockquote>
<p>很少看到这样一部表现现当代女性生存状态的电影，表面上我们看到的是一个市井妇女形象，尖酸刻薄，控制欲极强，最终毁灭了整个家庭，但她同时也为整个家庭付出了自己的心血，面对家庭顶梁柱的缺失，她一个人扛起扁担，养活整个家庭，这种朴实和毅力也是妇女身上难能可贵的品质。影片一方面颂扬了女性追求独立，追求社会地位提升的努力，一方面也表现出对这一可能性的怀疑，颜丙燕对于角色的刻画成为了电影的点睛之笔，同时也是一部典型的区域电影，影片中的各种武汉符号也让观赏这部影片的武汉人多了一分感情。</p>
<hr>
<h2 id="渴望"><a href="#渴望" class="headerlink" title="渴望"></a>渴望</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/kewang.jpg" alt="渴望"></p>
<blockquote>
<p>导演: 中岛哲也<br>编剧: 中岛哲也 / 门间宣裕 / 唯野未步子 / 深町秋生<br>主演: 役所广司 / 小松菜奈 / 妻夫木聪 / 清水寻也 / 二阶堂富美 / 更多…<br>类型: 悬疑<br>官方网站: kawaki.gaga.ne.jp<br>制片国家/地区: 日本<br>语言: 日语<br>上映日期: 2014-06-27(日本)<br>片长: 118分钟<br>又名: 渴罪(港) / 渴望(台) / 渴求 / Kawaki / The World of Kanako<br>IMDb链接: tt3108158</p>
</blockquote>
<p>作为中岛粉不放一部中岛的电影实在是过意不去，但是这部电影就观感来说实在不怎么样，可能是中岛之前的电影太过出彩，使得我对于他的标准无形中提的很高，这部电影总的来说还是继承了中岛一贯的极强的个人风格，血腥暴力，画面布局风格化，因为中岛是广告导演出身，所以在他的电影中滤镜是必备的，色彩是绚丽的，背景音乐是考究的，无处不种满着一种MV的画面风格。但是，我还是要说但是，形式的东西在中岛的电影里永远是锦上添花而非雪中送炭，其核心也可以说是日本电影的核心，最重要的还是对人性的挖掘，《告白》中的任何一个人物单拎出来都要比这部电影中的每一个人物立体很多，《松子》就更不必说了。所以在我看来这部影片如果只是以一个家庭缺失的内核套一个各种黄暴的B级片的话，中岛你这潜心四年的成果真是让人失望了。</p>
<hr>
<h2 id="爱在三部曲"><a href="#爱在三部曲" class="headerlink" title="爱在三部曲"></a>爱在三部曲</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/beforesunset.jpg" alt="before sunset"></p>
<blockquote>
<p>导演: 理查德·林克莱特<br>编剧: 理查德·林克莱特 / 金·克里桑<br>主演: 伊桑·霍克 / 朱莉·德尔佩 / 安德莉亚·埃克特 / 汉诺·波西尔 / Karl Bruckschwaiger<br>类型: 剧情 / 爱情<br>制片国家/地区: 美国 / 奥地利 / 瑞士<br>语言: 英语 / 德语 / 法语<br>上映日期: 1995-01-27(美国)<br>片长: 101分钟<br>又名: 情留半天(港) / 爱在黎明破晓时(台) / 日出之前<br>IMDb链接: tt0112471</p>
</blockquote>
<hr>
<blockquote>
<p>导演: 理查德·林克莱特<br>编剧: 理查德·林克莱特 / 朱莉·德尔佩 / 伊桑·霍克 / 金·克里桑<br>主演: 伊桑·霍克 / 朱莉·德尔佩 / 弗农·多布切夫<br>类型: 剧情 / 爱情<br>制片国家/地区: 美国<br>语言: 英语 / 法语<br>上映日期: 2004-02-10(柏林电影节) / 2004-07-30(美国)<br>片长: 80 分钟<br>又名: 日落巴黎(港) / 爱在日落巴黎时(台) / 日落之前 / 情留相逢时 / 爱在日落余晖时 / 爱在日落黄昏前<br>IMDb链接: tt0381681</p>
</blockquote>
<hr>
<blockquote>
<p>导演: 理查德·林克莱特<br>编剧: 理查德·林克莱特 / 伊桑·霍克 / 朱莉·德尔佩<br>主演: 伊桑·霍克 / 朱莉·德尔佩 / 肖姆斯·戴维-菲茨帕特里克 /<br>妮弗·普里尔 / 夏洛特·普里尔<br>类型: 剧情 / 爱情<br>官方网站: <a href="http://www.sonyclassics.com/beforemidnight/" target="_blank" rel="noopener">www.sonyclassics.com/beforemidnight/</a><br>制片国家/地区: 美国<br>语言: 英语 / 希腊语 / 法语<br>上映日期: 2013-06-14(美国)<br>片长: 109分钟<br>又名: 爱在午夜希腊时(台) / 情约半生(港) / 爱在午夜到来时 / 爱在午夜梦回时 / 午夜之前<br>IMDb链接: tt2209418</p>
</blockquote>
<p>聊到伊桑霍克，不得不想起还在他1989年在《死亡诗社》中和罗宾威廉姆斯搭戏的时候，还是一个萌萌哒齐刘海的小鲜肉，白驹过隙，这么多年过去，伊桑早已经变成了饱经沧桑的中年大叔，而罗宾已经离我们远去了。聊到林克莱特的爱在三部曲，然我想到了伊桑在《少年时代》中的改变，爱在三部曲每隔九年拍一部，历时18年完成，而少年时代一部电影历时12年完成，似乎伊桑对于尝试巴赞的电影理论（“电影就是对客观事物原貌的再现”）尤为感兴趣，这样的电影精神还是制度鼓励。具体说道这部电影，讲述的就是一个干干净净的爱情故事，两人的表演也颇为细致，观看的时候也不免会被带入其中，感受一场初恋般的朦胧，而电影也将维也纳和巴黎的街景带入其中，为这份爱情增添一份浪漫。很多人说第三部烂尾了，爱情最终还是输给了生活，或许吧，但有另一个角度看，这恰恰说明最初的选择是爱情，而非激情，在知乎上看到过一句话非常有触动：琐碎的生活一地鸡毛，如果没有真正的爱情，激情褪去真的是一天也过不下去。</p>
<hr>
<h2 id="十年"><a href="#十年" class="headerlink" title="十年"></a>十年</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/shinian.jpg" alt="shinian"></p>
<blockquote>
<p>404 is not found</p>
</blockquote>
<p>首先声明，这部电影我只看过预告片。<br>第一次听说这个电影，是在知乎上有人提出了如何评价香港2015上映的电影《十年》这一问题，当时看到回答下面一片骂声，说香港人天真，自己讲鬼故事把自己吓着了等等一些评论引起了我的兴趣，似乎是一部政治不正确的电影，于是在豆瓣上搜索，看到了词条，看了大概简介才明白，电影是几个香港独立电影导演对香港未来十年突发奇想，反思可能会被TG陷入到一种《1984》中所描述的恐怖氛围中，香港的本土文化逐渐丧失的故事，于是拍了这么一部短篇集的电影，正好赶上台湾大选结束，周子瑜事件，香港民众就这部电影产生了一些对大陆的恐慌和不稳定情绪。这也只是我的猜想，但当我希望进一步对这部影片有所了解时，网上的部分影评被删了，知乎的问题被删了，连豆瓣上的词条也被删了，这让我不由得心寒。我不想谈政治，也没有什么激进的政治立场或诉求，但是对于电影，对于艺术，我向来都是以为艺术是自由的，电影是没有国界的，优秀的电影可以触动每一个人的内心，可以打破国界，穿过意识形态的阻隔。中国的电影市场很大，但审查制度一直存在，电影水准一直得不到提升，如果想看到优秀的反映社会的充满思辨的电影，也只能赶每年的独立电影节看看影展了。退一步说，电影是意识形态的工具，反动电影会蛊惑人心，但你禁止能够禁止得了吗，市场经济的海洋中每一滴水都在流动，你堵能堵得住吗。开放与包容永远是一个大国该有的心态，公道自在人心，电影恰恰是让我们反思让我们避免悲剧的手段，如果对于电影，对于艺术只知道一味的查删封禁，十年时光，或许真我们的会迎来“一个不想见到的将来”。</p>
<hr />
]]></content>
      <categories>
        <category>评论</category>
      </categories>
      <tags>
        <tag>影评</tag>
        <tag>盘点</tag>
      </tags>
  </entry>
  <entry>
    <title>对数器和比较器的应用</title>
    <url>/algorithmTools.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在学习数据结构和算法的过程中，我们常常会遇到这样的问题：看到或想出某个时间复杂度或空间复杂度较低的算法，想要验证这个算法是否正确，但一时无法在OJ系统中找到相同的题目，只是有限的几个样本数据很难确定算法是否真的能AC，这时我们就可以借助对数器这一强有力的工具来帮助我们解决。</p>
<a id="more"></a>

<div class="note info"><p>以下学习笔记内容由java语言编写。</p></div>

<h2 id="六步实现对数器"><a href="#六步实现对数器" class="headerlink" title="六步实现对数器"></a>六步实现对数器</h2><p>什么是对数器，简单来说就是验证你的算法是否“完全正确”的工具，听起来很高大上，实现起来却很简单，只需要简简单单六个步骤</p>
<h3 id="1-有一个你想要测试的方法a"><a href="#1-有一个你想要测试的方法a" class="headerlink" title="1.有一个你想要测试的方法a"></a>1.有一个你想要测试的方法a</h3><p>这个方法可能来源于你在面对一道算法题时冥思苦想得出的一个思路，虽然看起来没什么问题，但是面对大样本的输入时不敢保证每一个结果都正确；又或者来源于你看到某篇帖子或论坛上某个大神的迷之脑回路的一个解法，想要验证这个解法是否正确。总之，这个方法你理解也好不理解也罢，目前为止还没有什么有效结果来支持这一算法的正确性。</p>
<h3 id="2-实现一个绝对正确的方法b"><a href="#2-实现一个绝对正确的方法b" class="headerlink" title="2.实现一个绝对正确的方法b"></a>2.实现一个绝对正确的方法b</h3><p>面对任何一道算法题，它的解一定不是唯一的，例如一个简单的排序，我们也学过冒泡，插入，选择，快排，希尔，桶排，堆排等等十几种排序方法。但是，解和解之间是有差别的，最终的差别往往体现在算法的时间复杂度和空间复杂度上，面对同一道题目，我们既可以采用最直接最简单也最暴力的方法去计算，也可以写出优雅高效的算法，这也是衡量一个程序员代码水平的重要指标。</p>
<p>对于大多数算法题目来说，如果你给出的解法在时间复杂度上超过O(N<sup>2</sup>)时，这个算法往往是没有意义的，因为这样的时间复杂度在工程领域根本不具备可操作性；但是，这样的方法往往是我们解决一个问题的第一思路，这个思路最符合人的思维逻辑（往往具备线性，全覆盖性等特点），对于这一算法的正确性也最有把握。因此，用这样的绝对正确但时间复杂度和空间复杂度又差的方法产生的结果作为参照依据是对数器的核心思路。</p>
<h3 id="3-实现一个随机样本产生器"><a href="#3-实现一个随机样本产生器" class="headerlink" title="3.实现一个随机样本产生器"></a>3.实现一个随机样本产生器</h3><p>有了算法，这时应该考虑测试数据从哪来，在我们一开始得到方法a时，必然也会用有限的几个样本数据对算法的准确性做初步的测试，三五个正确的输入输出之后似乎算法没有什么问题，但要做进一步大样本的测试又不是人力所能及的，这时我们就要通过语言所提供给我们的一些工具来构造大样本的富有随机性的输入输出了。构造随机样本产生器，我们主要要考虑以下三个问题：</p>
<ol>
<li><p><strong>输入数据的主要类型是什么？</strong></p>
<p> 可能你会认为，算法题目有那么多，几乎每一道题要求的输入数据都不相同，难道要每遇到一道题，就去手动构造一个对数器？其实不然，有一定数据结构与算法基础的同学都知道，基本的数据类型只有四种：集合结构，线性结构，树形结构，网状结构（也成图）。这四种属于逻辑结构，即人为区分出来的结构，对应到计算机内存中，每种逻辑结构又可以通过顺序存储和链式存储两种物理结构来表示（两种物理结构各有利弊，一般根据对数据常用的操作来决定选择哪种），因此通常你会遇到的主要数据类型不会超过十种，如果你能对每一种类型的构造方法都进行一定可拓展性的补充，就足以应对大部分的算法题目。</p>
</li>
<li><p><strong>输入数据的数据状况如何？</strong></p>
<p> 由于算法题目的要求往往具备一定的实际意义，因此其输入数据的数据状况也有相应的要求，以我们最常见的整型为例，如果题目的输入数据为年龄，则不应该出现负数或太大的数字，如果输入数据为星期数，则只能是1到7这七个整型数字之一，这就要求我们在构造随机样本生成器时，对随机产生的数据做一定处理，保证其输入的元素均在题目要求的合理范围内，避免进行无意义的计算。</p>
</li>
<li><p><strong>边界值的考虑</strong></p>
<p> 有一定开发经验的朋友一定深有体会，写代码过程中80%的时间都是在对边界值做处理，保证代码的健壮性（任何合法或不合法的输入输出值都不会使得程序崩溃），在做算法题目时也是如此，题目所给出的样本值往往是有限个合法或某一种不合法的输入情况，而在其他不合法的输入情况下，题目也没有明确说明不会有该情况发生，这时就需要我们全方位的考虑输入值在各种情况下如何得到合理的输出，尤其是对边界值的处理。这里的边界值包括0值的输入、空值的输入或空字符串的输入等，以及相关变量初始化和终止条件的控制。</p>
</li>
</ol>
<div class="note info"><p>后两点最好在随机样本产生器的构造函数中就留好接口，减少后期对构造函数反复修改的成本。</p></div>

<h3 id="4-把方法a和方法b比对很多次来验证方法a是否正确"><a href="#4-把方法a和方法b比对很多次来验证方法a是否正确" class="headerlink" title="4.把方法a和方法b比对很多次来验证方法a是否正确"></a>4.把方法a和方法b比对很多次来验证方法a是否正确</h3><p>有了随机样本生成器之后，我们便可以对样本进行大规模测试，将两个方法每一次计算得到的结果进行对比，判断这两次计算得到的结果是否完全相等，这里依然需要注意几个问题：</p>
<ol>
<li><p><strong>样本数量如何控制？</strong></p>
<p> 虽然在这一步我们意图进行大规模的样本测试，但是也很难对工程级的数据量进行测试，原因显而易见，想要比对两次计算所得结果，首先就要两个算法分别跑一遍之后才能进行比较，故整个流程是串行的，其时间复杂度为两个算法的时间复杂度之和。从数量级来看整个比较过程的时间复杂度和算法b的时间复杂度相同，如果算法b对工程级的数据量可以接受，那么算法a的时间复杂度的优势意义没有了，因此我们依然是对有限的数据量进行测试。</p>
<p> 那么既不能太多——时间耗不起，又不能太少——样本覆盖率太小，因此通过经验分析，我们认为在测试数量达到数十万次以上是一个比较合理的范围；这也需要根据数据类型和数据情况做相应的调整，例如输入样本为整型数组，数组的长度和取值范围也是考虑因素，如果数组本身已经很大，一次计算所要花费的时间就很大，那么数十万次的测试时间也是难以接受的。这里笔者推荐大家在计算机当前所能承受的计算程度上，逐级增加数据量，从而逼近当前计算能力所能逼近的数据量上限。</p>
</li>
<li><p><strong>如何对输出结果进行比较？</strong></p>
<p> 在得到两个计算结果之后，我们需要对两者进行比较，这一步我们需要创建比较函数。事实上，这一步通常比大家想的要难的多，虽然也有些题目的结果为单一的基本类型，直接用等号判断即可，但大量的题目是无法直接比较得出答案的。难以比较的结果主要分为以下几种：</p>
<ul>
<li><p>输出结果带有一定随机性。例如，输出结果是一个无序集合，算法a和算法b输出的结果是乱序的，需要一定程度的遍历，检索和记录；</p>
</li>
<li><p>输出结果为一个对象。无法直接比较两者的引用来验证，需要比较器（重写compareTo方法）来协助验证过程；</p>
</li>
<li><p>输出结果的类型需要一定转换。在讨论输入类型时我们提到四种基本逻辑结构，越是靠后的结构越复杂，有时通过将复杂的物理结构进行压缩（类似“降维打击”）可以有效提高数据的运算速度。例如，二叉树的比较是一个比较复杂的问题，但是当把二叉树序列化之后得到的字符串可以唯一标识一个树，这样字符串之间的比较就简单得多。</p>
<p>总之，对于计算结果的对比验证，其难度有时不亚于一道算法题目，需要在验证函数完成后多测试，确保验证函数的正确性，否则之后产生的问题会很难定位。</p>
</li>
</ul>
</li>
</ol>
<div class="note warning"><p>在对输入数据进行运算时，为了避免算法对原始输入数据的影响和算法之间的相互影响，通常开辟不同的内存空间存储相同值的输入数据，供方法a和方法b进行运算。</p></div>

<h3 id="5-如果有一个样本使得比对出错，打印样本分析是哪个方法出错"><a href="#5-如果有一个样本使得比对出错，打印样本分析是哪个方法出错" class="headerlink" title="5.如果有一个样本使得比对出错，打印样本分析是哪个方法出错"></a>5.如果有一个样本使得比对出错，打印样本分析是哪个方法出错</h3><p>样本验证出错是常有的情况，我们自己写出来的代码很难一次就AC，能够及时发现bug，修正代码的逻辑才是需要更加重视的能力。这里要注意的是，当发现错误时，我们需要保留出错时的相关信息，帮助我们锁定出问题的位置，才能迅速的修正问题。一般而言，在对数器的主函数中，就应当写明出现问题时打印当前比较中原始输入的数据，方法a执行的结果，方法b执行的结果等，分析这些信息来判断出错的函数（不是每次出错都是方法a的问题，有时方法b也会产生部分错误，但这些错误很快就会暴露出来）。分析错误的流程如下：</p>
<ol>
<li>先将通过人工推导的方式将原始输入数据推导一遍，得到输出数据，通过三方数据相互比对确定哪一个或几个数据出现问题</li>
<li>在找到数据出问题的方法，将原始输入数据代入其中，人工推导一遍代码的运算逻辑，找出出错的位置</li>
<li>修改出错的代码逻辑</li>
</ol>
<h3 id="6-当样本数量很多时比对测试依然正确，可以确定方法a已经正确"><a href="#6-当样本数量很多时比对测试依然正确，可以确定方法a已经正确" class="headerlink" title="6.当样本数量很多时比对测试依然正确，可以确定方法a已经正确"></a>6.当样本数量很多时比对测试依然正确，可以确定方法a已经正确</h3><p>当最初设定的样本数量全部通过之后，可以打印相应的信息进行标识，到此为止，我们已经可以基本确定，方法a是准确的了。之所以说基本确定，因为这样的验证方法仅仅是基于归纳统计得出的结果，而非通过严格的数学证明。但往往严格的数学证明需要花费大量的时间和精力，尤其是在贪心策略的相关题目上，提出一个贪心策略很容易，验证一个贪心策略也不是很难，而证明一个贪心策略需要深厚的数学功底，如果当前的目标是提升自己的算法能力，那么使用对数器来验证算法就够用了。</p>
<h2 id="对数器的代码实现"><a href="#对数器的代码实现" class="headerlink" title="对数器的代码实现"></a>对数器的代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlgorithmDevice</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 生成随机数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> maxSize	数组最大长度</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> maxValue	数组元素最大值</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> hasMinus	元素是否包含负数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> withEmpty	数组是否可以为空</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] geneRandomArray(<span class="keyword">int</span> maxSize,<span class="keyword">int</span> maxValue,<span class="keyword">boolean</span> hasMinus,<span class="keyword">boolean</span> withEmpty) &#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr;</span><br><span class="line">		<span class="keyword">if</span>(withEmpty)</span><br><span class="line">			arr = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>)(Math.random()*(maxSize+<span class="number">1</span>))];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			arr = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>) (Math.random() * (maxSize - <span class="number">1</span> + <span class="number">1</span>)) + <span class="number">1</span>];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr.length ; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (hasMinus)</span><br><span class="line">				arr[i] = (<span class="keyword">int</span>)(Math.random()*(maxValue+<span class="number">1</span>))-(<span class="keyword">int</span>)(Math.random()*(maxValue+<span class="number">1</span>));</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				arr[i] = (<span class="keyword">int</span>)(Math.random()*(maxValue+<span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> arr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 验证两个数组是否完全相等</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arr1</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arr2</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>((arr1==<span class="keyword">null</span>&amp;&amp;arr2!=<span class="keyword">null</span>)||(arr2==<span class="keyword">null</span>&amp;&amp;arr1!=<span class="keyword">null</span>))</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span>(arr1==<span class="keyword">null</span>&amp;&amp;arr2==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">if</span>(arr1.length!=arr2.length)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">boolean</span> equal = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr1.length ; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(arr1[i]!=arr2[i]) &#123;</span><br><span class="line">				equal = <span class="keyword">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> equal;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 	验证两个链表是否完全相等</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> n1</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> n2</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validateLinkList</span><span class="params">(Node n1,Node n2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n1==<span class="keyword">null</span>&amp;&amp;n2==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">boolean</span> equal = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">while</span>(n1!=<span class="keyword">null</span>&amp;&amp;n2!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(n1.value!=n2.value) &#123;</span><br><span class="line">				equal = <span class="keyword">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			n1 = n1.next;</span><br><span class="line">			n2 = n2.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>((n1==<span class="keyword">null</span>&amp;&amp;n2!=<span class="keyword">null</span>)||(n1!=<span class="keyword">null</span>&amp;&amp;n2==<span class="keyword">null</span>))</span><br><span class="line">			equal = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">return</span> equal;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//主函数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//设置初始值：验证次数，随机样本长度，最大值</span></span><br><span class="line">		<span class="keyword">int</span> textTime = <span class="number">50000</span>;</span><br><span class="line">		<span class="keyword">int</span> maxSize = <span class="number">20</span>;</span><br><span class="line">		<span class="keyword">int</span> maxValue = <span class="number">50</span>;</span><br><span class="line">		<span class="comment">//循环开关</span></span><br><span class="line">		<span class="keyword">boolean</span> ac = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; textTime ; i++) &#123;</span><br><span class="line">			<span class="comment">//遵循方法隔离原则，方法a和b分别操作不同的内存区域</span></span><br><span class="line">			<span class="keyword">int</span>[] ran = geneRandomArray(maxSize, maxValue,<span class="keyword">false</span>,<span class="keyword">false</span>);</span><br><span class="line">			<span class="comment">//clone方法为数组的深拷贝</span></span><br><span class="line">			<span class="keyword">int</span>[] arr1 = ran.clone();</span><br><span class="line">			<span class="keyword">int</span>[] arr2 = ran.clone();</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//输出结果为基本数据类型的验证</span></span><br><span class="line">			<span class="comment">/*int num1 = a(arr1);</span></span><br><span class="line"><span class="comment">			int num2 = b(arr2);</span></span><br><span class="line"><span class="comment">			if(num1!=num2) &#123;</span></span><br><span class="line"><span class="comment">				System.out.println(num1);</span></span><br><span class="line"><span class="comment">				System.out.println(num2);</span></span><br><span class="line"><span class="comment">				ac = false;</span></span><br><span class="line"><span class="comment">				break;</span></span><br><span class="line"><span class="comment">			&#125;*/</span></span><br><span class="line">			<span class="comment">//输出结果为数组的验证</span></span><br><span class="line">			<span class="comment">/*if(!validate(arr1, arr2)) &#123;</span></span><br><span class="line"><span class="comment">				ac = false;</span></span><br><span class="line"><span class="comment">				FoundSort.show(ran, false);</span></span><br><span class="line"><span class="comment">				FoundSort.show(arr1, false);</span></span><br><span class="line"><span class="comment">				FoundSort.show(arr2, false);</span></span><br><span class="line"><span class="comment">				break;</span></span><br><span class="line"><span class="comment">			&#125;*/</span></span><br><span class="line">			<span class="comment">//……</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ac)</span><br><span class="line">			System.out.println(<span class="string">"Nice!"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			System.out.println(<span class="string">"Fucking wrong!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="比较器（Comparator）"><a href="#比较器（Comparator）" class="headerlink" title="比较器（Comparator）"></a>比较器（Comparator）</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>比较器是java从JDK1.2版本开始就有的泛型接口，用来确定同类对象之间的顺序关系，从JDK8之后，该接口被声明为函数式接口，可以通过lambda表达式进行调用。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li>上文中我们提到用比较器来比较两个对象的是否“相等”，我们都知道在java中对象作为一个引用类型，是不能够直接用等号<code>==</code>来进行比较的，这样只会比较两个对象是否指向同一块内存区域，显然不具有实际的比较意义。有些类中为了便于比较，封装了自己的比较方法，例如String类的equals方法，故对于自定义类型的比较，需要根据需求自定义该类实例的比较方法。</li>
<li>在排序相关的算法过程中往往涉及到比较的环节，只有元素之间能够进行比较，才能确定顺序（且该顺序应该是确定唯一的，而非人为规定的循环顺序——“石头剪刀布”），因此为了简化代码，分离逻辑，将比较相关的代码放入比较器中。</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> foundation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompareDevice</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Student s1 = <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">"tom"</span>, <span class="number">22</span>);</span><br><span class="line">		Student s2 = <span class="keyword">new</span> Student(<span class="number">2</span>, <span class="string">"lina"</span>, <span class="number">12</span>);</span><br><span class="line">		Student s3 = <span class="keyword">new</span> Student(<span class="number">3</span>, <span class="string">"john"</span>, <span class="number">25</span>);</span><br><span class="line">		Student[] stus = <span class="keyword">new</span> Student[] &#123; s3, s1, s2 &#125;;</span><br><span class="line">		printStu(stus);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 比较器的返回值： </span></span><br><span class="line"><span class="comment">		 * 负数 ----&gt; 第一个参数应该放在前面 </span></span><br><span class="line"><span class="comment">		 * 0  ----&gt; 两个参数相等 </span></span><br><span class="line"><span class="comment">		 * 正数 ----&gt; 第二个参数应该放在前面</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//根据ID进行比较</span></span><br><span class="line">		Comparator&lt;Student&gt; idComparator = (o1, o2) -&gt; o2.id - o1.id;</span><br><span class="line">		<span class="comment">//根据年龄进行比较</span></span><br><span class="line">		Comparator&lt;Student&gt; ageComparator = (o1, o2) -&gt; o2.age - o1.age;</span><br><span class="line">		<span class="comment">//数组排序时传入比较器，按比较器规则进行排序</span></span><br><span class="line">		Arrays.sort(stus, idComparator);</span><br><span class="line">		printStu(stus);</span><br><span class="line">		Arrays.sort(stus, ageComparator);</span><br><span class="line">		printStu(stus);</span><br><span class="line">		<span class="comment">//生成堆的过程可以按照比较器进行排序</span></span><br><span class="line">		PriorityQueue&lt;Student&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(idComparator);</span><br><span class="line">		heap.add(s1);</span><br><span class="line">		heap.add(s3);</span><br><span class="line">		heap.add(s2);</span><br><span class="line">		<span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">			Student e = heap.poll();</span><br><span class="line">			System.out.println(e.id + <span class="string">"\t"</span> + e.name + <span class="string">"\t"</span> + e.age);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printStu</span><span class="params">(Student[] stus)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"======================="</span>);</span><br><span class="line">		<span class="keyword">for</span> (Student e : stus) &#123;</span><br><span class="line">			System.out.println(e.id + <span class="string">"\t"</span> + e.name + <span class="string">"\t"</span> + e.age);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"======================="</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr />
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>非基于比较的排序——桶排序</title>
    <url>/bucketSort.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前面我们学习过的O(N*log(N))级别的三个排序算法都是基于比较的排序算法，在工程中有着广泛的应用，但是还有一种时间复杂度更低，性能相对更好的排序算法——桶排序，而桶排序根据实现方式又分为基数排序和计数排序两种。那么为什么桶排序作为时间性能上更加高效的算法，却并没有在工程领域得到广泛的应用呢？原因在于桶排序算法不是基于比较的排序，而是基于词频的排序算法，那么一个排序算法基于什么到底对其有什么样的影响呢，本文就来分析和讨论一下。</p>
<a id="more"></a>

<h2 id="基于词频的排序算法"><a href="#基于词频的排序算法" class="headerlink" title="基于词频的排序算法"></a>基于词频的排序算法</h2><p>前面我们在学习排序算法时反复说排序的过程无非分为比较和交换两个步骤，但有时当我们已经<strong>对要排序的数据状况有了一定程度的了解</strong>之后，就可以设计出不需要比较原有序列中的元素就对其进行排序的算法，桶排序就是基于这样的设计理念产生的。可能你乍一听会想，这怎么可能呢？我都没有比较其中的元素，怎么可能知道两个元素的先后次序呢？其实，在你排序之前已经知道了，这就是所谓的桶。将排序中所有的可能情况分类成桶，桶与桶之间的相对次序一开始就是明确的，接下来我们只需要把元素放进相应的桶中，等到最后再从桶中挨个把元素拿出来，这时整个序列就被桶这个容器归类和排序了。</p>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>我们先来看一种最朴素也最暴力的实现方式——计数排序，形象来说就是“一个萝卜一个坑”，假设我们要排序的元素是十万个大小范围在【1~30】之间的整型数字，那么我们只需要准备30个桶，每个桶即是一个计数器，用于记录每个数字出现的次数。在遍历整个序列的过程中，遍历到某个数字就将对应桶中的计数器加一，等整个序列遍历结束，我们再根据这三十个桶的计数结果，按照桶的顺序和计数器的个数还原出这十万个数，就形成了有序序列。整个过程的时间复杂度为O(N)，这种排序方式相比于归并排序，快排和堆排序都要更快。</p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>看了计数排序的算法描述，你可能会对其提出质疑：如果要排序的范围比整个序列的大小还要大呢，岂不是时间和空间上都很浪费？确实，计数排序对数据状况的要求非常严格，很难遇到适用的场景，因此桶排序更为常用的一种实现方式为基数排序。所谓基于词频的排序，他与基于比较的排序最大的不同点在于需要提前去考虑待排序序列的数据状况，合理的将待排序的所有可能情况进行分类，且<strong>分类的方式必须是无交集，无缺失</strong>。分类的结果指明了需要用到的桶的数量，由于桶排序中我们需要遍历所有的桶来获取桶中的信息，所以桶的划分一定要越少越好，桶的数量直接影响算法的时间和空间复杂度。</p>
<p>计数排序中得益于特殊的数据状况，我们按照单个元素划分桶的方式就足以解决问题，但是实际情况下往往待排序序列的变化范围是很大的，有可能整个序列只有几万个元素，但是变化范围可能在正负几亿之间，这时我们就需要对我们的桶进行一个精巧的设计，使得只用有限个桶实现序列的排序，基数排序应运而生。其思想可以描述成<strong>按位多次排序</strong>，即虽然元素的变化范围很大，但是对应到位数上即便是上亿的数也不过9到10位，而每一位是由0到9中某一个数字来确定的，因此我们可以只通过10个桶，按位将序列中的元素放入桶中，此时虽然桶内和桶之间的元素都是无序的，但是某一位的数据却是有序的，我们将按位有序的结果记录下来，进行下一位的排序，依次执行到最后一位，整个序列的元素调整至有序。</p>
<blockquote>
<p>注：上述中的基数排序同样适用于非十进制数的排序，如二进制，八进制，十六进制等，此时桶的个数也调整为相应的2，8和16。</p>
</blockquote>
<h2 id="基数排序的实现"><a href="#基数排序的实现" class="headerlink" title="基数排序的实现"></a>基数排序的实现</h2><p>计数排序由于只需要在每个桶中记录单个元素的出现次数，所以直接用数组结构实现即可，由于元素的变化范围较小，所以不会出现数组所需空间较多的情况；而基数排序的桶中要保存序列中的元素值，因此其所需要的空间就很难确定，有可能出现空桶，也有可能所有的元素都跑到同一个桶中，因此采用链表结构较好，可以只申请O(N)的空间，而使用数组来放置元素则需要申请O(k*N)的空间才能保证每一次的排序过程都可以放下所有元素，其中k为待排序元素的进制数。</p>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><p>下面我们通过一个十进制的例子，来对基数排序的过程作进一步分析，考虑代码的设计。</p>
<ul>
<li>待排序序列：996，354，227，56，12，335，443，2，8，2009</li>
</ul>
<p>第一步：准备10个桶，分别用来放置某一位是0到9的元素</p>
<p>第二步：遍历序列找出最大值，以最大值的位数作为排序的次数，该例中最大数为2009，位数为4</p>
<p>第三步：遍历该序列，根据最低位将元素放入相应的桶中</p>
<table>
<thead>
<tr>
<th>桶号</th>
<th>元素1</th>
<th>元素2</th>
<th>元素3</th>
<th>……</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>12</td>
<td>2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>443</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>354</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>335</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>996</td>
<td>56</td>
<td></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>227</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>8</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>2009</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>第四步：将桶中的元素依次重新排成序列</p>
<ul>
<li>新序列（个位）：12，2，443，354，335，996，56，227，8，2009</li>
</ul>
<p>第五步：重复第三步和第四步，比较的位数依次递增</p>
<table>
<thead>
<tr>
<th>桶号</th>
<th>元素1</th>
<th>元素2</th>
<th>元素3</th>
<th>……</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>2</td>
<td>8</td>
<td>2009</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>12</td>
<td>227</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>335</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>443</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>354</td>
<td>56</td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>8</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>996</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>新序列（十位）：2，8，2009，12，227，335，443，354，56，996</li>
</ul>
<table>
<thead>
<tr>
<th>桶号</th>
<th>元素1</th>
<th>元素2</th>
<th>元素3</th>
<th>元素4</th>
<th>元素5</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>2</td>
<td>8</td>
<td>2009</td>
<td>12</td>
<td>56</td>
</tr>
<tr>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>227</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>335</td>
<td>354</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>443</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>8</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>996</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>新序列（百位）：2，8，2009，12，56，227，335，354，443，996</li>
</ul>
<blockquote>
<p>最后一次排序时，除了2009放入2号桶中，其余所有元素放入0号桶</p>
</blockquote>
<ul>
<li>新序列（千位）：2，8，12，56，227，335，354，443，996，2009</li>
</ul>
<p>最终整个序列有序。</p>
<h3 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h3><p>通过案例的排序过程，我们对整个流程有了一个大致的把握，其实基数排序的算法并不难理解，主要的操作也无非是入桶和出桶这两种操作，重点是对整个流程的把握和桶这一结构的设计。</p>
<h4 id="桶结构的设计"><a href="#桶结构的设计" class="headerlink" title="桶结构的设计"></a>桶结构的设计</h4><p>数据结构永远是最基础也最重要的一环，需要用到特殊数据结构的算法我们首先要对结构进行合理的设计。基数排序中桶的个数是确定的（0号到9号共10个桶），但桶中所要存储的元素个数是不确定的（可能出现空桶也可能出现一个桶中要存所有元素），所以我们可以将桶的集合用数组结构表示，而每个桶中元素的存储使用链表结构表示，这样设计可以有效节省存储空间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桶内链表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Elem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Elem next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Elem</span><span class="params">(<span class="keyword">int</span> value, Elem next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如代码所示，我们定义桶中的元素节点结构，包含元素值和指向桶内下一个元素的指针。同时，为了便于我们之后对桶内元素的判断，我们给每一个桶设置一个头结点，头结点中存储无意义的节点值，同时将该桶中的所有元素串起来。桶的初始化代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化各个桶的头结点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> buckets</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initBuckets</span><span class="params">(Elem[] buckets)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        buckets[i] = <span class="keyword">new</span> Elem(Integer.MIN_VALUE, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="主要操作"><a href="#主要操作" class="headerlink" title="主要操作"></a>主要操作</h4><p>前面我们说桶排序的核心操作包括入桶和出桶两项，但就整个流程来说，还包括案例中我们所做的求序列中最大值的位数、桶中元素生成新的序列等操作，下面我们来一一分析。</p>
<ul>
<li>入桶操作：每一个桶都是一个带头节点的链表，元素入桶时我们需要用到相应的元素值和桶指针，通过指针不断向下遍历，将当前元素值链到该桶的最后一个元素之后。代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 元素入桶</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bucket</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertBucket</span><span class="params">(<span class="keyword">int</span> value, Elem bucket)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (bucket.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        bucket = bucket.next;</span><br><span class="line">    &#125;</span><br><span class="line">    bucket.next = <span class="keyword">new</span> Elem(value, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>出桶操作：当我们遍历完一遍元素序列之后，我们需要将桶中的元素重新串成新的序列，为了节省空间可以直接对原序列空间进行覆盖。代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将桶中的数据覆盖回原序列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> buckets</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generateNewArray</span><span class="params">(<span class="keyword">int</span>[] arr, Elem[] buckets)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        Elem temp = buckets[i].next;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            arr[index++] = temp.value;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>确定需要排序的次数：即求序列中最大值的位数。代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求数组中最大元素的位数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxIndex</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; arr[maxIndex]) &#123;</span><br><span class="line">            maxIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[maxIndex];</span><br><span class="line">    maxIndex = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp / <span class="number">10</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        maxIndex++;</span><br><span class="line">        temp /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>清空桶：当一次排序结束后我们将桶中的数据 写回原序列，之后要将所有桶清空，以便下一次排序时元素入桶。代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空所有桶</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> buckets</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cleanBucket</span><span class="params">(Elem[] buckets)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        buckets[i].next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>主函数：外部函数组织了基数排序中所有操作的执行流程，其中关键的步骤在于如何确定当前元素该进入哪个桶，即如何取出元素相应位上的数。代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基数排序主函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radix</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.求最大值元素的位数</span></span><br><span class="line">    <span class="keyword">int</span> maxIndex = maxIndex(arr);</span><br><span class="line">    <span class="comment">//2.准备桶，初始化</span></span><br><span class="line">    Elem[] buckets = <span class="keyword">new</span> Elem[<span class="number">10</span>];</span><br><span class="line">    initBuckets(buckets);</span><br><span class="line">    <span class="comment">//3.按位循环，由低到高</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxIndex; i++) &#123;</span><br><span class="line">        <span class="comment">//4.遍历序列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="comment">//5.元素入桶（注意找桶的逻辑）</span></span><br><span class="line">            insertBucket(arr[j], buckets[arr[j] / (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, i) % <span class="number">10</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.生成新的序列</span></span><br><span class="line">        generateNewArray(arr, buckets);</span><br><span class="line">        <span class="comment">//7.清空桶</span></span><br><span class="line">        cleanBucket(buckets);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>在学习基于比较的排序算法时，我们说算法的稳定性是看元素的交换过程是否是跨元素的来判断，那么基于词频的排序算法的稳定性又如何来考量呢。通过分析算法的流程我们发现，在基数排序中<strong>相同值的元素必然在每一次排序的过程中都是处于同一个桶之中</strong>的，而元素入桶和出桶的顺序又是有序的，因此<strong>位于前面的元素在入桶时先入桶，出桶时先出桶，</strong>故基数排序是稳定的。</p>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>如果是使用链表结构实现的桶，那么基数排序的过程中只需要动态的申请O(N)的空间来暂存桶中元素的顺序，因此空间复杂度为O(N)</p>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>我们可以抛开求最大值位数、生成序列、清空桶等不构成复杂度最高的操作，只观察主函数中元素入桶的执行流程来推算整个算法的时间复杂度，抛开代码中比较具体的针对十进制数的排序，桶的个数应该是以单个位上的数字范围来确定的，二进制就是两个桶，八进制就是八个桶，十六进制则需要十六个桶，我们可以使算法时间复杂度的估算更具一般性。下面我们先将涉及到复杂度计算的变量抽象出来，有以下几个：</p>
<ul>
<li>n：待排序的数据规模，即代码中内层循环的次数——数组arr的个数</li>
<li>d：待排序的序列最大值的位数，即代码中外层循环的次数——maxIndex</li>
<li>k：桶的个数，即每一位数字可能出现的个数，代码中十进制的可能性为10</li>
</ul>
<p>对n和d这两个变量可以通过观察主函数很容易的看出对时间复杂度的影响，但是桶的个数是如何影响时间的呢。其实抽象地看，计数排序之所以只有O(N)的时间复杂度，是因为桶的数量很多，这是一种用空间来换时间的策略，所以桶越多排序的效率一定是越快的。那么具体到代码，我们应该如何定量的衡量呢。这里需要提到我们在设计桶结构时为了节省空间而采用链表结构来实现，这样带来的副作用是我们在元素入桶时需要承受一个查找桶的末尾的时间，因此排序的时间就和待排序的数据状况挂钩，如果每次入桶的数在十个桶中的分配很平均，那么元素入桶的时间就会很短，反之极端情况下所有元素都放进同一个桶中时，元素入桶的时间就是一个递增的数列。公式推导如下：</p>
<p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/bucketSort1.jpg" alt="bucketSort1"></p>
<p>如图所示，最好的情况下所有元素每一次都在k个桶之内平均分配，则一次排序的入桶过程要花费k次的1到n/k累加和，总共排序d次，时间复杂度为O(N<sup>2</sup>)；最差的情况下所有元素在每次排序时都进同一个桶（即排序的元素值都相同），则一次排序的入桶过程要花费k次的1到n累加和，总共排序d次，时间复杂度为O(N<sup>2</sup>)。最好和最差的时间复杂度虽然相差k<sup>2</sup>倍，但都是O(N<sup>2</sup>)级别，似乎和我们在其他地方看到的结论有些出入，这是什么原因呢。其实，这又是时间和空间上的一次取舍，还记得我们在设计桶的物理结构时，为了节省空间而使用链式结构作为每个桶中存储元素的方式吗，这样使得我们在元素入桶的时候，因为不知道链的长度而不得不承受一个遍历链表查找链尾的时间，增加了时间复杂度。</p>
<p>显然桶排序作为一种对数据状况有一定限制的排序算法，低时间复杂度是其和其他排序算法相“抗衡”的优势，如果时间复杂度为O(N<sup>2</sup>)，那么该算法就变得异常鸡肋，我们必须想办法降低时间复杂度。很容易想到的一种策略就是改变桶的物理结构，使用数组替换链表，数组对任意位置的元素可以实现O(1)时间的读取和设置，这样每个元素入桶的时间就是相同的，所有元素入桶的时间复杂度为O(N)，<strong>且此时的时间复杂度不存在最好和最差情况</strong>，整个算法的时间复杂度为d*k*N。如果是十进制元素浮动范围在亿左右的情况，常数项一般会在100左右，虽然很大，但是仍然不妨碍这个算法的时间复杂度被控制在O(N)的规模上，一旦待排序元素的规模变大，该算法在时间性能上的优势就会体现出来。就如同之前说的，时间和空间的取舍我们一旦选择了时间，空间上的弊端就暴露了出来，链表结构不存在空间上的最好最快情况，数组结构则不存在时间上的最好最坏情况，但空间上则存在。如果对多个相同元素进行排序，那么每一次入桶时所有元素就要进入同一个桶之中，这样就要求每一个桶的空间至少可以容乃所有元素，那么整个算法的空间复杂度为k*N，也算保持在O(N)规模，但k倍的空间复杂度意味着十万个待排序元素需要申请百万的空间来辅助，对于存储资源紧张的情况也是不能接受的。</p>
<h4 id="基数排序优化"><a href="#基数排序优化" class="headerlink" title="基数排序优化"></a>基数排序优化</h4><p>在我们对基数排序的时间和空间进行权衡之后，发现不论是选择时间还是空间，另一方的成本都使得该算法的性价比降得很低，那么是否我们可以想办法来对该算法进行优化，从而得出一个两全其美的策略呢。其实是有的，我们可以从两方面来考虑，如果选择时间放弃空间，那么k*N的空间是很难节省的，因为你无法确定待排序的数据情况，一旦出现单个桶中空间不足的情况就会出现内存溢出的问题；那么如果从空间入手，时间成本上我们可以考虑如何节省遍历链表的时间，由于元素入桶时我们往往只关心桶底的元素，我们只是希望将新入桶的元素挂在桶底，而非查找桶中的某个元素，因此每一次对桶内链表的遍历其实是没有必要的，我们完全可以使用一个指向桶底元素的指针来记录每次新元素要入桶的位置，这样每次元素入桶的时间就从O(N)降到了O(1)，并且我们只是增加了k个（桶的个数个）指针的有限空间就解决了这个问题。如此一来，整个算法的时间复杂度就变成了d*k*N，空间复杂度变成了k+N，时间空间复杂度同时控制在了O(N)级别，经过一系列优化该算法的竞争力也开始体现出来，同时由于入桶的时间和入桶的数据状况没有关系，因此不存在最好和最坏的时间复杂度。</p>
<p>下面我们来看一下原版代码需要改动的地方，首先就是数据结构的改动，为了主函数中的代码更加简洁，逻辑层次更分明，我们对桶集合进行了更高一级的封装，将每个桶的头和尾指针都封装在了一个桶集合对象中（当然你也可以用两个元素节点数组表示桶集合，那样主函数也要做相应的调整），头指针集合用于桶的遍历并覆写回原数组，尾指针集合用于元素入桶时记录位置，初始化时头尾指针都指向链表的头结点。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桶集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Buckets</span> </span>&#123;</span><br><span class="line">    Elem[] heads;</span><br><span class="line">    Elem[] tails;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Buckets</span><span class="params">(<span class="keyword">int</span> system)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.heads = <span class="keyword">new</span> Elem[system];</span><br><span class="line">        <span class="keyword">this</span>.tails = <span class="keyword">new</span> Elem[system];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heads.length; i++) &#123;</span><br><span class="line">            heads[i] = <span class="keyword">new</span> Elem(Integer.MIN_VALUE, <span class="keyword">null</span>);</span><br><span class="line">            tails[i] = heads[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次是元素入桶的过程，从原来的遍历入桶变成尾指针的后移完成，这里是整个算法时间复杂度降低的核心。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 元素入桶</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> buckets</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertBucket</span><span class="params">(<span class="keyword">int</span> value, Buckets buckets, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    buckets.tails[index].next = <span class="keyword">new</span> Elem(value, <span class="keyword">null</span>);</span><br><span class="line">    buckets.tails[index] = buckets.tails[index].next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次是覆写完成后清空桶的操作，新版本中需要同时将头尾指针的位置还原到初始化状态。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空所有桶</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> heads</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cleanBucket</span><span class="params">(Elem[] heads, Elem[] tail)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heads.length; i++) &#123;</span><br><span class="line">        heads[i].next = <span class="keyword">null</span>;</span><br><span class="line">        tail[i] = heads[i];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是主函数中对应的修改，相关方法的参数做了修改，故相应的方法调用传参也要发生变化，最主要的是入桶时要将桶的编号单独作为参数传入。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基数排序主函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radix</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.求最大值元素的位数</span></span><br><span class="line">    <span class="keyword">int</span> maxIndex = maxIndex(arr);</span><br><span class="line">    <span class="comment">//2.准备桶，初始化</span></span><br><span class="line">    Buckets buckets = <span class="keyword">new</span> Buckets(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//3.按位循环，由低到高</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxIndex; i++) &#123;</span><br><span class="line">        <span class="comment">//4.遍历序列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="comment">//5.元素入桶（注意找桶的逻辑）</span></span><br><span class="line">            insertBucket(arr[j], buckets, arr[j] / (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, i) % <span class="number">10</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.生成新的序列</span></span><br><span class="line">        generateNewArray(arr, buckets.heads);</span><br><span class="line">        <span class="comment">//7.清空桶</span></span><br><span class="line">        cleanBucket(buckets.heads,buckets.tails);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="桶的使用"><a href="#桶的使用" class="headerlink" title="桶的使用"></a>桶的使用</h2><p>在我们介绍完桶排序的两种具体实现之后我们再来看看桶这一数据结构，由于桶排序是不基于比较的排序方法，因此其使用场景是受限的，对待排序集合的数据状况有一定要求（这一点后文还会再展开），因此其使用的优先程度并不高，工程领域的重要程度也不及快排和归并排序，我们更应该把关注的重点放到桶这一数据结构上来。相信经过上面的介绍，我们对桶已经有了一定的认识，桶其实就是一个分类的容器，我们想要对数据做精细的处理时，避免不了对给定集合中数据的分类，而分类后数据暂存的容器我们都可以将其称之为桶，它的实现可以是数组，链表，二叉树（堆）等等。下面我们通过一道算法题来感受一下桶的妙用。</p>
<blockquote>
<p>题目： 给定一个数组， 求如果排序之后， 相邻两数的最大差值， 要求时间复杂度O(N)， 且要求不能用非基于比较的排序。 </p>
<p>案例：输入【1，2，6，3，7】；输出 3</p>
</blockquote>
<ul>
<li>分析：题目中明确要求了不能用非基于比较的排序，意味着我们不能通过计数排序或基数排序算法先将整个序列变有序之后再从头到尾遍历得到最大差值，而就我们已知的基于比较的排序算法中，也没有时间复杂度可以达到O(N)级别的排序算法，因此这道题对我们的要求就是在整个序列未完成排序的情况下求出排序后相邻两数的最大差值。</li>
<li>思路：虽然我们无法使用桶排序算法，但我们依然可以借助桶这一概念，正如前文提到的，桶的作用就是一个分类器，我们把数组中有相同特征的元素放进相同的桶中，通过桶之间的逻辑关系来求解最终的答案。这样说有些抽象，以上文中提到过的基数排序为例，我们想要得到的是元素之间的顺序关系，那么桶的设计就要体验出数字之间的顺序，这样当某一位上相同数字的元素放入同一个桶中之后，本轮元素的顺序关系就可以得到。回到这道题中，我们希望得到元素之间的差值关系，那么可以尝试构造出桶与桶之间的差值关系，将差距不大的元素放入同一个桶中，这样我们就不需要逐个比较元素之间的差值，毕竟这样做有意义的前提是我们需要将数组排序，下面来看我们的方案。</li>
<li>方案：遍历找出N个元素中的最大值和最小值，将最大值和最小值之间的范围等分N+1份；构造N+1个桶用来将大小在范围内的元素放入相应的桶中，每个桶记录入桶的元素最大值和最小值；遍历数组，元素入桶；遍历每个桶，找出桶与桶之间的最大值和最小值的最大差值即为所求结果。</li>
<li>证明：这里我们来证明一下这个方案的可行性，首先N个元素放入N+1个桶中，至少有一个空桶。其次我们是以数组中的最大值和最小值作为范围进行桶的划分的，因此第一个桶和最后一个桶必不为空桶，分别至少有最小值和最大值一个元素，故空桶一定位于中间的某个桶中。下面我们只需要证明序列的<strong>最大差值</strong>不出现在桶内元素之间而是<strong>出现在跨桶元素之间</strong>即可，这里可以使用<strong>反证法</strong>来说明（具体公式证明过程略）。假设整个序列的最大差值出现在某一个桶中，记为maxGap，桶的范围记为R，则必然有maxGap≤R，又已知第0号桶到第N号桶之间必然存在至少一个空桶，记为E号桶。此时E-1号桶和E+1号桶可能为空也可能有元素，当这两个桶中有元素，且E-1号桶中的最大元素（记为max<sup>E-1</sup>）为该桶范围的最大值，E+1号桶中的最小元素（记为min<sup>E+1</sup>）为该桶范围的最小值时，max<sup>E-1</sup>和min<sup>E+1</sup>之间的差值最小，为R+2＞R=maxGap，因此必然存在一个差值大于我们假设的桶内最大差值，故假设不成立，最大差值来自桶与桶之间，证明完毕。</li>
<li>注意：有同学可能会有些疑惑方案中为什么要逐个遍历桶与桶之间的差值关系，而不是直接使用空桶两边的差值最为最终答案。诚如证明中所论证的，我们设计桶分类元素求最大差值只是想要确保元素之间的最大差值并非来源于桶内元素，并且我们也只能证明这一点，而无法证明最大差值一定来自于空桶两侧的元素。这里我们可以借用证明中所用到的max<sup>E-1</sup>和min<sup>E+1</sup>这一特殊情况来举一个反例说明这一点，假设空桶两侧正好存在这两个元素，而在E+2号桶中存在唯一一个元素正好是该桶范围的最大值，这里记为max<sup>E+2</sup>，此时E号桶空桶两侧的最大差值为R+2，而非空桶E+1和E+2之间的最大差值约为2R，当R＞2时即最大差值不来自空桶两侧，这样的反例非常容易构造，大家可以尝试验证一下。</li>
</ul>
<p>下面我们来看代码，有了上面的分析我们的思路就比较清晰了，可以将整个过程分为以下几个部分：</p>
<ol>
<li>遍历数组，求最大最小值</li>
<li>设计桶结构并对其初始化</li>
<li>计算每个元素所对应的桶，并将元素入桶</li>
<li>遍历桶找出最大差值</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求数组中的最大值和最小值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] absoluteValue(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            max = Math.max(max, arr[i]);</span><br><span class="line">            min = Math.min(min, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;max, min&#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 确定该数应该放入哪个桶</span></span><br><span class="line"><span class="comment">     * 这里进行了一个简单的数值计算，注意计算结果需要保证边界值不重复不遗漏</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> max</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> min</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">determainIndex</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> len, <span class="keyword">int</span> max, <span class="keyword">int</span> min)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) ((num - min) * len / (max - min));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 桶结构设计</span></span><br><span class="line"><span class="comment">     * 其中布尔变量用于记录桶内是否进入过元素，不必须但增加该变量可以提高代码的可读性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Bucket</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxValue;</span><br><span class="line">        <span class="keyword">int</span> minValue;</span><br><span class="line">        <span class="keyword">boolean</span> enter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buckets</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 初始化桶集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initBucket</span><span class="params">(Bucket[] buckets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">            buckets[i] = <span class="keyword">new</span> Bucket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 元素入桶</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bucket</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> elemValue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertBucket</span><span class="params">(Bucket bucket, <span class="keyword">int</span> elemValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bucket.enter) &#123;</span><br><span class="line">            bucket.minValue = Math.min(bucket.minValue, elemValue);</span><br><span class="line">            bucket.maxValue = Math.max(bucket.maxValue, elemValue);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bucket.enter = <span class="keyword">true</span>;</span><br><span class="line">            bucket.maxValue = elemValue;</span><br><span class="line">            bucket.minValue = elemValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 遍历桶集合寻找最大差值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buckets</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calMaxMinus</span><span class="params">(Bucket[] buckets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> temp = buckets[<span class="number">0</span>].maxValue;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buckets[i].enter) &#123;</span><br><span class="line">                max = Math.max(max, buckets[i].minValue - temp);</span><br><span class="line">                temp = buckets[i].maxValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 主函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxMinus</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = arr.length;</span><br><span class="line">        Bucket[] buckets = <span class="keyword">new</span> Bucket[length + <span class="number">1</span>];</span><br><span class="line">        initBucket(buckets);</span><br><span class="line">        <span class="keyword">int</span> maxMin[] = maxMinElem(arr);</span><br><span class="line">        <span class="keyword">int</span> max = maxMin[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> min = maxMin[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (max == min) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = determainIndex(arr[i], length, min, max);</span><br><span class="line">            insertBucket(buckets[index], arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxMinus = calMaxMinus(buckets);</span><br><span class="line">        <span class="keyword">return</span> maxMinus;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="桶排序的局限性"><a href="#桶排序的局限性" class="headerlink" title="桶排序的局限性"></a>桶排序的局限性</h2><p>在实际的工程领域中，桶排序的适用范围相较于其他基于比较的排序算法而言是具有局限性的，为什么这么说。一个基于比较的排序算法，我们所要具备的基础仅仅是元素之间比较大小的标准，知道了如何比较元素之间的大小我们就可以实现该比较方法的比较器函数，即便是面对未知的数据状况我们也可以通过比较算法得到最终有序结果；而桶排序则不然，基于词频统计的排序我们既要直到元素之间的大小顺序，还要对数据状况有一定的了解，如果待排序的数据范围过大又不太适合使用桶排序，即便是基数排序这样精致的设计桶的使用，也付出了一定的空间代价，这也印证了我们在学习桶排序时发现虽然这个算法很好用，省时省力但它的算法地位相对于快排的地位没有那么高，因为他总与数据状况有关，总有瓶颈。</p>
<hr />
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>基数排序</tag>
        <tag>计数排序</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言基本概念</title>
    <url>/c1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>C语言诞生于20CD70s，经过演变和发展形成了C89（或C90）和C99这两个通用标准，后者由于出现较晚还未被所有编译器完全兼容。许多现代流行语言例如C++，Java，C#，Perl都是基于C语言并包含各自的特性发展起来的，学习C语言有助于我们更好地理解其他语言。</p>
<a id="more"></a>

<h2 id="C语言特性"><a href="#C语言特性" class="headerlink" title="C语言特性"></a>C语言特性</h2><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>C语言是一种底层语言，提供了机器级概念的访问，例如对字节和地址</li>
<li>C语言是一种小型语言，只提供了一个有限的特性集合，这是因为其在很大程度上依赖一个标准函数的库</li>
<li>C语言的优点在于高效，可移植，功能强大，灵活，标准库，与Unix系统的集成</li>
<li>C语言的缺点在于不容易及时发现错误，可能会难以理解和修改（这一点是面向过程开发语言的弊端）</li>
</ul>
<h3 id="使用原则"><a href="#使用原则" class="headerlink" title="使用原则"></a>使用原则</h3><ul>
<li>借助于<acronym title="Integrated Development Environment">IDE</acronym>（集成开发环境）进行编译和调试，可有效显示错误信息</li>
<li>复用现有的代码库，提高开发效率，节省试错成本</li>
<li>采用一套切合实际的编码规范，避免“投机取巧”和极度复杂的代码</li>
<li>紧贴标准，若非必要，避免使用不属于C89和C99标准的特性和库函数</li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="C程序的执行过程"><a href="#C程序的执行过程" class="headerlink" title="C程序的执行过程"></a>C程序的执行过程</h3><p>对于任何一个.c文件，要想转化成机器可以执行的形式，需要经过以下三个步骤：</p>
<ol>
<li><strong>预处理</strong> 预处理器（preprocessor）执行以#开头的指令，其功能类似于编辑器，为程序添加内容或修改内容</li>
<li><strong>编译</strong> 编译器（compiler）把修改后的程序翻译成机器指令，即目标代码</li>
<li><strong>链接</strong> 链接器（linker）把目标代码和其他所需的附加代码（包括程序中用到的库函数）进行整合，最终形成可执行程序</li>
</ol>
<blockquote>
<p>GCC编译器面向Linux平台，是最流行的C语言编译器之一。最初是GUN C compiler的缩写，新版的GCC能够编译多种语言写的程序，因此变为GUN Compiler Collection的简称。其优点在于免费获取，兼容多种操作系统，广泛用于商业开发。</p>
</blockquote>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">GCC编译器的安全检查选项</span><br><span class="line">-<span class="ruby">Wall			使编译器在检测到可能的错误时生成警告信息</span></span><br><span class="line"><span class="ruby">-W			除以上警告信息外，生成针对具体情况的额外警告信息</span></span><br><span class="line"><span class="ruby">-pedantic		根据c标准的要求生成警告信息，避免程序中使用非标准特性</span></span><br><span class="line"><span class="ruby">-ansi			禁用GCC的非标准C特性，并启用一些不太常用的标准特性</span></span><br><span class="line"><span class="ruby">-std=c89/C99		指明使用哪个版本的C编译器来检查程序</span></span><br><span class="line"><span class="ruby">以上选项通常结合使用：</span></span><br><span class="line"><span class="ruby">% gcc -O -Wall -W -pedantic -ansi -std=c99 -o pun pun.c</span></span><br></pre></td></tr></table></figure>

<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>通常我们把预处理器执行的命令叫做指令，即以字符#开头的代码，指令默认只占一行，其结尾没有其他符号标识，通常包括以下几种</p>
<ul>
<li><strong>宏定义</strong>（macro definition） <code>#define</code> 用于定义函数中所用到的常量</li>
<li><strong>包含程序</strong> <code>#include</code> 用于引入C程序所需的头文件（.h文件）</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>事实上C语言就是函数的集合，函数类似于其他编程语言中的例行程序（routine）和子例程（subroutine），是用来构建程序的构建块，分为以下两种：</p>
<ul>
<li>程序员编写的函数</li>
<li>C语言实现的一部分提供的函数，称为<strong>库函数</strong></li>
</ul>
<p>一个C程序可以包含多个函数，但是<code>main</code>函数是不可或缺的，且只能有几个，作为程序的入口，执行时系统会自动调用<code>main</code>函数</p>
<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>语句是程序运行时执行的命令，包括以下几种</p>
<ul>
<li>返回语句，例如<code>return 0;</code></li>
<li>函数调用语句（function call），例如<code>printf(&quot;hello world\n&quot;);</code></li>
</ul>
<p>每一条完整的语句必须要以;作为结束标识符</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>即文档说明，每一个程序都应该包含识别信息，即程序名，编写日期，作者，程序的用途以及其他相关信息，以便对程序进行更好的理解和阅读</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*	单行注释内容	*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	多行注释内容</span></span><br><span class="line"><span class="comment"> *	....</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C99提供的单行注释格式，注释内容会在行末自动终止</span></span><br><span class="line"></span><br><span class="line">注意：注释内部不能嵌套使用</span><br></pre></td></tr></table></figure>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量是指C语言中的存储单元，每个变量必须有一个类型（type），用于表示所存储的数据种类，如整型、浮点型、字符型。<br>在使用变量之前必须对其进行声明，声明方式为<code>类型名 变量名;</code>，如果几个变量类型相同，则可采取合并声明，声明方式为<code>类型名 变量名1,变量名2,变量名3;</code></p>
<blockquote>
<p>C语言的编码规范为先将函数中所需要使用的变量在函数开始统一声明，再在之后的语句中使用，而在C99和其他语言规范中多采用使用时才声明的方式。</p>
</blockquote>
<p>声明过后通过要给变量赋值，也称为变量的初始化，赋值方式为<code>变量名 = 常量;</code>，通常情况下我们要保证所赋值的类型和变量的类型要保持统一，混合类型赋值可能会不安全，其中在对float类型的变量进行赋值的时候需要在常量后添加小写字母f</p>
<h3 id="标识符（indentifier）"><a href="#标识符（indentifier）" class="headerlink" title="标识符（indentifier）"></a>标识符（indentifier）</h3><p>用于对变量、函数、宏和其他实体进行命名，命名规则如下：</p>
<ul>
<li>标识符只能含有字母、数字和<code>_</code>（下划线）</li>
<li>必须以字母或<code>_</code>（下划线）作为开头</li>
</ul>
<p>注意C语言是区分大小写的，在命名时尽可能的保持标识符的可分辨性</p>
<h3 id="关键字（keyword）"><a href="#关键字（keyword）" class="headerlink" title="关键字（keyword）"></a>关键字（keyword）</h3><p>对C编译器而言具有特殊意义，不能用来作为标识符</p>
<p>|  |  |  |  |<br>| :—: | :—: | :—: | :—: | :—: |<br>| auto | enum | restrict<sup>1</sup> | unsigned |<br>| break | extern | return | void |<br>| case | float | short | volatile |<br>| const | goto | sizeof | _Bool<sup>1</sup> |<br>| continue | if | static | _Complex<sup>1</sup> |<br>| default | inline<sup>1</sup> | struct | _Imaginary<sup>1</sup> |<br>| do | int | switch |  |<br>| double | long | typedef |  |<br>| else | register | union |  |</p>
<blockquote>
<p>有角标<sup>1</sup>的关键字是C99新增的</p>
</blockquote>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>基本概念</tag>
        <tag>语言特性</tag>
      </tags>
  </entry>
  <entry>
    <title>CYFF（一）：念念不忘</title>
    <url>/cyff1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大二下学期社团大佬找到我们，说长春青年影展（CYFF）想和吉大合作将南校区作为影展的放映场地之一，我们来组织这次的放映，这也是继FIRST之后又一电影节与社团的合作活动。不同的是CYFF是长春本土的影展，于我们而言感到更加亲切，后来几次和策展人的接触中也留下了很好的印象。因此在次年的影展筹备活动中，策展人找到我希望我能负责第四届CYFF的设计工作，我也很开心的接受了。<br>说实话，第一次在这样的活动中承担设计工作心里是有点虚的，毕竟自己也只是个业余水平，不知道能否拿下这项任务，于是为了能拿出好的作品费了不少心思。设计风格也尝试了很多种，有了FIRST的经验想法也慢慢成熟，风格上还是以简约的风格为主，配以富有意义的图案，在发给策展人审核的时候也得到了认可，虽然最后在印制时没有采用所有的方案，我也还是很开心。</p>
<a id="more"></a>

<blockquote>
<p>长春青年电影节致力于于民间影像的推广与放映，力图创造一个依托高校放映的民间学术交流平台，为国内新锐导演提供一个展映作品的空间，也为观众开拓一个交流国内外独立电影和独立纪录片的环境。影展致力于扩展放映与交流相呼应的放映氛围，放映后设有讨论和问答环节，在这里观众们不仅可以一同探讨不同类型的影片，还有机会与导演现场交流或连线。鼓励大众成为影片的评论者，长春青年电影节是一个激发青年思维活力想象自由的场所。</p>
</blockquote>
<h2 id="第四届长春青年电影节——邀请函折页（外侧）"><a href="#第四届长春青年电影节——邀请函折页（外侧）" class="headerlink" title="第四届长春青年电影节——邀请函折页（外侧）"></a>第四届长春青年电影节——邀请函折页（外侧）</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/cyff11.jpg" alt="第四届长春青年电影节——邀请函折页（外侧）"></p>
<h2 id="第四届长春青年电影节——邀请函折页（里侧）"><a href="#第四届长春青年电影节——邀请函折页（里侧）" class="headerlink" title="第四届长春青年电影节——邀请函折页（里侧）"></a>第四届长春青年电影节——邀请函折页（里侧）</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/cyff12.jpg" alt="第四届长春青年电影节——邀请函折页（里侧）"></p>
<h2 id="第四届长春青年电影节——吊牌"><a href="#第四届长春青年电影节——吊牌" class="headerlink" title="第四届长春青年电影节——吊牌"></a>第四届长春青年电影节——吊牌</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/cyff13.jpg" alt="第四届长春青年电影节——吊牌"></p>
<h2 id="第四届长春青年电影节——感谢状"><a href="#第四届长春青年电影节——感谢状" class="headerlink" title="第四届长春青年电影节——感谢状"></a>第四届长春青年电影节——感谢状</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/cyff14.jpg" alt="第四届长春青年电影节——感谢状"></p>
<h2 id="第四届长春青年电影节——海报1"><a href="#第四届长春青年电影节——海报1" class="headerlink" title="第四届长春青年电影节——海报1"></a>第四届长春青年电影节——海报1</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/cyff15.jpg" alt="第四届长春青年电影节——海报1"></p>
<h2 id="第四届长春青年电影节——海报2"><a href="#第四届长春青年电影节——海报2" class="headerlink" title="第四届长春青年电影节——海报2"></a>第四届长春青年电影节——海报2</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/cyff16.jpg" alt="第四届长春青年电影节——海报2"></p>
<h2 id="第四届长春青年电影节——海报3"><a href="#第四届长春青年电影节——海报3" class="headerlink" title="第四届长春青年电影节——海报3"></a>第四届长春青年电影节——海报3</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/cyff17.jpg" alt="第四届长春青年电影节——海报3"></p>
<h2 id="第四届长春青年电影节——展架2（暗）"><a href="#第四届长春青年电影节——展架2（暗）" class="headerlink" title="第四届长春青年电影节——展架2（暗）"></a>第四届长春青年电影节——展架2（暗）</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/cyff18.jpg" alt="第四届长春青年电影节——展架2（暗）"></p>
<h2 id="第四届长春青年电影节——展架2（亮）"><a href="#第四届长春青年电影节——展架2（亮）" class="headerlink" title="第四届长春青年电影节——展架2（亮）"></a>第四届长春青年电影节——展架2（亮）</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/cyff19.jpg" alt="第四届长春青年电影节——展架2（亮）"></p>
<h2 id="第四届长春青年电影节——展架1（大图）"><a href="#第四届长春青年电影节——展架1（大图）" class="headerlink" title="第四届长春青年电影节——展架1（大图）"></a>第四届长春青年电影节——展架1（大图）</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/cyff110.jpg" alt="第四届长春青年电影节——展架1（大图）"></p>
<h2 id="第四届长春青年电影节——展架1（小图）"><a href="#第四届长春青年电影节——展架1（小图）" class="headerlink" title="第四届长春青年电影节——展架1（小图）"></a>第四届长春青年电影节——展架1（小图）</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/cyff111.jpg" alt="第四届长春青年电影节——展架1（小图）"></p>
<hr />
]]></content>
      <categories>
        <category>平面设计</category>
      </categories>
      <tags>
        <tag>海报</tag>
        <tag>电影</tag>
        <tag>影展</tag>
      </tags>
  </entry>
  <entry>
    <title>CYFF（二）：必有回响</title>
    <url>/cyff2.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在CYFF做志愿者的这半年，是我的设计水平突飞猛进的一段时间，从最开始顶着压力接下这个活，每天都在pinterest寻找灵感，虽然自己有不少想法，但是没有什么美术功底的我在构图和色彩的把握上实在是有些力不从心，只好选择一些极简的风格来做。可能也是那段时间疯狂的喜欢上香港漫画家智海的漫画，对他那简单而又精致的线条着了迷，便找了很多线条纹路的图案和纹理，拼接出了很多作品。简单的东西总能给人以舒适和高级的感觉，因为生活中我们太容易对五光十色的东西产生审美疲劳，而当你面对简单的图案和大面积的留白时，思维就会不自然的放松和发散开来。</p>
<p>作品被人认可可能是对设计者莫大的欣慰，因为你会明白人们不仅认可了你的辛劳，更是认可了你的审美，第二年CYFF举办之前策展人也曾找我再为影展做一次设计工作，很可惜那段时间忙于考研没有抽出时间来。到这里，大学期间我的设计作品也全部上传完了，在影协的这段经历是我大学期间投入很大精力的一部分，我应该会很难忘记，能够做自己感兴趣的事情无疑是幸运的，当你默默为了自己热爱的事情不懈付出之后，终究会有人认可。</p>
<p>要记住，念念不忘，必有回响。</p>
<a id="more"></a>

<blockquote>
<p>长春青年电影节致力于于民间影像的推广与放映，力图创造一个依托高校放映的民间学术交流平台，为国内新锐导演提供一个展映作品的空间，也为观众开拓一个交流国内外独立电影和独立纪录片的环境。影展致力于扩展放映与交流相呼应的放映氛围，放映后设有讨论和问答环节，在这里观众们不仅可以一同探讨不同类型的影片，还有机会与导演现场交流或连线。鼓励大众成为影片的评论者，长春青年电影节是一个激发青年思维活力想象自由的场所。</p>
</blockquote>
<h2 id="宣传册（p1p2）"><a href="#宣传册（p1p2）" class="headerlink" title="宣传册（p1p2）"></a>宣传册（p1p2）</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/cyff21.jpg" alt="第四届长春青年电影节——宣传册（p1p2）"></p>
<h2 id="宣传册（p3p4）"><a href="#宣传册（p3p4）" class="headerlink" title="宣传册（p3p4）"></a>宣传册（p3p4）</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/cyff22.jpg" alt="第四届长春青年电影节——宣传册（p3p4）"></p>
<h2 id="宣传册（p5p6）"><a href="#宣传册（p5p6）" class="headerlink" title="宣传册（p5p6）"></a>宣传册（p5p6）</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/cyff23.jpg" alt="第四届长春青年电影节——宣传册（p5p6）"></p>
<h2 id="宣传册（p7p8）"><a href="#宣传册（p7p8）" class="headerlink" title="宣传册（p7p8）"></a>宣传册（p7p8）</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/cyff24.jpg" alt="第四届长春青年电影节——宣传册（p7p8）"></p>
<h2 id="宣传册（p9p10）"><a href="#宣传册（p9p10）" class="headerlink" title="宣传册（p9p10）"></a>宣传册（p9p10）</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/cyff25.jpg" alt="第四届长春青年电影节——宣传册（p9p10）"></p>
<h2 id="宣传册（p11p12）"><a href="#宣传册（p11p12）" class="headerlink" title="宣传册（p11p12）"></a>宣传册（p11p12）</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/cyff26.jpg" alt="第四届长春青年电影节——宣传册（p11p12）"></p>
<h2 id="宣传册（p13p14）"><a href="#宣传册（p13p14）" class="headerlink" title="宣传册（p13p14）"></a>宣传册（p13p14）</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/cyff27.jpg" alt="第四届长春青年电影节——宣传册（p13p14）"></p>
<h2 id="宣传册（p15p16）"><a href="#宣传册（p15p16）" class="headerlink" title="宣传册（p15p16）"></a>宣传册（p15p16）</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/cyff28.jpg" alt="第四届长春青年电影节——宣传册（p15p16）"></p>
<h2 id="宣传册（p17p18）"><a href="#宣传册（p17p18）" class="headerlink" title="宣传册（p17p18）"></a>宣传册（p17p18）</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/cyff29.jpg" alt="第四届长春青年电影节——宣传册（p17p18）"></p>
<h2 id="宣传册（p19p20）"><a href="#宣传册（p19p20）" class="headerlink" title="宣传册（p19p20）"></a>宣传册（p19p20）</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/cyff210.jpg" alt="第四届长春青年电影节——宣传册（p19p20）"></p>
<h2 id="宣传册（封面，封底）"><a href="#宣传册（封面，封底）" class="headerlink" title="宣传册（封面，封底）"></a>宣传册（封面，封底）</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/cyff211.jpg" alt="第四届长春青年电影节——宣传册（封面，封底）"></p>
<hr />
]]></content>
      <categories>
        <category>平面设计</category>
      </categories>
      <tags>
        <tag>电影</tag>
        <tag>影展</tag>
        <tag>宣传册</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构概述</title>
    <url>/dataStructrue.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>计算机领域许多概念都是生活中实际问题的抽象表达，因为这一学科在诞生时本身就具有很强的工程倾向，其目的就是高效的解决现实中的许多问题，在数据结构这一部分尤为明显。例如我们在生活中常常面临的物品堆积问题和排队问题就分别可以抽象成栈和队列这两种数据结构，由于实际情况中这些问题非常普遍也使得这两种数据结构成为工程实践过程中最常用的两种数据结构，这也是我们在学习算法和数据结构时最先接触这两种数据结构的原因。那么究竟什么是数据结构呢，今天我们就来一探究竟。</p>
<a id="more"></a>

<h2 id="所谓“结构”"><a href="#所谓“结构”" class="headerlink" title="所谓“结构”"></a>所谓“结构”</h2><p>我们在学习数据结构之前首先要对结构的划分有一个清晰的认识，否则后面对一些名词的分类和含义在理解上可能会出现一些偏差，例如线性表和链表是同一个结构吗？如果是包含关系，两者谁的范围又更广呢？要搞清楚这些问题，我们先得明确两个名词——“物理结构”和“逻辑结构”。</p>
<h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><p>我们知道，计算机存储数据是通过一个个顺序排列的存储单元来实现的，每个存储单元只能通过高低电平来表示0、1两个值，那么不论我们要存储多么复杂的结构，实际上也是通过一个个存储单元的序列来表示的，我们把数据在存储单元中的存储方式叫做“物理结构”。有同学可能会不理解，如果存储序列是像数组一样一个接一个的并列着，那么不是只能像数组一样按顺序一个个存储吗，还能有别的存储方法吗。其实除了这样的<strong>顺序存储</strong>方式，还有一种存储方式叫做<strong>链式存储</strong>，指的是前一个元素中包含下一个元素的起始地址，就像火车的车厢一样前一节的尾部挂着后一节的头部，也可以理解为排队过程中每个人只要记得自己前面的人是谁就不怕下一次无法还原这个排序（当然第二个例子不太恰当，因为链式存储中一般都是前一个元素记住后一个元素是谁）。</p>
<p>从上面的介绍我们可以推断出两种物理结构各自的存储特点了，在前面讲算法的时间复杂度时我们曾提过，获取数组元素的时间复杂度为O(1)，因为数组在内存空间上就是顺序存储的物理结构，CPU可以通过简单地数值计算进行内存寻址，因此顺序存储的优点在于快速读取，不论是获取序列中的第几个元素，其时间复杂度都是相同的。但是顺序存储的数据是不便于扩展的，因为你无法确定待扩展的下一个内存地址是否被占用，如果占用的话，将扩展的元素放到下一个空闲的位置又无法保证每个元素的连续性，这样只能开辟一块更大的空闲内存地址范围，将原来的序列复制到新申请的位置，继而存放新的元素，如果序列的扩展操作频繁，这种方式必然是低效的，根源就是<strong>无法解决内存空间的碎片化</strong>（注意此处的无法解决指无法在较小的成本下解决该问题）。</p>
<p>而链式存储的优缺点和顺序存储正好相反，链式存储不要求元素之间的位置连续，那么就便于我们对序列进行扩展和删减，避免了内存空间碎片化所造成的问题。但是由于整个数据的序列关系保存在每个元素中，所以我们获取某个元素时必须要遍历整个序列，时间为O(N)，这样就不适用于需要频繁读取的操作，时间成本较高。另外由于链式存储中前一个元素要携带下一个元素的地址信息，因此相比顺序存储还需申请额外的内存空间。</p>
<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>了解了物理结构，我们就知道数据怎么在计算机中存储了，你可能会疑惑那为什么还要有逻辑结构呢。因为人毕竟不是计算机，两者的思考方式和擅长的方面完全不同，计算机可以很快的计算出两个十位数相乘的结果，却难以识别一只猫，人则刚好相反，所以逻辑结构通俗的理解就是站在人的角度去组织数据，使用数据的分类方式。逻辑结构由简到繁可以大致划分为四类——集合、线性表、树和图，虽然每种结构有一些概念层面的定义，但是还是很容易让人联想到现实生活中的事物，这里我们先按下不表，后面会对每种结构进行展开。</p>
<p>这里我们需要着重说明的是<strong>物理结构和逻辑结构之间没有严格的对应关系</strong>，每种逻辑结构既可以用顺序存储来实现，也可以用链式存储实现，<strong>比较复杂的逻辑结构还需要两种存储方式结合起来实现</strong>。在<strong>逻辑结构层面我们更加关心的是这个结构需要实现哪些功能</strong>，而在<strong>物理层面我们则是考虑如何通过封装来实现所需功能</strong>，这样解释可能有些同学还是觉得比较抽象和陌生，不知道该如何来操作，那是因为在我们学习编程语言的过程中，不论你是C语言，C++，C#，Java还是Python等等，语言的设计者已经对许多逻辑结构和功能进行了封装，我们最开始接触的数组结构其实就是顺序存储的线性结构的简单实现，而链式存储则在不同语言中有不同的实现，例如C语言等中的指针，Java中类的定义和引用。毕竟语言的发展使得我们越来越少与操作系统和硬件打交道，许多逻辑结构已经被语言自带的库封装的很好用了，我们只需要调用接口记忆可以实现其功能，但是学习这些结构的内部功能和实现也是很有必要的，如果一个东西对我们而言只是一个黑盒，那我们就无法将其用到极致。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>这里我们以最简单的集合结构来举例，集合的定义很简单，就是元素之前没有任何关系，既没有顺序先后，也没有连接所属关系，仅仅是位于一个范围中，有些结构的设计中集合中的元素是不可以重复的，这种限制使得集合更偏向于数学中的概念，我们这里也按照这种设定去实现。集合的操作一般可以分为以下几个，同时为每个功能命名：</p>
<ol>
<li>创建集合（构造方法）</li>
<li>计算集合大小（size）</li>
<li>判断集合是否为空（isEmpty）</li>
<li>向集合中添加元素（push）</li>
<li>从集合中随机取出一个元素（pop）</li>
</ol>
<div class="note warning"><p>由于我们使用Java进行代码的实现，语言特性中的自动垃圾回收机制使得我们不用考虑对申请的内存空间进行手动释放，如果是使用C语言实现则需要考虑封装析构方法</p></div>
### 顺序存储实现

<p>首先，我们采用顺序存储的方式来实现集合结构，顺序存储的局限在于集合的容量会有上限，因此我们需要考虑在集合中加入元素时处理扩展集合容量的问题；另一个问题是从集合中获取元素和加入元素时由于集合是无序的，需要保证随机性，又由于顺序存储时元素之间是相互挨着的，所以我们可以通过随机数人为地打乱插入和取出的次序，以此来模拟集合的无序性。但是这样一来又会随之伴生两个问题，一是随着插入的元素越来越多，整个内存空间上可以被用来放置新元素的位置越来越少，在还没有对集合进行扩容之前，我们随机选择的插入位置已经被占用的概率越来越高；二是相对的在集合中没有多少元素的情况下，我们随机从集合中取出一个元素时，随机选择的位置没有元素的概率也会越来越高。其中第一个问题类似于我们在解决哈希冲突时所遇到的问题，解决这个问题最简单的方法就是从当前位置依次往下寻找下一个空位放进去，这样解决相比重新随机位置要高效很多，但是随机性就会差一些，因为寻找空闲位置总是沿着相同的方向和步长，这里我们就要加入一些随机条件来稀释其规律性，增加随机性。我们将整个集合结构封装成一个SeqCollection类，下面我们来看一下代码：</p>
<div class="note warning"><p>出于简化代码逻辑，避免过多与核心功能无关的代码，我们将元素类型设定为整型数字</p></div>
* 首先是类的五个内部成员变量：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当前集合的容量上限</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> ceiling = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//用于增加解决地址冲突时寻址的随机性设置方向标识</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//用于存储集合中的元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> value[];</span><br><span class="line"><span class="comment">//用于保存数组各个位置是否存放了元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> occupy[];</span><br><span class="line"><span class="comment">//当前集合中元素的数目</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>

<ul>
<li>其次是类的构造函数和初始化方法，我们提供可用于设定初始集合容量上限的构造方法，从而在使用者对集合大小有一定估计的情况下节省空间和扩容成本：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SeqCollection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SeqCollection</span><span class="params">(<span class="keyword">int</span> ceiling)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.ceiling = ceiling;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    value = <span class="keyword">new</span> <span class="keyword">int</span>[ceiling];</span><br><span class="line">    occupy = <span class="keyword">new</span> <span class="keyword">boolean</span>[ceiling];</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接下来是四个内部的私有方法，虽然不直接作为接口对外访问，但却是集合结构的核心逻辑代码，这四个函数辅助实现了集合的功能接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>:集合扩容方法，每次扩容至当前容量的两倍</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expansion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> new_value[] = <span class="keyword">new</span> <span class="keyword">int</span>[size * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">boolean</span> new_occupy[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[size * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        new_value[i] = value[i];</span><br><span class="line">        new_occupy[i] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    value = new_value;</span><br><span class="line">    occupy = new_occupy;</span><br><span class="line">    ceiling = size * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>:随机获取一个可插入元素的索引</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pushIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = (<span class="keyword">int</span>) (Math.random() * ceiling);</span><br><span class="line">    <span class="keyword">if</span> (occupy[index]) &#123;</span><br><span class="line">        <span class="comment">//设置flag变量用于出现地址冲突时寻址的方向随机性</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">while</span> (occupy[index]) &#123;</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">if</span> (index == ceiling)</span><br><span class="line">                    index = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (occupy[index]) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">if</span> (index == -<span class="number">1</span>)</span><br><span class="line">                    index = ceiling - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = !flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>:随机获取一个已插入元素的索引</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">popIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = (<span class="keyword">int</span>) (Math.random() * ceiling);</span><br><span class="line">    <span class="keyword">if</span> (!occupy[index]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!occupy[index]) &#123;</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">if</span> (index == ceiling)</span><br><span class="line">                    index = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!occupy[index]) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">if</span> (index == -<span class="number">1</span>)</span><br><span class="line">                    index = ceiling - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = !flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>:判断某个元素是否已经存在于集合中，该方法用于排除元素重复的情况</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> elem</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">int</span> elem)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> exist = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ceiling; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value[i] == elem &amp;&amp; occupy[i]) &#123;</span><br><span class="line">            exist = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最后是对外提供的接口方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>:获取集合内元素个数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>:判断集合是否为空</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>:向集合中添加元素，添加成功返回true，该元素已存在返回false</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> elem</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> elem)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先判断要插入的元素是否已经存在</span></span><br><span class="line">    <span class="keyword">if</span> (!exist(elem)) &#123;</span><br><span class="line">        <span class="comment">//如果集合中的元素已达上限先进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (size == ceiling)</span><br><span class="line">            expansion();</span><br><span class="line">        <span class="keyword">int</span> index = pushIndex();</span><br><span class="line">        value[index] = elem;</span><br><span class="line">        occupy[index] = <span class="keyword">true</span>;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>:从集合中随机拿出一个元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//集合为空时报错</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"collection empty , pop failed"</span>);</span><br><span class="line">        <span class="keyword">int</span> index = popIndex();</span><br><span class="line">        occupy[index] = <span class="keyword">false</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> value[index];</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链式存储实现"><a href="#链式存储实现" class="headerlink" title="链式存储实现"></a>链式存储实现</h3><p>接下来我们采用链式存储的方式实现集合结构，相比于顺序存储链式存储其实更适合来实现集合结构，因为顺序存储先天就带有的位置优势在集合结构中不太用的上，同时集合结构的重要操作就是放入元素和取出元素，也就是说在物理层面上的修改数据操作较多，这点也更适合链式存储来实现。因此我们唯一要解决的问题是保证集合中放入元素和取出元素的随机性，同时由于元素之间不相邻，也不用处理索引冲突的问题。下面我们来看ChaCollection类的代码：</p>
<ul>
<li>首先是集合类的成员变量和节点类Node，成员变量只包含一个头节点head，这样的好处在于头结点的值可以用来保存着整个集合元素的数量，因此整个集合结构就是一个带头节点的单链表</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头结点</span></span><br><span class="line"><span class="keyword">private</span> Node head;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">//存储下一个元素节点的位置</span></span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line">    <span class="comment">//存储当前元素的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Node next, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次是类的构造函数，链式存储的构造函数实现起来十分简单，只需要初始化头结点即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ChaCollection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>接下来是一个内部的私有方法，判断是否元素以及存在集合中，这也是链式存储实现起来方便之处</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> elem</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>:判断某个元素是否已经存在于集合中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">int</span> elem)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> exist = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!isEmpty()) &#123;</span><br><span class="line">            Node p;</span><br><span class="line">            p = head.next;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.value == elem) &#123;</span><br><span class="line">                    exist = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> exist;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最后是对外提供的接口方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:获取集合内元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> head.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:判断集合是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> head.next == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> elem</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:向集合中添加元素，添加成功返回true，该元素已存在返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> elem)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (exist(elem)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//随机选择位置放入元素</span></span><br><span class="line">        <span class="keyword">int</span> pushIndex = (<span class="keyword">int</span>) (Math.random() * head.value);</span><br><span class="line">        Node p = head, q;</span><br><span class="line">        <span class="keyword">while</span> (pushIndex-- &gt; <span class="number">0</span>)</span><br><span class="line">            p = p.next;</span><br><span class="line">        q = <span class="keyword">new</span> Node(<span class="keyword">null</span>, elem);</span><br><span class="line">        q.next = p.next;</span><br><span class="line">        p.next = q;</span><br><span class="line">        head.value++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:从集合中随机拿出一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"collection empty , pop failed"</span>);</span><br><span class="line">        <span class="keyword">int</span> popIndex = (<span class="keyword">int</span>) (Math.random() * head.value);</span><br><span class="line">        Node p = head, q;</span><br><span class="line">        <span class="keyword">while</span> (popIndex-- &gt; <span class="number">0</span>)</span><br><span class="line">            p = p.next;</span><br><span class="line">        q = p.next;</span><br><span class="line">        p.next = p.next.next;</span><br><span class="line">        head.value--;</span><br><span class="line">        <span class="keyword">return</span> q.value;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>这里我们也给出两种实现结构的测试代码与测试结果，验证代码的正确性和获取数据的随机性。测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"顺序存储结果集："</span>);</span><br><span class="line">    SeqCollection seqCollection = <span class="keyword">new</span> SeqCollection();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            seqCollection.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.print(seqCollection.pop() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"链式存储结果集："</span>);</span><br><span class="line">    ChaCollection chaCollection = <span class="keyword">new</span> ChaCollection();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            chaCollection.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.print(chaCollection.pop() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>验证结果如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">顺序存储结果集：</span><br><span class="line"><span class="number">2</span> <span class="number">0</span> <span class="number">5</span> <span class="number">3</span> <span class="number">6</span> <span class="number">1</span> <span class="number">7</span> <span class="number">4</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line"><span class="number">9</span> <span class="number">7</span> <span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">5</span> <span class="number">3</span> <span class="number">6</span> <span class="number">0</span> <span class="number">8</span> </span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">8</span> <span class="number">6</span> <span class="number">9</span> <span class="number">4</span> <span class="number">2</span> <span class="number">7</span> <span class="number">0</span> <span class="number">5</span> </span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">2</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span> <span class="number">7</span> <span class="number">4</span> <span class="number">0</span> <span class="number">3</span> </span><br><span class="line"><span class="number">9</span> <span class="number">7</span> <span class="number">1</span> <span class="number">0</span> <span class="number">6</span> <span class="number">2</span> <span class="number">8</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> </span><br><span class="line"><span class="number">1</span> <span class="number">7</span> <span class="number">0</span> <span class="number">6</span> <span class="number">5</span> <span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line"><span class="number">3</span> <span class="number">7</span> <span class="number">0</span> <span class="number">2</span> <span class="number">6</span> <span class="number">8</span> <span class="number">1</span> <span class="number">5</span> <span class="number">9</span> <span class="number">4</span> </span><br><span class="line"><span class="number">3</span> <span class="number">0</span> <span class="number">6</span> <span class="number">8</span> <span class="number">4</span> <span class="number">9</span> <span class="number">1</span> <span class="number">7</span> <span class="number">5</span> <span class="number">2</span> </span><br><span class="line"><span class="number">6</span> <span class="number">7</span> <span class="number">5</span> <span class="number">8</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="number">4</span> <span class="number">9</span> <span class="number">3</span> </span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">5</span> <span class="number">7</span> <span class="number">9</span> <span class="number">8</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">6</span> </span><br><span class="line">链式存储结果集：</span><br><span class="line"><span class="number">0</span> <span class="number">9</span> <span class="number">7</span> <span class="number">4</span> <span class="number">5</span> <span class="number">1</span> <span class="number">6</span> <span class="number">3</span> <span class="number">2</span> <span class="number">8</span> </span><br><span class="line"><span class="number">5</span> <span class="number">0</span> <span class="number">7</span> <span class="number">6</span> <span class="number">8</span> <span class="number">4</span> <span class="number">2</span> <span class="number">3</span> <span class="number">9</span> <span class="number">1</span> </span><br><span class="line"><span class="number">8</span> <span class="number">4</span> <span class="number">6</span> <span class="number">3</span> <span class="number">5</span> <span class="number">2</span> <span class="number">7</span> <span class="number">1</span> <span class="number">9</span> <span class="number">0</span> </span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">0</span> <span class="number">2</span> <span class="number">9</span> <span class="number">4</span> <span class="number">5</span> <span class="number">3</span> <span class="number">8</span> <span class="number">7</span> </span><br><span class="line"><span class="number">9</span> <span class="number">8</span> <span class="number">4</span> <span class="number">0</span> <span class="number">7</span> <span class="number">1</span> <span class="number">3</span> <span class="number">6</span> <span class="number">2</span> <span class="number">5</span> </span><br><span class="line"><span class="number">9</span> <span class="number">8</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">3</span> <span class="number">0</span> <span class="number">1</span> <span class="number">7</span> <span class="number">6</span> </span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">4</span> <span class="number">0</span> <span class="number">9</span> <span class="number">3</span> <span class="number">2</span> </span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">5</span> <span class="number">7</span> <span class="number">9</span> <span class="number">0</span> <span class="number">8</span> <span class="number">6</span> <span class="number">3</span> </span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">4</span> <span class="number">7</span> <span class="number">8</span> <span class="number">5</span> <span class="number">3</span> <span class="number">6</span> <span class="number">9</span> <span class="number">2</span> </span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">1</span> <span class="number">4</span> <span class="number">8</span> <span class="number">9</span> <span class="number">7</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<hr />
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>简单工厂模式</title>
    <url>/design1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr />

<a id="more"></a>

<div class="note info"><p>以下学习笔记内容由java语言编写。</p></div>

<p>从一个简单的控制台计算器程序开始，编写程序在控制台输入两个运算数和操作符，完成加减乘除运算。</p>
<h2 id="面向过程风格"><a href="#面向过程风格" class="headerlink" title="面向过程风格"></a>面向过程风格</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Scanner scan;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//输入参数</span></span><br><span class="line">			scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">			System.out.println(<span class="string">"请输入数字A"</span>);</span><br><span class="line">			<span class="keyword">double</span> a = scan.nextDouble();			</span><br><span class="line">			System.out.println(<span class="string">"请输入运算符，包括+-*/："</span>);</span><br><span class="line">			String op = scan.next();</span><br><span class="line">			System.out.println(<span class="string">"请输入数字B"</span>);</span><br><span class="line">			<span class="keyword">double</span> b = scan.nextDouble();</span><br><span class="line">			<span class="comment">//运算、输出和异常处理</span></span><br><span class="line">			<span class="keyword">switch</span> (op) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">				System.out.println(<span class="string">"计算结果为"</span>+(a+b));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">				System.out.println(<span class="string">"计算结果为"</span>+(a-b));				</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">				System.out.println(<span class="string">"计算结果为"</span>+(a*b));				</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">				<span class="keyword">if</span> (b==<span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"被除数不能为0"</span>);</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;			</span><br><span class="line">					System.out.println(<span class="string">"计算结果为"</span>+(a/b));				</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				System.out.println(<span class="string">"输入运算符有误"</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码虽然实现了计算器功能，但是不够灵活，可复用、可扩展、可维护性能并不好，如果能够将界面和业务分离，把计算功能抽象出来，就能复用到不同的界面，例如web端、移动端等，于是就有了第二个版。</p>
<h2 id="业务逻辑封装"><a href="#业务逻辑封装" class="headerlink" title="业务逻辑封装"></a>业务逻辑封装</h2><ul>
<li>业务</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> num1;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> num2;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> num3;</span><br><span class="line">	<span class="keyword">private</span> String op;</span><br><span class="line">	<span class="comment">//构造函数传入计算数和操作符</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Operation</span><span class="params">(<span class="keyword">double</span> num1,<span class="keyword">double</span> num2,String op)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.num1=num1;</span><br><span class="line">		<span class="keyword">this</span>.num2=num2;</span><br><span class="line">		<span class="keyword">this</span>.op=op;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//计算方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cal</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">switch</span> (op) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">				num3=num1+num2;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">				num3=num1-num2;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">				num3=num1*num2;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">				<span class="keyword">if</span> (num2==<span class="number">0</span>) &#123;					</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"被除数不能为零"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				num3=num1/num2;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"操作符输入有误"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> num3;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>界面</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Enter</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Scanner scan;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//输入参数</span></span><br><span class="line">		scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">"请输入数字A"</span>);</span><br><span class="line">		<span class="keyword">double</span> a = scan.nextDouble();			</span><br><span class="line">		System.out.println(<span class="string">"请输入运算符，包括+-*/："</span>);</span><br><span class="line">		String op = scan.next();</span><br><span class="line">		System.out.println(<span class="string">"请输入数字B"</span>);</span><br><span class="line">		<span class="keyword">double</span> b = scan.nextDouble();</span><br><span class="line">		<span class="comment">//实例化计算类</span></span><br><span class="line">		Operation o1 = <span class="keyword">new</span> Operation(a, b, op);</span><br><span class="line">		<span class="comment">//调用计算方法输出结果</span></span><br><span class="line">		System.out.println(<span class="string">"计算结果为"</span>+o1.cal());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>面向对象三大特性封装继承多态，上述代码只用到了封装特性，虽然将业务和界面分离，但是业务逻辑的代码依然没有实现很好的分离，无法应对更多的需求，例如：</p>
<ol>
<li>计算类中的不同计算方法并未分离，当只需要执行一种运算时，其他运算也不可避免的参与了编译</li>
<li>当需要增加计算方法时要求拥有计算类的修改权限</li>
</ol>
<p>基于以上缺陷，有了面向对象风格的第三个版本。</p>
<h2 id="面向对象风格"><a href="#面向对象风格" class="headerlink" title="面向对象风格"></a>面向对象风格</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/design11.jpg" alt="design11"></p>
<ul>
<li>运算父类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">	<span class="comment">//将操作数设置为私有成员变量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> num1;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> num2;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> num3;</span><br><span class="line">	<span class="comment">//构造方法传入参数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Operation</span><span class="params">(<span class="keyword">double</span> num1, <span class="keyword">double</span> num2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.num1 = num1;</span><br><span class="line">		<span class="keyword">this</span>.num2 = num2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置get方法使得子类在计算时获取操作数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getNum1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getNum2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//父类计算函数，在子类中覆盖</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cal</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num3;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>运算子类-加</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算子类继承父类，重写父类的计算函数，封装各自的计算逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperateAdd</span> <span class="keyword">extends</span> <span class="title">Operation</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OperateAdd</span><span class="params">(<span class="keyword">double</span> num1, <span class="keyword">double</span> num2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(num1, num2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cal</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.getNum1()+<span class="keyword">this</span>.getNum2();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>运算子类-减</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperateMinus</span> <span class="keyword">extends</span> <span class="title">Operation</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OperateMinus</span><span class="params">(<span class="keyword">double</span> num1, <span class="keyword">double</span> num2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(num1, num2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.getNum1()-<span class="keyword">this</span>.getNum2();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>运算子类-乘</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperateMultiply</span> <span class="keyword">extends</span> <span class="title">Operation</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OperateMultiply</span><span class="params">(<span class="keyword">double</span> num1, <span class="keyword">double</span> num2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(num1, num2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.getNum1()+<span class="keyword">this</span>.getNum2();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>运算子类-除</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperateDivide</span> <span class="keyword">extends</span> <span class="title">Operation</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OperateDivide</span><span class="params">(<span class="keyword">double</span> num1, <span class="keyword">double</span> num2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(num1, num2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.getNum2()==<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"被除数不能为零"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			System.exit(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.getNum1()/<span class="keyword">this</span>.getNum2();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>界面</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Enter</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Scanner scan;</span><br><span class="line">	<span class="comment">//声明静态计算父类</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Operation o;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//输入参数</span></span><br><span class="line">			scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">			System.out.println(<span class="string">"请输入数字A"</span>);</span><br><span class="line">			<span class="keyword">double</span> a = scan.nextDouble();			</span><br><span class="line">			System.out.println(<span class="string">"请输入运算符，包括+-*/："</span>);</span><br><span class="line">			String op = scan.next();</span><br><span class="line">			System.out.println(<span class="string">"请输入数字B"</span>);</span><br><span class="line">			<span class="keyword">double</span> b = scan.nextDouble();</span><br><span class="line">			<span class="comment">//根据运算符实例化计算子类（对象上转型）</span></span><br><span class="line">			<span class="keyword">switch</span> (op) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">				o = <span class="keyword">new</span> OperateAdd(a, b);				</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">				o = <span class="keyword">new</span> OperateMinus(a, b);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">				o = <span class="keyword">new</span> OperateMultiply(a, b);				</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">				o = <span class="keyword">new</span> OperateDivide(a, b);				</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"输入运算符有误"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//调用计算函数并输出结果</span></span><br><span class="line">			System.out.println(<span class="string">"计算结果为"</span>+o.cal());			</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码充分利用了面向对象的封装继承和多态原则，通过子类对父类的继承和子类实例化时对象上转型，保证每次运算不用编译额外的运算过程，提高了代码的效率，提升了业务逻辑的可扩展性，当需求变化要加入新的运算时只需写入新的子类，继承计算父类并覆盖父类的计算方法即可。</p>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>实际上上一个面向对象的版本已经出现了简单工厂模式的雏形，只需要把界面中的实例化过程进一步封装就符合了简单工厂模式。</p>
<p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/design12.jpg" alt="design12"></p>
<ul>
<li>运算工厂</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">//通过运算符实例化不同的计算子类并返回</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Operation <span class="title">createOperation</span><span class="params">(String op)</span></span>&#123;</span><br><span class="line">		Operation o = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">switch</span> (op) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">				o = <span class="keyword">new</span> OperateAdd();				</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">				o = <span class="keyword">new</span> OperateMinus();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">				o = <span class="keyword">new</span> OperateMultiply();				</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">				o = <span class="keyword">new</span> OperateDivide();				</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"输入运算符有误"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			System.exit(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> o;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>运算父类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> num1;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> num2;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> num3;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getNum1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum1</span><span class="params">(<span class="keyword">double</span> num1)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.num1 = num1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getNum2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum2</span><span class="params">(<span class="keyword">double</span> num2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.num2 = num2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cal</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num3;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运算子类-加</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperateAdd</span> <span class="keyword">extends</span> <span class="title">Operation</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cal</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.getNum1()+<span class="keyword">this</span>.getNum2();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运算子类-减</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperateMinus</span> <span class="keyword">extends</span> <span class="title">Operation</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.getNum1()-<span class="keyword">this</span>.getNum2();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运算子类-乘</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperateMultiply</span> <span class="keyword">extends</span> <span class="title">Operation</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.getNum1()+<span class="keyword">this</span>.getNum2();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运算子类-除</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperateDivide</span> <span class="keyword">extends</span> <span class="title">Operation</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.getNum2()==<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"被除数不能为零"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			System.exit(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.getNum1()/<span class="keyword">this</span>.getNum2();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>界面</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Enter</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Scanner scan;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//输入参数</span></span><br><span class="line">			scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">			System.out.println(<span class="string">"请输入数字A"</span>);</span><br><span class="line">			<span class="keyword">double</span> a = scan.nextDouble();			</span><br><span class="line">			System.out.println(<span class="string">"请输入运算符，包括+-*/："</span>);</span><br><span class="line">			String op = scan.next();</span><br><span class="line">			System.out.println(<span class="string">"请输入数字B"</span>);</span><br><span class="line">			<span class="keyword">double</span> b = scan.nextDouble();</span><br><span class="line">			<span class="comment">//通过计算工厂实例化计算子类</span></span><br><span class="line">			Operation o = OperationFactory.createOperation(op);</span><br><span class="line">			<span class="comment">//通过set方法传入计算参数</span></span><br><span class="line">			o.setNum1(a);</span><br><span class="line">			o.setNum2(b);</span><br><span class="line">			<span class="comment">//调用计算方法输出参数</span></span><br><span class="line">			System.out.println(<span class="string">"计算结果为"</span>+o.cal());	</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr />
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>面向对象风格</tag>
        <tag>耦合</tag>
        <tag>内聚</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/design2.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>日常设计过程中我们常常会遇到这样的需求，在得到一个数据结果的过程中，有时会选择这样或那样不同的处理过程，也就是说目的相同，算法却不同，并且这些算法之间还要频繁的替换，如果是在小型的程序中，还可以使用方法重载的技术实现这种需求，但是面对大型系统，这样基于函数级别的封装就显得不便于维护，每次增加新的算法就要使得原来已有的算法重新编译一边，代价较高，因此策略模型的引入就显得非常重要。</p>
<a id="more"></a>

<div class="note info"><p>以下学习笔记内容由java语言编写。</p></div>

<p>商场开业，需要在每台收银机上安装一个收银系统，要求每次录入商品的名称，单价和购买数量，点击确定按钮后就可以将当前商品的收费信息显示在收银界面，再次录入下一条商品信息点击确定后，将收费信息追加在收银界面，总价递增；商品录入结束后点击清零按钮刷新界面，清空录入列表和总价。</p>
<h2 id="面向过程风格"><a href="#面向过程风格" class="headerlink" title="面向过程风格"></a>面向过程风格</h2><div class="note danger"><p>以下代码中包含java图形化编程相关接口调用，要读懂部分函数参数和功能需要一定图形化编程经验。</p></div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.Font;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JLabel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JOptionPane;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JPanel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JScrollPane;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JTextArea;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JTextField;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashView</span> <span class="keyword">extends</span> <span class="title">JFrame</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">	<span class="comment">//总价</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> sum_price = <span class="number">0.00</span>;</span><br><span class="line">	<span class="comment">//构造方法即程序入口</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CashView</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.setTitle(<span class="string">"商场收银系统"</span>);</span><br><span class="line">		<span class="keyword">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">		<span class="comment">//设置框架的宽高</span></span><br><span class="line">		<span class="keyword">this</span>.setSize(<span class="number">400</span>, <span class="number">450</span>);</span><br><span class="line">		<span class="comment">//将中间容器放入框架</span></span><br><span class="line">		<span class="keyword">this</span>.add(getPanel());</span><br><span class="line">		<span class="comment">//设置框架不可缩放</span></span><br><span class="line">		<span class="keyword">this</span>.setResizable(<span class="keyword">false</span>);</span><br><span class="line">		<span class="comment">//设置框架可见</span></span><br><span class="line">		<span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> JPanel <span class="title">getPanel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		JPanel panel = <span class="keyword">new</span> JPanel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置布局为 null，绝对布局</span></span><br><span class="line">        panel.setLayout(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 这个方法定义了组件的位置。</span></span><br><span class="line"><span class="comment">         * setBounds(x, y, width, height)</span></span><br><span class="line"><span class="comment">         * x 和 y 指定左上角的新位置，由 width 和 height 指定新的大小。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 创建商品名标签</span></span><br><span class="line">        JLabel goodsLabel = <span class="keyword">new</span> JLabel(<span class="string">"商品:"</span>);</span><br><span class="line">        goodsLabel.setBounds(<span class="number">20</span>,<span class="number">20</span>,<span class="number">50</span>,<span class="number">30</span>);</span><br><span class="line">        goodsLabel.setFont(getCashFont(<span class="keyword">false</span>));</span><br><span class="line">        panel.add(goodsLabel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建商品名文本域</span></span><br><span class="line">        JTextField goodsText = <span class="keyword">new</span> JTextField(<span class="number">20</span>);</span><br><span class="line">        goodsText.setBounds(<span class="number">90</span>,<span class="number">20</span>,<span class="number">165</span>,<span class="number">30</span>);</span><br><span class="line">        panel.add(goodsText);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建单价标签</span></span><br><span class="line">        JLabel priceLabel = <span class="keyword">new</span> JLabel(<span class="string">"单价:"</span>);</span><br><span class="line">        priceLabel.setBounds(<span class="number">20</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">30</span>);</span><br><span class="line">        priceLabel.setFont(getCashFont(<span class="keyword">false</span>));</span><br><span class="line">        panel.add(priceLabel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建单价文本域</span></span><br><span class="line">        JTextField priceText = <span class="keyword">new</span> JTextField(<span class="number">20</span>);</span><br><span class="line">        priceText.setBounds(<span class="number">90</span>,<span class="number">60</span>,<span class="number">165</span>,<span class="number">30</span>);</span><br><span class="line">        panel.add(priceText);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建确定按钮</span></span><br><span class="line">        JButton addButton = <span class="keyword">new</span> JButton(<span class="string">"确定"</span>);</span><br><span class="line">        addButton.setBounds(<span class="number">280</span>, <span class="number">60</span>, <span class="number">80</span>, <span class="number">30</span>);</span><br><span class="line">        addButton.setFont(getCashFont(<span class="keyword">false</span>));</span><br><span class="line">        panel.add(addButton);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建数量标签</span></span><br><span class="line">        JLabel numberLabel = <span class="keyword">new</span> JLabel(<span class="string">"数量:"</span>);</span><br><span class="line">        numberLabel.setBounds(<span class="number">20</span>,<span class="number">100</span>,<span class="number">50</span>,<span class="number">30</span>);</span><br><span class="line">        numberLabel.setFont(getCashFont(<span class="keyword">false</span>));</span><br><span class="line">        panel.add(numberLabel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建数量文本域</span></span><br><span class="line">        JTextField numberText = <span class="keyword">new</span> JTextField(<span class="number">20</span>);</span><br><span class="line">        numberText.setBounds(<span class="number">90</span>,<span class="number">100</span>,<span class="number">165</span>,<span class="number">30</span>);</span><br><span class="line">        panel.add(numberText);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建清零按钮</span></span><br><span class="line">        JButton resetButton = <span class="keyword">new</span> JButton(<span class="string">"清零"</span>);</span><br><span class="line">        resetButton.setBounds(<span class="number">280</span>, <span class="number">100</span>, <span class="number">80</span>, <span class="number">30</span>);</span><br><span class="line">        resetButton.setFont(getCashFont(<span class="keyword">false</span>));</span><br><span class="line">        panel.add(resetButton);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建文本域显示商品清单</span></span><br><span class="line">        JTextArea jta= <span class="keyword">new</span> JTextArea();</span><br><span class="line">        <span class="comment">//设置文本框不可编辑</span></span><br><span class="line">        jta.setEditable(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//在文本框上添加滚动条</span></span><br><span class="line">        JScrollPane jsp = <span class="keyword">new</span> JScrollPane(jta);</span><br><span class="line">        <span class="comment">//设置矩形大小.参数依次为(矩形左上角横坐标x,矩形左上角纵坐标y，矩形长度，矩形宽度)</span></span><br><span class="line">        jsp.setBounds(<span class="number">20</span>, <span class="number">140</span>, <span class="number">340</span>, <span class="number">150</span>);</span><br><span class="line">        <span class="comment">//默认的设置是超过文本框才会显示滚动条，以下设置让滚动条一直显示</span></span><br><span class="line">        jsp.setVerticalScrollBarPolicy( JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);        </span><br><span class="line">        <span class="comment">//把滚动条添加到容器里面</span></span><br><span class="line">        panel.add(jsp);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建总价标签</span></span><br><span class="line">        JLabel sumLabel = <span class="keyword">new</span> JLabel(<span class="string">"总计:"</span>);</span><br><span class="line">        sumLabel.setBounds(<span class="number">20</span>,<span class="number">300</span>,<span class="number">50</span>,<span class="number">30</span>);</span><br><span class="line">        sumLabel.setFont(getCashFont(<span class="keyword">false</span>));</span><br><span class="line">        panel.add(sumLabel);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建总价显示标签</span></span><br><span class="line">        JLabel sumViewLabel = <span class="keyword">new</span> JLabel(String.valueOf(sum_price));</span><br><span class="line">        sumViewLabel.setBounds(<span class="number">100</span>,<span class="number">300</span>,<span class="number">250</span>,<span class="number">60</span>);</span><br><span class="line">        sumViewLabel.setFont(getCashFont(<span class="keyword">true</span>));</span><br><span class="line">        panel.add(sumViewLabel);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//确定按钮绑定事件（不加数值验证）</span></span><br><span class="line">        addButton.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">if</span> (goodsText.getText().equals(<span class="string">""</span>)||priceText.getText().equals(<span class="string">""</span>)||numberText.getText().equals(<span class="string">""</span>)) &#123;</span><br><span class="line">					JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">"内容不全"</span>);</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="comment">//计算收费信息	</span></span><br><span class="line">					<span class="keyword">int</span> num = Integer.parseInt(numberText.getText());</span><br><span class="line">					<span class="keyword">double</span> price = Double.parseDouble(priceText.getText());</span><br><span class="line">					jta.append(<span class="string">"商品："</span>+goodsText.getText()+<span class="string">" 单价："</span>+price+<span class="string">" 数量："</span>+num+<span class="string">" 合计："</span>+num*price+<span class="string">"\n"</span>);</span><br><span class="line">					sum_price+=num*price;</span><br><span class="line">					sumViewLabel.setText(String.valueOf(sum_price));</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//清零按钮绑定事件</span></span><br><span class="line">        resetButton.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">				goodsText.setText(<span class="string">""</span>);</span><br><span class="line">				priceText.setText(<span class="string">""</span>);</span><br><span class="line">				numberText.setText(<span class="string">""</span>);</span><br><span class="line">				jta.setText(<span class="string">""</span>);</span><br><span class="line">				sum_price=<span class="number">0</span>d;</span><br><span class="line">				sumViewLabel.setText(String.valueOf(sum_price));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> panel;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> Font <span class="title">getCashFont</span><span class="params">(<span class="keyword">boolean</span> is_big)</span></span>&#123;</span><br><span class="line">		Font f;</span><br><span class="line">		<span class="keyword">if</span> (is_big) &#123;			</span><br><span class="line">			f = <span class="keyword">new</span> Font(<span class="string">"黑体"</span>, Font.BOLD, <span class="number">50</span>); </span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;			</span><br><span class="line">			f = <span class="keyword">new</span> Font(<span class="string">"黑体"</span>, Font.PLAIN, <span class="number">20</span>); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> f;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显而易见，这样的程序轻而易举的就能指出很多缺点：</p>
<blockquote>
<p>展示界面的swing代码和用于计算的业务逻辑代码杂糅在一起，难以分别<br>需要修改原有业务逻辑时需要整个重新编译源程序<br>无法轻便高效的拓展原系统功能<br>…</p>
</blockquote>
<p>以上代码虽然实现了收银系统的功能，但是面向过程的编程风格使得代码的可读性、可维护性、可扩展性都不强，面对小小的需求改变都难以适应。例如，商场开业为了酬宾推出部分商品折扣活动，有五折、八折、九折三种折扣分别适用于部分商品，在生成商品收费清单时，不仅要用所选的优惠方式进行计算，还要将折扣信息输出在收银界面上。<br>这是我们就应该考虑将业务逻辑封装起来，适应需求的变化。</p>
<h2 id="业务逻辑封装"><a href="#业务逻辑封装" class="headerlink" title="业务逻辑封装"></a>业务逻辑封装</h2><ul>
<li>业务逻辑封装类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 折扣类封装</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 张国荣</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Discount</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String[] reduce = &#123;<span class="string">"正常收费"</span>,<span class="string">"五折"</span>,<span class="string">"八折"</span>,<span class="string">"九折"</span>&#125;;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据商品原价和折扣类型计算商品收费价格</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calPrice</span><span class="params">(<span class="keyword">double</span> money,String type)</span></span>&#123;</span><br><span class="line">		<span class="keyword">double</span> discount;</span><br><span class="line">		<span class="keyword">switch</span> (type) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"五折"</span>:</span><br><span class="line">			discount=<span class="number">0.5</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"八折"</span>:</span><br><span class="line">			discount=<span class="number">0.8</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"九折"</span>:</span><br><span class="line">			discount=<span class="number">0.9</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			discount=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> money*discount;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>界面类</li>
</ul>
<div class="note primary"><p>以下代码省略相同部分。</p></div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">        JComboBox&lt;String&gt; discountBox = <span class="keyword">new</span> JComboBox&lt;&gt;();</span><br><span class="line">        discountBox.setBounds(<span class="number">280</span>, <span class="number">20</span>, <span class="number">80</span>, <span class="number">30</span>);</span><br><span class="line">		<span class="comment">//调用业务类中的静态常量来生成优惠选项</span></span><br><span class="line">        <span class="keyword">for</span> (String e : Discount.reduce) &#123;		</span><br><span class="line">        	discountBox.addItem(e);</span><br><span class="line">		&#125;</span><br><span class="line">        panel.add(discountBox);</span><br><span class="line">……</span><br><span class="line"><span class="comment">//确定按钮绑定事件（不加数值验证）</span></span><br><span class="line">        addButton.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">if</span> (goodsText.getText().equals(<span class="string">""</span>)||priceText.getText().equals(<span class="string">""</span>)||numberText.getText().equals(<span class="string">""</span>)) &#123;</span><br><span class="line">					JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">"内容不全"</span>);</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;					</span><br><span class="line">					<span class="keyword">int</span> num = Integer.parseInt(numberText.getText());</span><br><span class="line">					<span class="keyword">double</span> price = Double.parseDouble(priceText.getText());</span><br><span class="line">					<span class="comment">//通过传入优惠参数调用业务类中的静态方法计算商品费用</span></span><br><span class="line">					<span class="keyword">double</span> dis_price=Discount.calPrice(price*num, discountBox.getSelectedItem().toString());</span><br><span class="line">					jta.append(<span class="string">"商品："</span>+goodsText.getText()+<span class="string">" 单价："</span>+price+<span class="string">" 数量："</span>+num+<span class="string">" "</span>+discountBox.getSelectedItem()+<span class="string">" 合计："</span>+dis_price+<span class="string">"\n"</span>);</span><br><span class="line">					sum_price+=dis_price;</span><br><span class="line">					sumViewLabel.setText(String.format(<span class="string">"%.2f"</span>, sum_price));</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>这个版本的代码相比第一次有了很大的改善，代码的重构使得展示界面的“前端”代码和真正用于处理数据的业务逻辑代码分开，降低了耦合度。在这个版本中，当我们要对系统的界面进行优化或者业务逻辑的需求出现变化时，我们可以很轻易在不同的类中做修改，并且完全不影响到另一个方面。<br>但是这样的代码就是好的设计吗，显示不是，我们依然可以从中挑出不足：</p>
<blockquote>
<p>业务逻辑的代码全部放在一个类中，从这个角度耦合度并没有降下来<br>每一次进行业务逻辑的计算实际上只用到了类中的一个计算方法，但是其他计算方法也无可避免的参与了系统的编译和实例化<br>如果要加入新的业务功能，要么单独写类增加界面类的判断逻辑，提高界面和业务的耦合，要么融入到已有的业务类中，使得业务逻辑类的内部愈加复杂<br>……</p>
</blockquote>
<p>基于上述的种种问题，我们想到在上一个章节中介绍了简单工厂模式，显然就可以运用到这个案例中来，业务逻辑实际上可以抽象出计算实际收费功能的父类和具体不同算法实现收费的子类，这样不同的计算方式就可以分开来，降低业务逻辑的耦合度。<br>再看来需求，商场为了回馈快开业期间消费者的支持特地推出了更加有力的优惠活动，满减活动，但是不与原有的折扣活动共享，消费者自主选择划算的优惠方式。</p>
<h2 id="简单工厂模式实现"><a href="#简单工厂模式实现" class="headerlink" title="简单工厂模式实现"></a>简单工厂模式实现</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/design21.jpg" alt="design21"></p>
<ul>
<li>收费工厂类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashFactory</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String[] reduce = &#123;<span class="string">"正常收费"</span>,<span class="string">"五折"</span>,<span class="string">"八折"</span>,<span class="string">"满三百减一百"</span>&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CashSuper <span class="title">reduce</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">		CashSuper cs = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">switch</span> (type) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"正常收费"</span>:</span><br><span class="line">			cs = <span class="keyword">new</span> CashNormal();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"五折"</span>:</span><br><span class="line">			cs = <span class="keyword">new</span> CashDiscount(<span class="number">0.5</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"八折"</span>:</span><br><span class="line">			cs = <span class="keyword">new</span> CashDiscount(<span class="number">0.8</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"满三百减一百"</span>:</span><br><span class="line">			cs = <span class="keyword">new</span> CashReturn(<span class="number">300</span>, <span class="number">100</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cs;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>优惠父类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashSuper</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calPrice</span><span class="params">(<span class="keyword">double</span> price)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>正常收费子类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashNormal</span> <span class="keyword">extends</span> <span class="title">CashSuper</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>折扣子类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashDiscount</span> <span class="keyword">extends</span> <span class="title">CashSuper</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> discount = <span class="number">1</span>d;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CashDiscount</span><span class="params">(<span class="keyword">double</span> discount)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.discount = discount;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> price*discount;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>满减子类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashReturn</span> <span class="keyword">extends</span> <span class="title">CashSuper</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> condition_money = <span class="number">0</span>d;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> return_money = <span class="number">0</span>d;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CashReturn</span><span class="params">(<span class="keyword">double</span> condition_money, <span class="keyword">double</span> return_money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.condition_money = condition_money;</span><br><span class="line">		<span class="keyword">this</span>.return_money = return_money;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> price-((<span class="keyword">int</span>)price/(<span class="keyword">int</span>)condition_money)*return_money;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>界面类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">        <span class="comment">// 创建折扣下拉框</span></span><br><span class="line">        JComboBox&lt;String&gt; discountBox = <span class="keyword">new</span> JComboBox&lt;&gt;();</span><br><span class="line">        discountBox.setBounds(<span class="number">280</span>, <span class="number">20</span>, <span class="number">80</span>, <span class="number">30</span>);</span><br><span class="line">        <span class="comment">//引入活动名称</span></span><br><span class="line">        <span class="keyword">for</span> (String e : CashFactory.reduce) &#123;			</span><br><span class="line">        	discountBox.addItem(e);</span><br><span class="line">		&#125;</span><br><span class="line">        panel.add(discountBox);</span><br><span class="line">……</span><br><span class="line">		<span class="comment">//确定按钮绑定事件（不加数值验证）</span></span><br><span class="line">        addButton.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">if</span> (goodsText.getText().equals(<span class="string">""</span>)||priceText.getText().equals(<span class="string">""</span>)||numberText.getText().equals(<span class="string">""</span>)) &#123;</span><br><span class="line">					JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">"内容不全"</span>);</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;			</span><br><span class="line">					<span class="keyword">int</span> num = Integer.parseInt(numberText.getText());</span><br><span class="line">					<span class="keyword">double</span> good_price = Double.parseDouble(priceText.getText());</span><br><span class="line">					<span class="keyword">double</span> goods_price = good_price * num;</span><br><span class="line">					<span class="comment">//根据选中的优惠方式从优惠工厂中生成优惠子类</span></span><br><span class="line">					CashSuper cs = CashFactory.reduce(discountBox.getSelectedItem().toString());</span><br><span class="line">					<span class="comment">//调用优惠父类的抽象计算方法</span></span><br><span class="line">					goods_price = cs.calPrice(goods_price);				</span><br><span class="line">					<span class="comment">//显示收费及活动信息</span></span><br><span class="line">					sum_price+=goods_price;</span><br><span class="line">					jta.append(<span class="string">"商品："</span>+goodsText.getText()+<span class="string">" 单价："</span>+good_price+<span class="string">" 数量："</span>+num+<span class="string">" "</span>+discountBox.getSelectedItem()+<span class="string">" 合计："</span>+goods_price+<span class="string">"\n"</span>);</span><br><span class="line">					sumViewLabel.setText(String.format(<span class="string">"%.2f"</span>, sum_price));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>到了这个版本，在业务逻辑方面的耦合度已经降得很低了，现在面对已有子类的新需求，我们只需要在工厂类中添加不同的参数名，返回相应的实例即可；而面对新的计算方法需求，添加计算方法类之后继承父类，并修改业务工厂中的调用即可。<br>到目前为止，虽然简单工厂模式也解决了收费算法的问题，但是这个模式只是解决了对象的创建问题，而且由于工厂本身包括了所有的收费方式，每次维护和扩展都要改动这个工厂，以致代码需要重新编译部署，所以这不是最好的办法。这里我们就要引出今天的策略模式了。</p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><blockquote>
<p><strong>策略模式（strategy）</strong>定义了算法家族，分别封装起来，让其之间可以互相替换，使算法的变化不会影响到使用算法的用户</p>
</blockquote>
<p>对于这个收银系统来说，不论是打折还是满减，甚至返利等算法，都是策略，用户真正想要得到的是优惠后所要付出的费用，而至于算法的实现过程并不关心。因此，我们真正所应该封装的，是不同的策略，而非类，这就是简单工厂模式所不能解决的问题，工厂只是解决了对象的创建，而用户所需要的只是类中的计算方法，而策略模式正好可以把对象也封装起来。在系统中，优惠父类即策略类，各种实现子类即具体策略类。</p>
<p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/design22.jpg" alt="design22"></p>
<ul>
<li>策略上下文</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashContext</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String[] reduce = &#123;<span class="string">"正常收费"</span>,<span class="string">"五折"</span>,<span class="string">"八折"</span>,<span class="string">"满三百减一百"</span>&#125;;</span><br><span class="line">	<span class="comment">//将优惠父类封装到策略上下文中</span></span><br><span class="line">	<span class="keyword">private</span> CashSuper cs;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CashContext</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (type) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"正常收费"</span>:</span><br><span class="line">			<span class="comment">//每一次实例化都在上下文中实例优惠子类对象</span></span><br><span class="line">			<span class="keyword">this</span>.cs = <span class="keyword">new</span> CashNormal();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"五折"</span>:</span><br><span class="line">			<span class="keyword">this</span>.cs = <span class="keyword">new</span> CashDiscount(<span class="number">0.5</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"八折"</span>:</span><br><span class="line">			<span class="keyword">this</span>.cs = <span class="keyword">new</span> CashDiscount(<span class="number">0.8</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"满三百减一百"</span>:</span><br><span class="line">			<span class="keyword">this</span>.cs = <span class="keyword">new</span> CashReturn(<span class="number">300</span>, <span class="number">100</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//通过上下文调用子类的计算方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calMoney</span><span class="params">(<span class="keyword">double</span> money)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cs.calPrice(money);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>界面类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">        <span class="comment">// 创建折扣下拉框</span></span><br><span class="line">        discountBox = <span class="keyword">new</span> JComboBox&lt;&gt;();</span><br><span class="line">        discountBox.setBounds(<span class="number">280</span>, <span class="number">20</span>, <span class="number">80</span>, <span class="number">30</span>);</span><br><span class="line">        <span class="comment">//引入活动名称</span></span><br><span class="line">        <span class="keyword">for</span> (String e : CashContext.reduce) &#123;			</span><br><span class="line">        	discountBox.addItem(e);</span><br><span class="line">		&#125;</span><br><span class="line">        panel.add(discountBox);</span><br><span class="line">……</span><br><span class="line">        <span class="comment">//确定按钮绑定事件（不加数值验证）</span></span><br><span class="line">        addButton.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">if</span> (goodsText.getText().equals(<span class="string">""</span>)||priceText.getText().equals(<span class="string">""</span>)||numberText.getText().equals(<span class="string">""</span>)) &#123;</span><br><span class="line">					JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">"内容不全"</span>);</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;			</span><br><span class="line">					<span class="keyword">int</span> num = Integer.parseInt(numberText.getText());</span><br><span class="line">					<span class="keyword">double</span> good_price = Double.parseDouble(priceText.getText());</span><br><span class="line">					<span class="keyword">double</span> goods_price = good_price * num;</span><br><span class="line">					<span class="comment">//将选中的优惠类型传入策略上下文</span></span><br><span class="line">					CashContext cc = <span class="keyword">new</span> CashContext(discountBox.getSelectedItem().toString());</span><br><span class="line">					<span class="comment">//调用策略上下文中的计算方法</span></span><br><span class="line">					goods_price = cc.calMoney(goods_price);				</span><br><span class="line">					<span class="comment">//显示收费及活动信息</span></span><br><span class="line">					sum_price+=goods_price;</span><br><span class="line">					jta.append(<span class="string">"商品："</span>+goodsText.getText()+<span class="string">" 单价："</span>+good_price+<span class="string">" 数量："</span>+num+<span class="string">" "</span>+discountBox.getSelectedItem()+<span class="string">" 合计："</span>+goods_price+<span class="string">"\n"</span>);</span><br><span class="line">					sumViewLabel.setText(String.format(<span class="string">"%.2f"</span>, sum_price));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>实际上，这个版本的代码是策略模式和简单工厂模式的结合，将工厂类和策略模式的上下文结合了起来，使得代码更加轻便。对比策略模式和简单工厂模式的界面类代码，我们可以发现，简单工厂模式中我们的客户端需要使用工厂类和优惠父类两个类才可以完成策略的使用，而策略模式中只需要在客户端实例化策略上下文一个类就可以完成策略的使用，耦合度变得更低，连优惠父类也封装起来了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>策略模式定义了一系列算法的方法，这些算法所做的工作相同，只是实现不同。策略模式以相同的方法调用不同的算法，减少了算法类和使用算法类之间的耦合</li>
<li>策略模式简化了单元测试，每个算法都有自己的类，可通过自己的接口单独测试</li>
<li>实践中策略模式可以用来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考略使用策略模式处理这种变化的可能性</li>
</ol>
<hr />
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>面向过程风格</tag>
        <tag>简单工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象编程五大原则</title>
    <url>/design3.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前面我们谈了很多面向对象编程风格相对于面向过程编程风格的好处，诸如可维护性，可复用性，可扩展性和灵活性，虽然我们已经知道封装、继承、多态这些特性，可以支持我们来完成面向对象程序的开发，但在实际开发过程中，我们怎样才能做到面向对象开发呢。这里就需要引入著名的“SOLID”设计原则，单一功能、开闭原则、里氏替换、接口隔离以及依赖反转是由罗伯特·C·马丁在21世纪早期引入的设计原则，当这些原则被一起应用时，它们使得一个程序员开发一个容易进行软件维护和扩展的系统变得更加可能，SOLID被典型的应用在测试驱动开发上，并且是敏捷开发以及自适应软件开发的基本原则的重要组成部分。</p>
<a id="more"></a>

<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>回忆一下上一次我们所写的银行收银系统，在最初的面向过程风格版本中，我们几乎将所有的代码都写在同一个类中（如果不考虑main方法），那么这时该类所承担的职责就非常多，任何一个新的需求都迫使我们去修改这个类中的代码。例如我们要新加一个优惠活动的业务，我们既要在该类的界面代码块中加入一个下拉框用于选择打折的数额，又要在业务逻辑代码块中加入相应的折扣计算和选择判断逻辑代码，这已经违背了面向对象编程的单一职责原则。</p>
<blockquote>
<p><strong>单一职责原则（Single Responsibility Principle）</strong>：就一个类而言，应该仅有一个引起他变化的原因</p>
</blockquote>
<p>这一原则告诉我们在进行面向对象开发的实践中，首要问题并不是考虑功能的实现，而是考虑系统的划分，我们常常在拿到一个需求之后就开始陷入到业务逻辑的细节当中，如果功能的实现流程和所要用到的技术都已经在我们的大脑中形成框架，就恨不得立刻拿起键盘开始写。直到写到一半需要修改某一处的逻辑或结构时，才发现牵一发而动全身，一点小小的改动就bug不断，这才开始放下键盘，沉思起如何对代码进行重构。我们日常练习过程中的代码重构尚且如此费劲，可想而知实际开发过程中的大型系统更是不敢轻举妄动。<br>那么在一开始的时候，我们就要尽可能的把职责划分清楚，如果一个类承担的职责过多，就等于把这些职责耦合到一起，一个职责的变化可能会削弱或抑制这个类完成其他职责的能力，还是举我们之前说过的例子，当你把一个收银系统的业务和界面都写在一起的时候，一旦你想重构界面相关的代码，把swing封装界面的过程不耦合在同一个函数当中时，就会发现界面上按钮的绑定事件需要获取到相关输入框的值，如果想把按钮的绑定事件函数写在控件的封装函数外，那么这些输入框就没办法在作为局部变量写在函数当中，否则按钮根本无法获取到相关输入值，也就无法完成业务逻辑的计算，这就是界面的改动影响业务逻辑的表现。<br>说起来很容易，但真正实践起来还需要多踩坑才能加深理解和体会，软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离，记住原则的内容，如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。</p>
<h2 id="开放-封闭原则"><a href="#开放-封闭原则" class="headerlink" title="开放-封闭原则"></a>开放-封闭原则</h2><p>有一定开发经验的人常常有这样一个习惯，当面对新的需求或不稳定的需求时，他们会第一时刻想办法把需求封装起来，留出可扩展的接口，而不是去修改原本的代码来适应新需求。就像我们第一次遇到商场收银系统需要增加打折功能时，我们并不会只在原有计算逻辑的基础上乘一个折扣，至少我们也会将折扣这个需求封装成一个函数，以适应之后新的折扣变化，这已经隐隐有了开放封闭的思想。</p>
<blockquote>
<p><strong>开封-封闭原则（Open Close Principle）</strong>：软件实体（类、模块、函数等）应该可以扩展，但是不可修改</p>
</blockquote>
<p>这个原则有两个特征：</p>
<ol>
<li>对扩展开放（open for extension）</li>
<li>对修改封闭（close for modification）</li>
</ol>
<p>任何一个系统在设计过程中都要面对不稳定的需求，这是毋庸置疑的，如果没当面对新的需求就来修改原有的代码，重新测试，开发的效率就会大大降低，因此对扩展开放就是用以适应变化的需求。这一原则的理想状态下，我们对待新的需求不需要修改原有类，只需增加新类即可解决，但实际情况是很难做到的，无论模块多封闭，都无法避免一些变化对其造成影响和冲击，这就要求设计人员在设计模块时对变化和封闭的部分作出判断和选择。<br>说起来简单，但预测变化又谈何容易，选错了方向意味着更大的损失。这里我们就需要遵循两点技巧：</p>
<ol>
<li>编码初期，预设不会发生变化，变化发生时立刻采取行动</li>
<li>变化发生时创建抽象隔离以后发生的同类变化</li>
</ol>
<p>第一点说的是应对变化的时间，第二点表明如何应对变化，太早对变化作出预测是有风险的，这无异于赌博，实际情况中我们常常是在发生小变化时，再去采取措施应对更大的变化，比如当需求是打八折时你应当考虑打任意折怎么办，当需求是实现加减乘除计算时你应当考虑开根号，求平方，取绝对值等变化。往往当你开始考虑更多的变化时，也实现了更多的抽象，程序也会更能应对不同的变化，因此我们希望能在越早的时候发生变化并创建抽象，这样也会付出越少的成本，不然等到后期再去为了创建抽象而重构代码就举步维艰了。<br>开放封闭原则是面向对象的核心所在，遵循这一原则可以使得程序可维护、可扩展、可复用、灵活性好，开发过程中要尽肯能的对频繁变化的部分作出抽象，但也不可刻意的抽象，拒绝不成熟的抽象也很重要。</p>
<h2 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h2><p>在开放封闭原则中我们说应对变化要对修改封闭，对扩展开放，而对扩展开放的方法是创建抽象隔离同类变化，这样的说法未免还是有些抽象，具体来说我们应该如何建立抽象呢，继续回顾我们之前的计算器和收银系统就会发现，最终版本的系统之所以能够应对变化，是因为他们都对业务逻辑的接口进行了封装，通过变化的子类继承不变的父类把变化封装了起来，再通过客户端多态的实例化完成了业务的调用。看来抽象父类的多态实例化和变化子类的继承才是关键，这也就涉及到了里氏代换原则。</p>
<blockquote>
<p>里氏代换原则（Liskov Substitution Principle)：子类型必须能够替换掉他们的父类型</p>
</blockquote>
<p>这样一句话乍一听有些莫名其妙，这个“必须”让人有些摸不着头脑，实际上是说一个软件实体如果是用的是一个父类的话，那么一定适用于其子类，而且调用者察觉不出父类对象和子类对象的区别，依然能够正常工作。我们常说面相对象可复用，而这一原则正是复用的理论基础，只有当子类继承父类，并且能够替代父类正常运行时，父类在作为调用接口才真正做到了复用，我们在计算器中的抽象计算父类和收银系统中的抽象优惠父类都是起到了这样的作用。而多态意味着子类在父类的基础上增加了新的行为，父类模块在无需修改的情况下进行了扩展，从而实现了程序的开放封闭原则。</p>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>我们说抽象类和接口是面向对象语言提供给用户来实现抽象的两大基础设施，上面谈了抽象类的意义，现在来聊接口，java语言中抽象类只能单继承，接口支持多实现，那么怎样设定接口才是好的设计呢，这里就要遵循接口隔离原则。</p>
<blockquote>
<p>接口隔离原则（Interface Segregation Principle）：类不应该被迫依赖他们不使用的方法</p>
</blockquote>
<p>这一原则是说一个接口应该拥有尽可能少的行为，因为在接口中所设定的抽象方法，实现类中必须予以实现，那么接口的设定就要尽可能的功能单一，实现类需要完成哪些功能，接口就应该设定哪些抽象方法。这听起来有些像类的单一职责原则，不过接口隔离原则与单一职责原则的审视角度不相同。单一职责原则要求是类和接口的职责单一，注重的是职责，这是业务逻辑上的划分。接口隔离原则要求接口的方法尽量少。</p>
<h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><p>我相信依赖这个词大家都不陌生，但在软件开发中的依赖指的是什么呢，在面向过程开发时，为了实现封装和代码的复用，我们通常把实现特定功能的代码封装成函数，在需要执行相应功能时调用该函数，这里就产生了高层模块依赖低层模块。为什么这么说呢，因为低层模块的代码都是固定的，高层模块想要调用就必须遵循低层模块函数的参数和返回值，通俗来说，就是高层得“听”低层的，对应到现实生活中就是生成汽车的得听生产轮胎的，显然这样的生产模式是不合理的，应该是大家制定好标准都遵循才对。再回到开发中，我们发现通常高层模块的业务都是差不多的，而所需要调用的低层模块却不尽相同，例如在OA系统中，面对数据库的操作无非增删改查几种，却因为数据库的不同而要调用不同的函数，这样如果还是延续以前的依赖模式，每种低层模块都封装相同功能的函数，那就光记不同的调用函数就要费很大劲，所以依赖倒转，刻不容缓。</p>
<blockquote>
<p>依赖倒转原则（Dependency Inversion Principle）：</p>
<ol>
<li>高层模块不应该依赖低层模块，二者都应该依赖抽象</li>
<li>抽象不应该依赖细节，细节应该依赖抽象</li>
</ol>
</blockquote>
<p>前面说高层不应该依赖低层，大家惯性思维可能会想低层难道要依赖高层吗，显然不是，就像现实世界中的工业并不存在上下游谁依赖谁的问题（这里指大环境下），而是大家都遵循行业制定的统一标准，也就是标准件，这样的设定有两个好处：一是更有利于组件的复用，现在的年轻人都流行自己组装电脑，根据自身需求选择响应性能的组件，正是由于配件的标准化使得这些来自不同厂商的零部件可以组装成一台功能完整的电脑，而且某个部件的损坏并不影响其他部件的复用；二是给了生产者很大的自主研发空间，文章开始我们就提到违背单一职责原则会导致一个职责的变化可能会削弱或抑制这个类完成其他职责的能力，同理如果某一环节的生产商需要依赖于他的上游或下游所指定的标准，那么在研发产品的过程中必定要对自身功能或设计理念有所取舍以便适应依赖，如果有行业标准的话生产商只要满足标准就不用再投入成本考虑适应变化，毕竟标准是相对稳定的。<br>对应到软件设计也是同样的道理，所谓的标准就是抽象，再具体说就是接口，我们要面向接口编程，而不是面向实现编程，面向接口可以帮助我们先构建系统的框架，在考虑细节的实现，使团队分工开发有了可能，但面向实现编程必须先实现模块才能考虑模块之间的连接。所以依赖抽象就是打破接口双方的依赖，谁也不依赖谁，耦合度大大降低，大家都可以灵活自如。<br>依赖倒转可以说是面向对象设计的标志，其思想精华在于用哪种语言写程序并不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之就是过程化的设计。</p>
<hr />
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单一职责原则</tag>
        <tag>开放封闭原则</tag>
        <tag>里氏代换原则</tag>
        <tag>接口隔离原则</tag>
        <tag>依赖倒转原则</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰者模式</title>
    <url>/design4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>玩过3D游戏的朋友可能对换装系统非常熟悉，游戏人物通过在商城购买或与玩家交易获得的装备可以用来改变游戏人物的外观或者提升游戏角色的属性，但你是否想过这样一套换装系统是如何实现的呢；再举一个暴露年龄的例子，很久以前PC端软件盛行的时代，年轻人大多热衷于美化自己的QQ秀，给自己聊天界面的人物形象购买一套好看的服饰。上述两个案例都涉及到了我们今天要说的装饰者模式这一设计思想，装饰者模式能够做到动态的给某一个实体增加功能或职责，但又不破坏该类的完整性，换句话说就是内部组装功能，最后返回类并调用功能。</p>
<a id="more"></a>

<div class="note info"><p>以下学习笔记内容由java语言编写。</p></div>

<p>以换装系统为例，现需求如下：要求玩家能够任意的组合自已的服饰，形成一套装扮。</p>
<h2 id="面向过程风格"><a href="#面向过程风格" class="headerlink" title="面向过程风格"></a>面向过程风格</h2><ul>
<li>服饰类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该类中包含所有服饰相关的包装函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Avatar</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Avatar</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wear_head</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.print(<span class="string">"头饰 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wear_ear</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.print(<span class="string">"耳饰 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wear_hand</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.print(<span class="string">"手饰 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wear_under</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.print(<span class="string">"内衣 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wear_coat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.print(<span class="string">"外套 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"装扮的"</span>+<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Enter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Avatar a1 = <span class="keyword">new</span> Avatar(<span class="string">"玩家1"</span>);</span><br><span class="line">		System.out.println(<span class="string">"第一种装饰："</span>);</span><br><span class="line">		a1.wear_hand();</span><br><span class="line">		a1.wear_under();</span><br><span class="line">		a1.show();</span><br><span class="line">	</span><br><span class="line">		Avatar a2 = <span class="keyword">new</span> Avatar(<span class="string">"玩家2"</span>);</span><br><span class="line">		System.out.println(<span class="string">"第二种装饰："</span>);</span><br><span class="line">		a2.wear_coat();</span><br><span class="line">		a2.wear_ear();</span><br><span class="line">		a2.wear_head();</span><br><span class="line">		a2.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下:</p>
<blockquote>
<p>第一种装饰：<br>手饰 内衣 装扮的玩家1<br>第二种装饰：<br>外套 耳饰 头饰 装扮的玩家2</p>
</blockquote>
<p>这个版本的代码虽然完成了要求的功能，且在一定程度上分离了界面和业务逻辑，但是还是将业务逻辑都封装在了同一个类中，这样的设计有两个显而易见的弊端：第一，通常商城中的装扮是很多的，而一个人物身上所能穿戴的是有限的，这样每一次生成新的对象时，大量用不到的代码也一同参与了编译，效率很低；第二，当商城推出新的饰品时，不得不修改该类，增加新的包装函数，显然违背了我们上一次所提到的开放封闭原则。</p>
<h2 id="面向对象风格"><a href="#面向对象风格" class="headerlink" title="面向对象风格"></a>面向对象风格</h2><ul>
<li>游戏角色类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"装扮的"</span>+<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>饰品父类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Avatar</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wear</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>饰品子类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvatarCoat</span> <span class="keyword">extends</span> <span class="title">Avatar</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.print(<span class="string">"外套 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvatarEar</span> <span class="keyword">extends</span> <span class="title">Avatar</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.print(<span class="string">"耳饰 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvatarHand</span> <span class="keyword">extends</span> <span class="title">Avatar</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.print(<span class="string">"手饰 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvatarHead</span> <span class="keyword">extends</span> <span class="title">Avatar</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.print(<span class="string">"头饰 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvatarUnder</span> <span class="keyword">extends</span> <span class="title">Avatar</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.print(<span class="string">"内衣 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Enter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"第一种装饰："</span>);</span><br><span class="line">		Player p1 = <span class="keyword">new</span> Player(<span class="string">"玩家1"</span>);</span><br><span class="line">		Avatar a = <span class="keyword">new</span> AvatarCoat();</span><br><span class="line">		a.wear();</span><br><span class="line">		a = <span class="keyword">new</span> AvatarEar();</span><br><span class="line">		a.wear();</span><br><span class="line">		p1.show();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"第二种装饰："</span>);</span><br><span class="line">		Player p2 = <span class="keyword">new</span> Player(<span class="string">"玩家2"</span>);</span><br><span class="line">		a = <span class="keyword">new</span> AvatarHand();</span><br><span class="line">		a.wear();</span><br><span class="line">		a = <span class="keyword">new</span> AvatarHead();</span><br><span class="line">		a.wear();</span><br><span class="line">		a = <span class="keyword">new</span> AvatarUnder();</span><br><span class="line">		a.wear();</span><br><span class="line">		p2.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<blockquote>
<p>第一种装饰：<br>外套 耳饰 装扮的玩家1<br>第二种装饰：<br>手饰 头饰 内衣 装扮的玩家2</p>
</blockquote>
<p>相比第一个版本，这次的饰品模块变成继承关系的饰品父类和具体装饰子类，减少了实例化饰品过程中的系统开销，再增加新饰品时也无需对已有模块进行改动，代码的质量有了很大的改善。当我们仔细分析代码就能发现，这个版本中装饰的过程并不是在装饰模块内部完成的，而是角色构建好之后将功能一个个调用实现的，饰品虽然和角色分属不同的类，但应该是和角色相关联的，我们可以将他们设计成聚合的关系，同时也可以利用装饰者模式来完成该功能。</p>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><blockquote>
<p><strong>装饰者模式（Decorator）</strong>：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。</p>
</blockquote>
<ul>
<li>角色类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个对象接口，可以动态的给这些对象添加职责</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"装扮的"</span>+name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>饰品父类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承角色类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Avatar</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> Person p;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decorate</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.p = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.p!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			p.show();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>饰品子类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvatarCoat</span> <span class="keyword">extends</span> <span class="title">Avatar</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.print(<span class="string">"外套 "</span>);</span><br><span class="line">		<span class="keyword">super</span>.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvatarEar</span> <span class="keyword">extends</span> <span class="title">Avatar</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.print(<span class="string">"耳饰 "</span>);</span><br><span class="line">		<span class="keyword">super</span>.show();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvatarHand</span> <span class="keyword">extends</span> <span class="title">Avatar</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.print(<span class="string">"手饰 "</span>);</span><br><span class="line">		<span class="keyword">super</span>.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvatarHead</span> <span class="keyword">extends</span> <span class="title">Avatar</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.print(<span class="string">"头饰 "</span>);</span><br><span class="line">		<span class="keyword">super</span>.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvatarUnder</span> <span class="keyword">extends</span> <span class="title">Avatar</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.print(<span class="string">"内衣 "</span>);</span><br><span class="line">		<span class="keyword">super</span>.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Enter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Person p = <span class="keyword">new</span> Person();</span><br><span class="line">		AvatarCoat ac = <span class="keyword">new</span> AvatarCoat();</span><br><span class="line">		AvatarEar ae = <span class="keyword">new</span> AvatarEar();</span><br><span class="line">		AvatarHand ah = <span class="keyword">new</span> AvatarHand();</span><br><span class="line">		AvatarUnder au = <span class="keyword">new</span> AvatarUnder();</span><br><span class="line">		AvatarHead ahe = <span class="keyword">new</span> AvatarHead();</span><br><span class="line">		</span><br><span class="line">		p.setName(<span class="string">"玩家1"</span>);</span><br><span class="line">		System.out.println(<span class="string">"第一种装饰："</span>);</span><br><span class="line">		ac.decorate(p);</span><br><span class="line">		ae.decorate(ac);</span><br><span class="line">		ah.decorate(ae);</span><br><span class="line"><span class="comment">//		ah.decorate(ah);//自己装饰自己，报错</span></span><br><span class="line">		ah.show();</span><br><span class="line">		</span><br><span class="line">		p.setName(<span class="string">"玩家2"</span>);</span><br><span class="line">		System.out.println(<span class="string">"第二种装饰："</span>);</span><br><span class="line">		ahe.decorate(p);</span><br><span class="line">		au.decorate(ahe);</span><br><span class="line">		ac.decorate(au);</span><br><span class="line">		ac.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<blockquote>
<p>第一种装饰：<br>手饰 耳饰 外套 装扮的玩家1<br>第二种装饰：<br>外套 内衣 头饰 装扮的玩家2</p>
</blockquote>
<p>标准的装饰者模式中</p>
<hr />
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>记一次算法的方案设计</title>
    <url>/droneCrossPhotograph.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>随着无人机技术的快速发展，其用途也变得越来越广泛，工业农业和日常生活中处处都可以看到无人机的影子，国产无人机品牌大疆也因其国际领先的技术和工业水准广为人知。虽然用途广泛，但是总结起来也无非信息收集和物品传输两大类，因为无人机相较于传统的侦测设备或物流设备突破的点就在于不受地形的限制和视野的约束，受限于目前无人机技术的续航能力和载重能力，在物品传输方面的选择比较有限，所以大量的无人机还是运用在航拍，范围搜索，地形侦测，活动单位追踪等方面。对于收集信息的无人机，一般而言都是人为操纵无人机的飞行航线并有选择地在适当时机来记录信息的，那么我们是否有可能让无人机按照一定的路线自动导航并进行信息的收集呢，下面我们就来尝试一下。</p>
<a id="more"></a>

<h2 id="问题抽象"><a href="#问题抽象" class="headerlink" title="问题抽象"></a>问题抽象</h2><p>假设我们现在想利用具备航拍功能的无人机了解某个区域的地形情况，那么我们需要考虑的情况会有哪些？如果在实际情况中，影响的因素会非常复杂，例如</p>
<blockquote>
<p>我们是否了解这块地形的大致情况，例如是一个矩形区域还是圆形区域，或者是不规则形状？</p>
<p>如果是矩形区域，那么他的长宽大致是多少；如果是圆形区域，那么他的半径大致是多少？</p>
<p>我们如何选择无人机的起飞位置呢？</p>
<p>无人机的续航是否足够其遍历整个区域再返回起始位置？你不会希望飞到一半无人机没电了坠落吧……</p>
<p>无人机每次拍摄地形信息都要进行存储，那么无人机最大支持的存储空间是否满足覆盖整个地形范围呢？</p>
<p>如果因为天气因素导致无人机偏离原本航线时如何处理呢？</p>
<p>如果无人机的续航能力无法保证其一次完成整个地形的探测任务，那么我们应该如何对整个航线进行分段探测呢？</p>
<p>……</p>
</blockquote>
<h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h3><p>如果我们不对整个问题的范围和变量做一定的约束，那么总会存在我们考虑不周到的点，使得整个问题在还没开始就变得无比复杂，与其这样，不如我们先对整个任务的资源和要求做一定的限制，在此基础上完成整个方案的核心要素，回过头来再在此基础上添加新的功能，增强算法的可扩展性和健壮性。</p>
<p>我们对整个任务做以下限制：</p>
<ul>
<li>我们将待探测的区域抽象为一个M×N大小的矩形区域，无人机的飞行轨迹可以看做在地图上的一个个坐标之间移动，移动距离使用两点间的曼哈顿距离</li>
<li>地图上的每个坐标范围内的区域信息用某种数据格式表示，其表示形式和含义不重要，这里假定为字符格式</li>
<li>无人机可以在地图上的任何位置进行航拍，每次拍摄可以记录当前位置及其前后左右四个方向的地图信息</li>
<li>无人机需要从地图上的某个点起飞，最终收集完整个地图的信息后返回出发点</li>
<li>无人机在飞行的过程中会消耗电量，且支持存储的航拍信息也有上限，这里不限定为具体数值，但需要尽可能的节省飞行距离和存储空间</li>
</ul>
<h3 id="为什么航拍的范围是“十字”"><a href="#为什么航拍的范围是“十字”" class="headerlink" title="为什么航拍的范围是“十字”"></a>为什么航拍的范围是“十字”</h3><p>以上就是我们假定的一些限制条件，部分同学可能有疑惑，为什么每次拍摄只能记录一个“十字”范围的区域信息，这样对飞行过程中收集地图信息带来很多难度，但是如果大家对真实无人机的航拍方式有所了解，其实这是有实际意义的。大家可以回头看一眼本篇博客封面的图片，就是一个航拍的照片，为了使得一次拍摄包含更多的地图信息，我们一般会选择使用广角摄像头，这种摄像头的成像结果会以当前位置为圆心，三百六十度无死角的将四面八方的地图拍成一张圆形的图像，如下图所示：</p>
<p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/droneCrossPhotograph1.png" alt="广角航拍范围视图"></p>
<p>我们为了方便计算，假设照片的范围正好与3×3的地图区域相切，那么此时图中左上，右上，左下，右下四个区域所能拍摄到的范围还不及当前单位面积的一半，因此不能算收集到了该区域的地图信息，单纯的观察图片可能无法得出靠谱的数据解释，我们可以通过Python的scipy库计算一下图中各个单位中所拍到的面积占单位面积的比例。</p>
<p>首先我们建立坐标系，因为圆形区域与正方形相交的部分除了中心位置的正方形面积被全部包括外，周围的八个部分可以分成两类，其中上下左右四个位置的面积是相等的，记为面积A；四个角落的位置同样是相等的，记为面积B。我们只需要求出面积A和B的大小即可，出于数值取整的考虑，我们将上图中一个小正方形区域的边长设置为2，同时为了方便求积分操作，我们把圆心放在[3,-1]位置，此时只需要计算圆的方程在[0,2]区间和[2,4]区间的积分结果，即为B和A的面积。</p>
<p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/droneCrossPhotograph2.png" alt="坐标系"></p>
<p>以下是计算和验证面积A和面积B的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> integrate</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">9</span>-(x<span class="number">-3</span>)**<span class="number">2</span>)**<span class="number">0.5</span><span class="number">-1</span></span><br><span class="line">v1, err = integrate.quad(f, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 2.125103815660392</span></span><br><span class="line">print(v1)</span><br><span class="line">v2, err = integrate.quad(f, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment"># 3.886959309833288</span></span><br><span class="line">print(v2)</span><br><span class="line"><span class="comment"># 0.531275953915098</span></span><br><span class="line">print(v1/<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 0.971739827458322</span></span><br><span class="line">print(v2/<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 面积验证</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="comment"># 28.274333882308138（通过πR^2计算的圆面积）</span></span><br><span class="line">print(<span class="number">9</span>*math.pi)</span><br><span class="line"><span class="comment"># 28.04825250197472（通过累加和大正方形相切的各个部分面积计算圆的面积）</span></span><br><span class="line">print((v1+v2)*<span class="number">4</span>+<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>通过计算结果我们看到面积A的大小为2.13，面积B的大小为3.89，已知一个正方形的面积为4（边长为2），因此面积A的占比只有该区域的53%，而面积B可以达到97%，因此在一次无人机航拍时，四个边角位置是无法获取其完整信息的。</p>
<h2 id="问题剖析"><a href="#问题剖析" class="headerlink" title="问题剖析"></a>问题剖析</h2><p>通过分析上文的几个限制条件，我们可以发现要完成一个无人机的航拍算法，需要考虑三个要点，评价算法的优劣有三大指标。先说三个要点：</p>
<ul>
<li>起飞位置</li>
<li>飞行航线</li>
<li>拍摄时机</li>
</ul>
<p>题目要求无人机在某个位置起飞完成整个区域的探测任务后还要返回起飞位置，实现一个完全自动化的巡航和拍摄任务，因此无人机从地图中的哪个位置起飞，飞行过程中要依据什么来选择移动路径，又依据什么来选择合适的拍摄时机，如何判断已经完成了拍摄任务，如何从最终位置返航，这些都是我们要精心规划的。</p>
<p>再看三大指标：</p>
<ul>
<li>信息收集</li>
<li>飞行距离</li>
<li>拍摄次数</li>
</ul>
<p>在最后两个条件中规定了这个算法的功能指标和性能指标，其中第四个条件要求无人机必须对整个地图的信息收集完整，这是一个功能性的指标，如果最终我们的算法使得收集的信息有遗漏，那么这个算法就是一个无法交付的版本；而第五个条件没有明确量化要求无人机的续航限制和内存限制，因为我们可以将其理解为两个性能相关的指标，其一是无人机的续航能力是有限的，每一次位置的移动都会耗费无人机的剩余电量，换句话说无人机一次续航后的航行里程是有上限的，我们要尽可能的减少无人机的移动次数；其二是无人机的存储容量是有限的，因此我们不能每次移动都进行拍摄，这样会造成存储的较大浪费（虽然实际情况中可能需要重复的位置信息来帮助我们勘误），因此我们要尽可能减少拍摄的次数。这两条指标是用于评价算法的性能，类似于我们用于评价算法的时间复杂度和空间复杂度。</p>
<h3 id="“十字”拼图"><a href="#“十字”拼图" class="headerlink" title="“十字”拼图"></a>“十字”拼图</h3><p>对于一个算法方案，最优先考虑的当前是实现其功能，其次再来优化性能，题目要求规划的路线和拍摄方案要收集完整个区域的地图信息，换句话说在这个M×N的地图上每一个点都要被拍到至少一次，直观的反映到地图上相当于我们拿着一个“十字”形状的印章盖在地图上，直到地图上的所有位置被盖过。由于从这一次拍摄到下一次拍摄这样一个过程是需要无人机一步步移动过去的，如果拍摄的顺序过于跳跃或者说两次拍摄为了避免重复而中间存在遗漏的区域，就会消耗额外的移动次数折返回去查漏补缺，因此考虑选择拍摄的时机尽可能在移动的距离尽可能小的情况下（这里说尽可能小而不是最小因为最小就退化为每次移动都进行拍摄，这样会出现大量的存储浪费），那么移动距离为多少比较合适呢，毫无疑问3最合适，因为一次拍摄的长和宽范围都是3，因此在当前拍摄点向任意方向不折返的移动3的步长，下一次拍摄就不会出现重复的拍摄信息，但是这三步怎么走，其实我们有很多种选择，基本可以分为下图中的三种：</p>
<p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/droneCrossPhotograph3.jpg" alt="无重复飞行路径"></p>
<ol>
<li>如图所示第一种是每一次拍摄后按直线的方式向右（也可以向左，向上，向下）移动3步，作为下一次的拍摄坐标，这种方式很直观也很有效，但这种方式无法避免的一个问题是会出现信息重复，图一中两次拍摄不论方向如何选择，在这两次的拍摄范围内都会存在两个位置的信息空缺，这意味着这两个位置需要在之后的折返过程中重新拍摄填补，即使是尽可能的使拍摄信息之间不重复，也会存在一个无法弥补的区域（图中黑色阴影的坐标）需要我们不得不以重复信息的代价来填补这一空缺；</li>
<li>相比第一种，第二种“十字”拼图的排列方式就巧妙得多，因为他并不是选择一味地向一个方向移动3的步长，而是将3步拆分成水平方向走1步和垂直方向走2步，这样的移动方式和第一种一样都是每次移动拍摄位置花费3步的距离，但是却有效避免了信息的重复，其对存储空间的利用效率就提升了不少；</li>
<li>同样的，第三种移动方式也是对3的步长选择了拆分，但与第二种不同的是，第二种总是选择水平方向的1步和垂直方向的2步（也可以选择水平方向的2步和垂直方向的1步），即最终的巡航路线接近于优先对某个范围的垂直方向（或水平方向，取决于移动方式的选择）进行遍历；但是第三种的移动方式我们发现他会在水平方向和垂直方向交替的进行1步和2步的选择，这样也能满足信息不出现重复，而其巡航路线则会更接近一种圆周运动。</li>
</ol>
<h3 id="时间优先VS空间优先"><a href="#时间优先VS空间优先" class="headerlink" title="时间优先VS空间优先"></a>时间优先VS空间优先</h3><p>从上面的尝试来看，显然不存在理想化的方案使得我们百分之百的充分利用每次拍摄收集的信息，我们无法避免存储空间的浪费，即使我们不考虑重复问题，位于地图的四个边角位置的坐标，我们不论以何种方式去拍摄这些位置的信息都会造成某个拍摄的范围位于整个地图之外，这个范围无疑就会被浪费掉。既然损失无法避免，也就是说不存在方案选择上的最优解，那么我们只能通过比较不同方案的性能来选择“较优解”或者更适应某种情况的解。</p>
<p>为了便于方案的性能评估，我们现在这里设定两个理想状态下的性能指标，第一个是存储空间的理想指标，由于整个地图的大小时M×N的，因此如果存在一种理想的拍摄方式，使得每次拍摄都不存在重复信息，且每次拍摄都可以得到5个有效的坐标信息，那么收集整个地图所需的拍摄次数为Math.ceiling(M×N÷5)，由于前面已经说明了实际巡航拍摄中一定存在信息的重复和损失，因此这只是一个理想值，实际方案不可能达到；第二个是航行时间的理想指标，正如之前的考虑，当我们的移动步长为3时，拍摄到的信息可以保证不重复，因此我们要拍摄完整个地图也至少要移动够3×Math.ceiling(M×N÷5)的距离，这只是从拍摄起点移动到拍摄终点的路程，如果要加上折返距离还要更大，但是航行的折返距离是取决于具体的航线规划的，不同规划方案最终拍摄完成后的坐标位置是不同的，我们也不排除存在航行拍摄完成后刚好回到起始位置的方案，因此关于时间上的理想指标（也可以叫航行距离理想指标）我们就按照3×Math.ceiling(M×N÷5)来计算。</p>
<h2 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h2><p>在测试无人机飞行拍摄方案时我们可以感性地认识到，当我们想要去节省无人机的飞行距离时，不得不付出重复拍摄信息的代价，而想要不重复的拍摄地图信息又需要无人机在飞行航线上做更加复杂的设计，从而使得飞行距离变长。也就是说作为衡量无人机飞行方案的两个性能指标存在潜在的负相关关系，具体的量化分析可能非常复杂，但是至少我们可以分别从两个方面去尝试逼近各自的最优解，再在此基础上看一下是否存在可以结合或优化的空间。因此基于这两种指标我们分别尝试给出最少移动距离方案，和最少拍摄次数方案。</p>
<h3 id="方案一：最短移动路径方案"><a href="#方案一：最短移动路径方案" class="headerlink" title="方案一：最短移动路径方案"></a>方案一：最短移动路径方案</h3><p>这个方案我们完全以移动距离为优先考虑的性能指标，即在满足拍摄信息覆盖整个地图的前提下，尽可能少的让无人机进行移动，不考虑节省拍摄次数，这一算法方案的实际意义主要有两个方面：</p>
<ol>
<li>目前的无人机续航问题相比空间存储问题的优先级更高，因为随着存储技术的进步，存储空间的成本越来越低，相比而言电池技术一直没有大的突破，基本是靠“堆量”堆出来的，但是无人机航行主要的耗电成本就是克服自身重量的做功，所以续航的提升是主要问题，设计尽可能少的航行距离在实际需求中优先级较高；</li>
<li>前面的分析也指出，拍摄区域信息的重复在实际意义中也有着勘误和验证的作用，并非纯粹浪费存储空间。</li>
</ol>
<p>设计这个路线最容易想到的就是<strong>以3行或3列为一个单位进行行遍历或列遍历</strong>，因为拍摄区域的长和宽都是3，所以我们在每一栋一层就拍摄3格的有效信息，同时出于无人机的移动尽可能少的考虑，采用“S”型遍历路线，即到达一侧边界后向下移动三格再以反方向遍历至另一侧，直到整个地图遍历完成。下面给出当地图大小为7×7时的路线图：</p>
<p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/droneCrossPhotograph4.jpg" alt="方案一路线图"></p>
<p>图中我们假定的无人机起飞位置在(1,0)坐标处，从S1起飞后向右不断移动，每次移动都对当前位置的拍摄范围进行拍摄，直到S7位置拍摄完成后向下移动3步到S8位置后继续向左移动并拍摄，值得注意的是如果我们最后一次遍历只剩下一行时可以对拍摄进行优化，如图所示只需要S15，S16，S17这三个位置进行拍摄即可涵盖所有地图信息，减少一定的存储压力。从这一点优化方案中我们可以发现，当地图的长宽M和N中存在某个值是3的整数倍或整数倍加1时，我们在另一条边上遍历可以减少一定的存储压力。</p>
<p>下面我们来计算一下这种方案的移动次数和拍摄次数：</p>
<ul>
<li>拍摄次数：Math.ceiling(M/3)×N</li>
<li>移动次数：Math.ceiling(M/3)×N+M（M为最终返航需要的移动距离）</li>
</ul>
<p>这只是一个大概的估计值，因为实际路线会根据具体情况进行优化，类似前面提到的只剩一行时我们不需要再每次移动都拍摄，因此该算法的具体表现需要等实现后通过数据测试才能确定，在此按下不表。</p>
<h3 id="方案二：“S”型路径优化方案"><a href="#方案二：“S”型路径优化方案" class="headerlink" title="方案二：“S”型路径优化方案"></a>方案二：“S”型路径优化方案</h3><p>方案一中虽然我们尽可能的压低移动距离，但是造成了大量的拍摄信息浪费，相比理想的拍摄次数MN/5提高到了MN/3，拍摄次数同比增幅为66.7%，也就是说比理想情况下的拍摄次数多了一半左右，我们需要想办法优化飞行路线，降低拍摄次数。这里我们想到前面的“十字拼图”中的第二种方案，其大致也是遵循先遍历某个方向，因此我们可以尝试用这种拍摄方式对第一种方案做优化，减少重复的拍摄次数。我们发现第二种拼图的方式在行或列的遍历中实际上只能保证两行或两列的有效覆盖范围，因为我们只能取其与矩形形状相交的部分，而不规则的位置同样是存在重复拍摄或信息损失的。所以我们可以先尝试用这种方式来遍历上面的地图，通过遍历的结果再来总结有哪些可以优化的方面。</p>
<p>以下给出方案二的航行路线图：</p>
<p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/droneCrossPhotograph5.jpg" alt="方案二路线图"></p>
<p>这里先解释一下无人机的移动规则，因为存在无人机移动至地图之外的情况，可能大家会存在疑惑，这里可以理解为为了遵循航行规则的统一性而做出的设定，毕竟<strong>无人机在空中航行时并没有飞行边界的限制，当无人机的拍摄范围内的五个位置包含M×N这个地图上的任意一个坐标时我们就认为这次拍摄是有意义的</strong>，这一点对于算法的设计尤为重要。</p>
<p>首先我们从地图的左上角起飞，以每两列为遍历单元，每次移动向着列的另一边移动行1步和列2步，而行的1步是方向交替的（口述起来比较复杂，相信大家看图可以一目了然），我们需要注意在两列遍历完成后下一次折返时逆向遍历下一个两列。由于我们不确定整个地图的长宽是多少，因此可能出现下一次的移动位置位于整个地图之外的情况，这里前面也有解释，这时只要无人机还能拍摄到地图内的区域我们就完成拍摄操作，例如图中的S8和S17位置。</p>
<p>从上图中来看似乎我们的优化没有起到减少拍摄次数的作用，方案一最终拍摄17次，方案二也是17次，其实不然，方案一我们是进行了优化的，最后一行只拍摄了3次，而方案二中最后一列并没有优化而是遵循了既有的路线规则。其实换个角度考虑如果我们将地图范围稍作修改增加一行或一列（其实没有什么差别，都是7×8的地图范围），那么我们再来看，对于方案一来说就无法再进行优化，最后一列需要从头拍摄到尾，累计拍摄总和21次；而对于方案二呢，我们会发现增加的这一列元素已经完全被当前已有的拍摄次数所覆盖了（观察S13至S17的拍摄范围即可）。因此我们的优化方案是起到了一定减少拍摄次数的效果的，但具体的评估还是需要最终用不同量级的数据测试后观察。</p>
<h3 id="方案三：螺旋航行拍摄方案"><a href="#方案三：螺旋航行拍摄方案" class="headerlink" title="方案三：螺旋航行拍摄方案"></a>方案三：螺旋航行拍摄方案</h3><p>现在我们先来分析一下方案二存在的问题，虽然相比方案一已经有效提升了拍摄的效率但是仍然存在信息的重复和损失，并且从初始的位置就损失了两个单位的信息，S8位置甚至一次拍摄丢失了四个单位的位置信息；而重复信息的情况例如S2和S6之间、S7和S9之间都存在两个单位的信息重复。虽然我们已经分析过拍摄过程中无法避免拍摄的信息重复和信息丢失情况，但是我们考虑能否将这种情况尽可能的延后至整个巡航过程的最后阶段，即我们优先收集最有效的信息，最后再将边界位置没有收集到的坐标信息查漏补缺的拍摄一遍。</p>
<p>这里我们就可以利用到“十字”拼图中的第三种方案，以这种螺旋的方式逐步收集到一定范围内的元素，这种飞行路线可以从某一个点开始向四周辐射，并且在拍摄的过程中保证不会出现信息的重复拍摄，那么我们在选择起飞位置的时候，越靠近整个地图的中间位置在向周围辐射的过程中就不会出现失衡的情况，即辐射的范围和原本的地图区域是中心对称的，不会出现一边还可以每次收集五个有效坐标信息，相对的另一边已经五个位置都扩展到了整个地图之外，那么这样的移动和拍摄就没有意义了。</p>
<p>下面我们给出方案三的航行路线图：</p>
<p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/droneCrossPhotograph6.jpg" alt="方案三路线图"></p>
<p>相较于第二种飞行路线，这种航行的路线更加复杂，下面我们来分析一下。首先无人机选择从整个地图的中心位置起飞，以3步的步长为间隔进行拍摄，但是这3步的移动规则比较复杂，在尝试旋转移动时我们说在这种航行路线的移动是在水平方向和垂直方向上交替的进行1步和2步的移动，但是如果每走一步就更换移动的方向和步长顺序就会出现“十字”拼图示例中给出的第三种结构一样，只是在四个相邻的环中循环，无法扩大其拍摄范围。因此我们需要改变一定的规则，使得在旋转的过程中还能不断扩大拍摄的范围，从图中的路线来看可以这样描述移动的规则：</p>
<ul>
<li>存在四种固定顺序的移动模式，依次是向当前位置的右下（参考S1-&gt;S2），左下（参考S2-&gt;S3），左上（参考S3-&gt;S4），右上（参考S5-&gt;S6）方向移动3的步长</li>
<li>初始改变移动模式的阈值为1，每一种移动方式移动达到阈值后更换下一种移动模式</li>
<li>阈值会在每两次改变移动模式后加1</li>
</ul>
<p>这是不进行任何优化的初始版移动规则，当然我们需要根据地图的实际情况来优化，由于螺旋辐射的过程中不可避免的最终无人机的移动位置会跳出地图的范围，和方案二的优化规则相同，我们出于统一算法的目的，跳过无人机拍摄范围完全跳出地图的情况（例如方案图中S9至S10之间就跳过一个按照原本规则应该包括的位置）。</p>
<p>从方案设计图的情况来看，最终依然进行和17次的拍摄才收集全了整个地图的位置信息，和方案二似乎没有出入，但是仔细观察这17次拍摄的覆盖范围就可以发现，如果将地图的长和宽都扩大一个量级至8×8的范围，那么目前的拍摄范围距离全部的地图信息只有4个遗漏的坐标信息分布在各个边上，换句话说我们只需要21次拍摄就可以完成对一个8×8范围的地图的信息收集。除此之外这种算法相比前两种方案还有三点优势，分别是</p>
<ol>
<li>前期拍摄信息不重复</li>
<li>优先记录中心区域信息</li>
<li>最终拍摄完成的位置距起始飞行位置近</li>
</ol>
<p>先来说第一点，前期飞行过程不会出现拍摄信息的重复意味着什么，还记得我们前面讨论存储空间的理想指标是多少吗？答案是Math.ceiling(M×N÷5)，虽然由于收集信息结构和地图的结构无法完美匹配导致了拍摄信息的重复和损失，但是我们一旦能够将拍摄信息重复和损失的情况延后，就能够在越早的移动范围内获取大量的地图区域信息，此时如果因为续航能力的不足或其他不可控因素导致要提前结束巡航过程，这种方案在信息的收集度上就有更大的优势。就以方案三的示例情况来看，我们仅仅截取前期的拍摄覆盖范围来看，如图所示：</p>
<p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/droneCrossPhotograph7.jpg" alt="方案三前期路线图"></p>
<p>当从起飞开始9次拍摄接受时对整个区域信息的掌握情况已经达到了83.7%，这样的信息收集效率如果我们对地图的信息收集要求没有百分之百这么高的话，我们只使用了方案一和方案二的一般存储空间就逼近了前两种方案的信息量，足以看出这种方案的优势。</p>
<p>再来看第二点，优先获取地图中心区域的信息在实际情况中往往有着更强的意义，显然当我们希望对一个区域的地形情况或其他信息进行巡查时一定是更关心该区域的中心位置而非边界，除非需要对整个区域进行地毯式的搜索，那么不论我们选择从一边到另一边的遍历还是从中心到四周的遍历都是一样的，其余大部分情况下这种遍历方式都更具优势。</p>
<p>最后一点显然也很好理解，如果我们把整个螺旋扩展的过程看做一个近似的圆，那么总终返回起飞位置的返航距离一定只是一个半径长度，反应在矩形区域中就坐落在某个边长的一半到两条边之和的一半这两者的区间内；反观方案一和方案二，基本返航距离都是该方案的两倍左右。</p>
<h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><p>在我们实现上述的三种航拍算法之前先来思考一下整个代码的体系结构，因为面向对象的编程思想告诉我们，适当的抽象和封装可以使我们的代码实现有效的复用，并且具备足够的可读性。尤其是在这个案例中，天然的就具有无人机这个实体，我们所要设计的一切操作都是围绕这个实体，即使上面设计了三种不同的飞行航线，其中依然用到了无人机的相同行为，例如飞行，拍摄和返航等。因此我们先对整个代码的结构做如下规划：</p>
<p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/droneCrossPhotograph8.jpg" alt="代码类图"></p>
<p>其中，我们遵循面向对象的编程思想，将无人机抽象为IDrone接口，在接口中定义无人机的一系列行为，包含数据的初始化，移动，拍摄，返航等，而这些功能的具体实现方式实现在Drone类中。无人机的实体通过聚合的方式与航行算法抽象类PathStrategy类进行聚合，航行算法抽象类中包含两个航行算法相关的抽象算法：地图信息收集算法和地图信息还原算法，分别对应信息的输入和输出；同样的这两个方法的具体实现在具体航行算法的实现类中，正如上文我们设计了三种方案，分别对应三个实现类，其中MinMoveStrategy对应最短移动路径方案，STypePathStrategy对应“S”型路径优化方案，SpinPathStrategy对应螺旋航行拍摄方案。这样设计，即使后期我们有了新的航行算法，也可以简单的通过类的继承实现代码的复用，具有较强的可扩展性。最后客户端和算法抽象类之间具有关联关系，当客户端调用相应的航行算法进行地图信息的输入输出时，传入地图对象初始化好的无人机对象，选择所采用的航行算法即可得到结果。</p>
<p>下面我们来看一下整个算法最终版的代码体系结构：</p>
<p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/droneCrossPhotograph9.jpg" alt="代码类图"></p>
<p>可以看到主体的架构和我们上述分析的保持一致，同时为了功能的完整性，规范性和更进一步的可扩展性我们增加了部分代码，体现在以下几个方面：</p>
<ol>
<li>增加IO工具类，将算法中需要输出信息的部分功能进行抽象，主要包括输出航行日志信息和输出最终的地图信息，这样做的好处是后期便于我们希望实现多渠道的信息输出时，只需要扩展该工具类的功能，就可以将信息输出至本地文件、网络等其他渠道中；</li>
<li>使用策略模式对无人机航行算法进行了抽象和封装，降低了客户端在调用算法接口时的耦合性，由于客户端在使用某种算法时并不关心算法的细节，因此我们应该尽可能的将算法相关的类和代码与客户端隔离，策略模式可以很好地帮助我们实现这一需求；</li>
<li>在代码中出现有限个情况选择时使用枚举类型代替字符串或数字，例如算法的选择，输出信息的种类等，增强代码的可读性和安全性。</li>
</ol>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>代码的具体实现囿于篇幅有限这里不全部列出，有兴趣的同学可以访问我的GitHub仓库进行浏览，这里给出<a href="https://github.com/shitsurei/dsa/tree/master/graph/src/DroneCrossPhotograph" target="_blank" rel="noopener">链接</a>。下面我就算法中几个重要的方法结合代码做一点讲解，首先是最短移动路径方案算法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">route</span><span class="params">(IDrone drone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setDrone(drone);</span><br><span class="line">        <span class="keyword">int</span> m = drone.getMap().length, n = drone.getMap()[<span class="number">0</span>].length;</span><br><span class="line"><span class="comment">//        deal just one line</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>, restAll = m * n;</span><br><span class="line">        <span class="keyword">int</span>[] xChange, yChange;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) &#123;</span><br><span class="line">            xChange = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>&#125;;</span><br><span class="line">            yChange = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, m - <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span> - m&#125;;</span><br><span class="line">            drone.init(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            xChange = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span> - n&#125;;</span><br><span class="line">            yChange = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>&#125;;</span><br><span class="line">            drone.init(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (restAll &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tempX = drone.getCurX() + xChange[index];</span><br><span class="line">            <span class="keyword">if</span> (tempX &gt;= n)</span><br><span class="line">                tempX = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> tempY = drone.getCurY() + yChange[index];</span><br><span class="line">            <span class="keyword">if</span> (tempY &gt;= m)</span><br><span class="line">                tempY = m - <span class="number">1</span>;</span><br><span class="line">            index++;</span><br><span class="line">            index %= <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">if</span> (tempX == drone.getCurX()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tempY &gt; drone.getCurY()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = drone.getCurY(); i &lt;= tempY; i++) &#123;</span><br><span class="line">                        drone.move(tempX, i, <span class="keyword">false</span>);</span><br><span class="line">                        restAll -= drone.shoot(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = drone.getCurY(); i &gt;= tempY; i--) &#123;</span><br><span class="line">                        drone.move(tempX, i, <span class="keyword">false</span>);</span><br><span class="line">                        restAll -= drone.shoot(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tempY == drone.getCurY()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tempX &gt; drone.getCurX()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = drone.getCurX(); i &lt;= tempX; i++) &#123;</span><br><span class="line">                        drone.move(i, tempY, <span class="keyword">true</span>);</span><br><span class="line">                        restAll -= drone.shoot(<span class="keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = drone.getCurX(); i &gt;= tempX; i--) &#123;</span><br><span class="line">                        drone.move(i, tempY, <span class="keyword">true</span>);</span><br><span class="line">                        restAll -= drone.shoot(<span class="keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        drone.returnStart(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> drone.getSumFeet();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里与最短移动路径相关的代码逻辑主要可以分为三个部分：</p>
<ol>
<li>开始对地图矩形长宽的逻辑判断，目的是决定无人机的初始升空位置和遍历的方向顺序，这里选择的不同可能会影响最终无人机返航的路径距离。根据方案一中的推论，最终拍摄完成的位置如果和初始升空位置在同一侧，那么只需要移动大约一条边的距离即可返航，而如果不在同一侧则需要移动两条临边的距离才能返航，那么我们总是选择先遍历较长的边，即可在最终返航时只需要移动单边的情况下移动短边的距离返回初始位置；</li>
<li>中间循环部分，这里我们判断循环结束的条件是剩余未拍摄到的坐标个数不大于0，其他两个算法中的判断航拍任务是否完成也是采用该指标，这样的优点是保证了题目要求的收集完备整个地图中的地形信息，而实现方式也比较容易，即通过在无人机的初始化阶段通过判断地图的大小确定整个地图中需要收集的坐标个数，同时在拍摄过程中记录已经拍摄过的坐标位置，每次拍摄都返回当前新获得坐标信息个数即可。而该算法中我们基本上是每次移动都要进行拍摄的，因此我们先确定当前方向的遍历最终停下的位置，然后通过循环这些坐标来每次移动都进行拍摄，需要注意的点在于地图边界的判断和越界规避；</li>
<li>最后则是无人机的返航部分，通过调用已经封装好的返航方法完成。</li>
</ol>
<p>下面给出“S”型路径优化方案算法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">route</span><span class="params">(IDrone drone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setDrone(drone);</span><br><span class="line">        <span class="keyword">int</span> m = drone.getMap().length, n = drone.getMap()[<span class="number">0</span>].length;</span><br><span class="line">        drone.init(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> nextX = <span class="number">0</span>, nextY = <span class="number">0</span>, restAll = m * n;</span><br><span class="line">        <span class="keyword">int</span>[] xChangeColumn = &#123;<span class="number">2</span>, <span class="number">2</span>&#125;, xChangeRow = &#123;-<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] yChangeColumn = &#123;<span class="number">1</span>, -<span class="number">1</span>&#125;, yChangeRow = &#123;<span class="number">2</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> columnIndex = <span class="number">0</span>, rowIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (restAll &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            restAll -= drone.shoot(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (restAll == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> tempX = nextX + xChangeColumn[columnIndex % <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> tempY = nextY + yChangeColumn[columnIndex % <span class="number">2</span>];</span><br><span class="line">            columnIndex++;</span><br><span class="line">            <span class="keyword">if</span> (valuable(tempX, tempY, m, n)) &#123;</span><br><span class="line">                nextX = tempX;</span><br><span class="line">                nextY = tempY;</span><br><span class="line">                drone.move(nextX, nextY, <span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nextX += xChangeRow[rowIndex % <span class="number">2</span>];</span><br><span class="line">                nextY += yChangeRow[rowIndex % <span class="number">2</span>];</span><br><span class="line">                rowIndex++;</span><br><span class="line">                columnIndex++;</span><br><span class="line">                xChangeColumn[<span class="number">0</span>] = -xChangeColumn[<span class="number">0</span>];</span><br><span class="line">                xChangeColumn[<span class="number">1</span>] = -xChangeColumn[<span class="number">1</span>];</span><br><span class="line">                drone.move(nextX, nextY, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	drone.returnStart(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> drone.getSumFeet();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该算法的实现与方案一的代码结构类似，但是由于这一算法的移动规则比较复杂，因此没有引入优先遍历方向的判断，所以可以看到该算法中无人机固定从左上角起飞，在当前位置拍摄后，如何确定下一次的拍摄位置是该算法的难点，我们可以看到循环中有一个valuable的方法，这是所有航拍算法的父类PathStrategy类中的一个非抽象的protected方法，因此仅供其子类使用，作用是判断某个位置是否可以拍摄到整个地图中的信息，方法实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * judge if current location could shoot message in valuable map</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">valuable</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> value = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[] xChange = &#123;<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] yChange = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tempX = x + xChange[i];</span><br><span class="line">            <span class="keyword">int</span> tempY = y + yChange[i];</span><br><span class="line">            <span class="keyword">if</span> (tempX &gt;= <span class="number">0</span> &amp;&amp; tempX &lt; m &amp;&amp; tempY &gt;= <span class="number">0</span> &amp;&amp; tempY &lt; n) &#123;</span><br><span class="line">                value = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>了解了该方法的作用再回头看原方法的代码逻辑，就能明白我们在列方向遍历和移动的过程中一旦出现越界“严重”（即拍摄不到有用信息）的情况，就需要进行行方向的移动，除此之外列方向下一次的移动顺序和之前要完全相反。这也是代码中变量命名tempX和tempY的用意，即我们在原规则的基础上试探性的进行一次列方向的移动，而无人机是否最终进行该移动，取决于是否可以拍摄到有价值的信息；而一旦无法拍摄到有价值的信息，我们就要在原位置的基础上进行行移动，所以这是一个以列移动为主、行移动为辅的移动顺序。其余的判断循环结束条件和无人机返航的逻辑与上一个方案相同。</p>
<p>最后我们来看螺旋航行拍摄方案算法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">route</span><span class="params">(IDrone drone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setDrone(drone);</span><br><span class="line">        <span class="keyword">int</span> m = drone.getMap().length, n = drone.getMap()[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> startX = (m - <span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span>, startY = (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        startX = startX &lt; <span class="number">0</span> ? <span class="number">0</span> : startX;</span><br><span class="line">        startY = startY &lt; <span class="number">0</span> ? <span class="number">0</span> : startY;</span><br><span class="line">        drone.init(startX, startY);</span><br><span class="line">        <span class="keyword">int</span>[] xChange = &#123;<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] yChange = &#123;<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>, restAll = m * n;</span><br><span class="line">        <span class="keyword">int</span> nextX = startX, nextY = startY;</span><br><span class="line">        <span class="keyword">while</span> (restAll &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            restAll -= drone.shoot(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (restAll == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> tempIndex = nextIndex(index++);</span><br><span class="line">            nextX += xChange[tempIndex];</span><br><span class="line">            nextY += yChange[tempIndex];</span><br><span class="line">            <span class="keyword">while</span> (!valuable(nextX, nextY, m, n)) &#123;</span><br><span class="line">                tempIndex = nextIndex(index++);</span><br><span class="line">                nextX += xChange[tempIndex];</span><br><span class="line">                nextY += yChange[tempIndex];</span><br><span class="line">            &#125;</span><br><span class="line">            drone.move(nextX, nextY, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        drone.returnStart(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> drone.getSumFeet();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该算法的代码逻辑相比之前两个方案要清楚得多，一方面是因为这个算法的移动规则比较统一，不需要像之前的算法方案要进行各种逻辑判断，另一方面也是因为对该算法的封装程度较高。我们先来看算法的整体流程，首先不同于前面的算法，这里会根据整个地图的大小对无人机的初始位置进行计算，并将计算的结果做越界检查；其次我们依然要确定每次无人机的移动方向，正如方案三所分析的那样，虽然螺旋式的拍摄只有四种移动方式，但四种移动方式的交替顺序是按一定规则变化的，这就是代码中nextIndex方法对这一规则所做的抽象，因为移动方式的排列次序是确定的，只是无法按照每次交替的规则，所以我们将下一次的移动次数作为参数皆可以获得移动的方式，该方式的实习如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * find next move direction</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> floor = (<span class="keyword">int</span>) Math.floor(Math.sqrt(index));</span><br><span class="line">        <span class="keyword">int</span> base = floor % <span class="number">2</span> == <span class="number">0</span> ? <span class="number">3</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> odd = index - floor * floor;</span><br><span class="line">        <span class="keyword">if</span> (odd &gt;= floor) &#123;</span><br><span class="line">            index = (base + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该算法通过当前移动的次数确定下一次移动的方式在移动方式数组中索引下标，了解了这个方法的含义，其余代码或多或少在前面也有所提及，这里不再赘述。</p>
<h2 id="算法测试"><a href="#算法测试" class="headerlink" title="算法测试"></a>算法测试</h2><p>最后我们结合之前给出的部分指标进行算法性能的评估，主要包括以下指标：</p>
<ul>
<li>累计路径</li>
<li>累计拍摄次数</li>
<li>理想路径</li>
<li>无损拍摄次数</li>
<li>路径比</li>
<li>有效信息比</li>
</ul>
<p>在用于测试的数据量级上，囿于机器性能有限，我们从个位数的地图尺寸大小开始，每次增加指数级别的大小，直到地图的边长到达三位数。</p>
<h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><table>
<thead>
<tr>
<th align="left">地图大小</th>
<th>初始位置</th>
<th align="left">累计路径</th>
<th align="left">理想路径</th>
<th>累计拍摄</th>
<th>无损拍摄</th>
<th>有效信息比</th>
</tr>
</thead>
<tbody><tr>
<td align="left">3×3</td>
<td>(0,1)</td>
<td align="left">4</td>
<td align="left">6</td>
<td>3</td>
<td>2</td>
<td>66.7%</td>
</tr>
<tr>
<td align="left">5×5</td>
<td>(0,1)</td>
<td align="left">14</td>
<td align="left">15</td>
<td>12</td>
<td>5</td>
<td>41.7%</td>
</tr>
<tr>
<td align="left">9×9</td>
<td>(0,1)</td>
<td align="left">44</td>
<td align="left">57</td>
<td>31</td>
<td>19</td>
<td>61.3%</td>
</tr>
<tr>
<td align="left">17×17</td>
<td>(0,1)</td>
<td align="left">126</td>
<td align="left">174</td>
<td>112</td>
<td>58</td>
<td>51.8%</td>
</tr>
<tr>
<td align="left">33×33</td>
<td>(0,1)</td>
<td align="left">444</td>
<td align="left">654</td>
<td>383</td>
<td>218</td>
<td>56.9%</td>
</tr>
<tr>
<td align="left">65×65</td>
<td>(0,1)</td>
<td align="left">1534</td>
<td align="left">2535</td>
<td>1472</td>
<td>845</td>
<td>57.4%</td>
</tr>
<tr>
<td align="left">129×129</td>
<td>(0,1)</td>
<td align="left">5884</td>
<td align="left">9987</td>
<td>5631</td>
<td>3329</td>
<td>59.1%</td>
</tr>
</tbody></table>
<p>通过对方案一进行测试，我们可以看出最短移动路径算法“名副其实”，随着问题规模的扩大，累计路径和理想路径的相差越来越大，当数据规模达到三位数后该算法的实际所需累计路径将近节省了50%（以理想路径做参照），而相应的也付出了一定的存储空间代价，随着数据量级的增大，有效信息比最终稳定在60%左右这个区间，也就是说平均来看每次拍摄地图信息可以收集到3个新的坐标信息，表现基本及格，性能还需要和之后的两个算法进行对比再下定论。</p>
<h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><table>
<thead>
<tr>
<th align="left">地图大小</th>
<th>初始位置</th>
<th align="left">累计路径</th>
<th align="left">理想路径</th>
<th>累计拍摄</th>
<th>无损拍摄</th>
<th>有效信息比</th>
</tr>
</thead>
<tbody><tr>
<td align="left">3×3</td>
<td>(0,0)</td>
<td align="left">12</td>
<td align="left">6</td>
<td>4</td>
<td>2</td>
<td>50.0%</td>
</tr>
<tr>
<td align="left">5×5</td>
<td>(0,0)</td>
<td align="left">32</td>
<td align="left">15</td>
<td>9</td>
<td>5</td>
<td>55.6%</td>
</tr>
<tr>
<td align="left">9×9</td>
<td>(0,0)</td>
<td align="left">88</td>
<td align="left">57</td>
<td>25</td>
<td>19</td>
<td>76.0%</td>
</tr>
<tr>
<td align="left">17×17</td>
<td>(0,0)</td>
<td align="left">272</td>
<td align="left">174</td>
<td>81</td>
<td>58</td>
<td>71.6%</td>
</tr>
<tr>
<td align="left">33×33</td>
<td>(0,0)</td>
<td align="left">928</td>
<td align="left">654</td>
<td>289</td>
<td>218</td>
<td>75.4%</td>
</tr>
<tr>
<td align="left">65×65</td>
<td>(0,0)</td>
<td align="left">3392</td>
<td align="left">2535</td>
<td>1089</td>
<td>845</td>
<td>77.6%</td>
</tr>
<tr>
<td align="left">129×129</td>
<td>(0,1)</td>
<td align="left">12928</td>
<td align="left">9987</td>
<td>4225</td>
<td>3329</td>
<td>78.8%</td>
</tr>
</tbody></table>
<p>通过对比方案二的测试结果就可以看出方案一在移动距离上的优势，但是方案二的有效信息比相比方案一就有了显著提高，随着数据量级的增大最终稳定在77%左右这个区间，相比方案一的有效信息比提高了15%。</p>
<h3 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h3><table>
<thead>
<tr>
<th align="left">地图大小</th>
<th>初始位置</th>
<th align="left">累计路径</th>
<th align="left">理想路径</th>
<th>累计拍摄</th>
<th>无损拍摄</th>
<th>有效信息比</th>
</tr>
</thead>
<tbody><tr>
<td align="left">3×3</td>
<td>(0,1)</td>
<td align="left">12</td>
<td align="left">6</td>
<td>4</td>
<td>2</td>
<td>50.0%</td>
</tr>
<tr>
<td align="left">5×5</td>
<td>(1,2)</td>
<td align="left">38</td>
<td align="left">15</td>
<td>9</td>
<td>5</td>
<td>55.6%</td>
</tr>
<tr>
<td align="left">9×9</td>
<td>(3,4)</td>
<td align="left">94</td>
<td align="left">57</td>
<td>24</td>
<td>19</td>
<td>79.2%</td>
</tr>
<tr>
<td align="left">17×17</td>
<td>(7,8)</td>
<td align="left">278</td>
<td align="left">174</td>
<td>71</td>
<td>58</td>
<td>81.7%</td>
</tr>
<tr>
<td align="left">33×33</td>
<td>(15,16)</td>
<td align="left">996</td>
<td align="left">654</td>
<td>244</td>
<td>218</td>
<td>89.3%</td>
</tr>
<tr>
<td align="left">65×65</td>
<td>(31,32)</td>
<td align="left">3870</td>
<td align="left">2535</td>
<td>897</td>
<td>845</td>
<td>94.2%</td>
</tr>
<tr>
<td align="left">129×129</td>
<td>(63,64)</td>
<td align="left">14734</td>
<td align="left">9987</td>
<td>3432</td>
<td>3329</td>
<td>97.0%</td>
</tr>
</tbody></table>
<p>最后我们来看方案三的测试结果，我们欣喜地发现随着问题规模的扩大，有效信息比不断攀升，当上升至三位数时有效信息比已经达到95%以上，这说明该算法对存储空间的利用率已经接近了百分之百。但是相应的该算法也相比方案二付出了更多的路径长度，方案二中以理想路径为参考每次拍摄间隔需要多移动约0.3步，而方案三中需要多移动约0.45步，而方案一中不是以3步的步长为一次拍摄间隔故不做对比。</p>
<p>方案三相比方案二的另一个隐患在于我们都是使用临边相等的矩形地图来测试，对于方案一和方案二这种与地图临边平行的移动方式，地图的临边是否相等是不受影响的；但这种地图结构天生适用于螺旋式的遍历过程，如果临边长度不相等，该算法的性能又如何呢，下面我们以一定的増长速度扩大临边之间的差距，再来测试一下该算法的性能表现：</p>
<table>
<thead>
<tr>
<th align="left">地图大小</th>
<th>初始位置</th>
<th align="left">累计路径</th>
<th align="left">理想路径</th>
<th>累计拍摄</th>
<th>无损拍摄</th>
<th>有效信息比</th>
</tr>
</thead>
<tbody><tr>
<td align="left">5×10</td>
<td>(3,2)</td>
<td align="left">76</td>
<td align="left">30</td>
<td>16</td>
<td>10</td>
<td>62.5%</td>
</tr>
<tr>
<td align="left">5×15</td>
<td>(6,2)</td>
<td align="left">126</td>
<td align="left">45</td>
<td>23</td>
<td>15</td>
<td>65.2%</td>
</tr>
<tr>
<td align="left">5×25</td>
<td>(11,2)</td>
<td align="left">258</td>
<td align="left">75</td>
<td>37</td>
<td>25</td>
<td>67.6%</td>
</tr>
<tr>
<td align="left">5×40</td>
<td>(18,2)</td>
<td align="left">532</td>
<td align="left">120</td>
<td>58</td>
<td>40</td>
<td>69.0%</td>
</tr>
<tr>
<td align="left">5×50</td>
<td>(23,2)</td>
<td align="left">764</td>
<td align="left">150</td>
<td>72</td>
<td>50</td>
<td>69.4%</td>
</tr>
</tbody></table>
<p>果不其然，当临边不相等时该算法的性能有了明显的下降，有效信息比最终稳定在70%这个区间，相比方案二还低了10%左右，所以可以看出方案三的适用条件是有一定局限性的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>综上所述，我们将三种算法测试下来，可以得出并没有任何一种算法在各个层面都可以做到性能最优，每一种算法都有其合适的使用场景，方案一适用于对移动路径距离敏感的场景，例如续航能力一般但内存空间容量大的无人机；方案三正好相反，适用于对存储空间敏感的场景，但是方案三又需要地图的临边差距较小，接近于正方形；方案二则是一个在各个性能指标上比较折中的算法，适用场景比较广泛，时间和空间的性能也比较优良，是大多数场景中推荐使用的无人机航拍算法。</p>
<hr />
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《醉步男》读后感</title>
    <url>/drunkMan.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>血沼，我以后大概都不会和你相遇了。</p>
<p>话没说完，小竹田从我眼前消失了。不仅仅是人消失不见，连放在他桌子上的威士忌也消失了。仿佛从头到尾都只有我一个人孤孤单单地坐在酒馆里。</p>
<p>一阵寒意袭上身来。</p>
<a id="more"></a>

<p>不久前在豆瓣2019年读书榜单上看到许多人推荐这本<a href="https://baike.baidu.com/item/小林泰三" target="_blank" rel="noopener">小林泰三</a>的科幻小说《醉步男》，题材与时间旅行相关，看了一些书评感觉好奇，便购买回来阅读。小说不长，几个小时就可以读完，读完后我确实被书中的设定和想象力震撼到了，后来了解到这本书是2019年的再版，原小说写作的年代已经距今将近二十年了，这就不得不让我更加佩服作者的脑洞。再深入了解，原来作者的本业就是通信工程师，也怪不得这本小说被称作“硬核科幻”，从前后的情节可以看出作者缜密的逻辑思维和准确的语言表述，一旦接受了最初始的设定，那么后面的所有故事基本上没有破绽和漏洞可言。在反复阅读了好几遍之后，我想把一些自己的思考写下来。</p>
<h2 id="日式哲学"><a href="#日式哲学" class="headerlink" title="日式哲学"></a>日式哲学</h2><p>严格来讲《醉步男》是我看的第一本日本科幻小说，以往看日本推理小说较多，印象中日本小说也以推理见长，科幻上如果除去近年来《三体》、《北京折叠》等作品知名度较高外一直是欧美见长，但是这本小说让我对这一成见有了改观。虽然本书的设定没有任何宏大的架构，但是所延伸出去的思考是很有分量的，这个我们后面在聊到情节时再展开。</p>
<p>其实抛开作品题材我在阅读日本文学作品时有一个很深的感受，就是日本的作家擅长对人的心理活动进行细致准确地刻画，典型代表就是<a href="[https://wiki.hk.wjbk.site/baike-%E8%8A%A5%E5%B7%9D%E9%BE%99%E4%B9%8B%E4%BB%8B](https://wiki.hk.wjbk.site/baike-芥川龙之介)">芥川龙之介</a>的短篇小说，黑泽明导演的《罗生门》就出自于芥川的作品《竹林中》，其中“罗生门”也作为一个意向被流传了下来，成为人性中虚伪和自私利己的象征。这种特点源自于日本这个民族对人性深刻的反思，从地缘政治上来说，大和民族千百年来生活在资源匮乏地狭人稠的日本群岛上，战乱的时间远远长于统一和平的时间，因此养成了对资源精打细算和注重细节的心理特质。对比中国，从古到今的文学作品许多都是对祖国的山川河流、作者的思虑抱负等等宏大图景的描绘，而日本的文学作品从《万叶集》到《源氏物语》等等都是描述民情风俗等内容，在乐曲风格上日本也是多用小调编曲，在B站上有很多音乐区的up主尝试将中国的大调乐曲改变成日本小调来演奏，听起来就很有“昭和气息”。</p>
<p>从历史文化渊源来说，日本自“大化改新”开始学习中国唐帝国的礼乐文化，不论是忠、孝、礼、义、廉、耻的任何方面，可以说日本遵循的都要比中国好，可是唯独缺少了“仁”。仁的文化可以说是区别中日文化的核心特质，对于中国人来说我们不论是认可欣赏一个人的忠孝礼义廉耻还是亲自去践行这些道德标准，都会将仁作为一切的前提，君主不仁我们可以不忠，父母不仁我们可以不孝等等，在我们看来是合情合理的，可对日本人来说忠和孝都是无条件的，这也是日本人集体意识如此强的原因。对日本人来说，精神是比物质更加重要的东西，遵循规则几乎成为一种信仰，“宁为玉碎不为瓦全”这句话用来形容日本人的性格再合适不过。这样的特质就使得日本作家在写人的时候能将人物的某种情感或心理特质表达到极致甚至病态，而故事的核心冲突矛盾也是以人物心理的情感变化为基点来爆发的，例如太宰治的《人间失格》和夏目漱石的《心》。这种叙事方式会让初读之人感到一些新奇，因为大多数小说往往会通过突发事件推动人物的行为，人大多数情况是处于被动的，这样的小说多是结合一些时代背景，讲述大时代下小人物的选择；而日本小说中往往不会给人以明显的时代背景，而是着重笔墨去渲染人与人之间的关系，人与自己之间的矛盾。</p>
<p>美国学者曾研究后将日本文化定义为一种“耻感文化”，日本人被等级森严的社会观念束缚，无时无刻不把自己的行为动机设定在社会环境之下，一旦自己逾越自己所遵循的情感、规范和信念就会感到深深的耻感，这种羞耻之心是有很强的约束力的，即我无法背叛我所依赖的、渴求的、深信不疑的东西，因为那样会被世人唾弃。一旦陷入这种逻辑，是非观念就不再重要，是否达到目的和是否从一而终才重要。就像《醉步男》中的血沼，就是典型的为了菟原手儿奈放弃了一切（第一层因果），小竹田同样是出于愧疚接受了手术。</p>
<h2 id="时间与因果"><a href="#时间与因果" class="headerlink" title="时间与因果"></a>时间与因果</h2><p>很难想像有一天如果和血沼一样遇到一个“素不相识”的挚友会是什么样的心情，惊讶，兴奋或是恐惧。我想我可能会感谢他吧。每个人都曾假想过，在某一个人生选择的瞬间，如果自己走向了另一条路，那会是怎样一个不同的人生，幻想中的世界总是美好而虚无缥缈，还不如听他人讲述来的有趣。如果这个人说出了你不知道的事，但也说出了你所知道的事，那么你又会怎么想呢。</p>
<p>《醉步男》这本小说的剧情类似于故事新编，他借用了《菟原处女墓歌》的典故，原诗歌出自《万叶集》，讲述了菟原手儿奈无法在血沼壮士和小竹田丈夫之间做出抉择而选择自杀的故事，表达了女性在古代社会中因为地位低下而无法抉择命运的一种抗争。作者小林泰三在剧情上设置除了时代背景改为当下外基本符合典故中的情节，血沼和小竹田因为都喜欢菟原而发生争执，菟原（可能）因为无法选择而卧轨自杀，之后两人决定通过时间穿越来拯救菟原。乍一听起来似乎这种剧情没什么新意，似乎还有些狗血和老套，但真正让《醉步男》封神的点在于小林泰三对时间旅行与众不同的理解。以时间旅行为题材的科幻影视文学已经不算新鲜，我们比较熟悉的类似《蝴蝶效应》、《回到未来》三部曲等，大多数作品将时间旅行寄予某种机器或是物理法则，而《醉步男》中所表述的观点是——时间旅行是一种大脑的“缺陷”。简而言之，血沼通过研究一些时间知觉认知障碍病人的脑神经图发现他们的共同点，试图通过破坏自己大脑中相关的区域来实现时间穿越。这样的想法让我想到李阳导演的《李献计历险记》中主角患有的差时症，但是两者并不相同，差时症的“临床”表现为在感觉上把一段很短的时间漫长化以及把一段很长的时间变短，并不涉及到时间次序的混乱，而时间知觉认知障碍病人的时间观念是混乱的，他们脑中时间的顺序是混乱的，今天过后可能是昨天，而明天已经过去了。对于一个生在新中国，长在红旗下，学着马克思唯物主义长大的人来说，如果差时症还有可能用某种复杂的科学理论解释的话，第二种病就真的在逻辑上出问题了，一个人怎么可能知道未发生的事情呢（像太阳从东边出来这种不算……）。可是这本书就是这样，你只有先放下自己对时间，意识以及因果这些最普通不过的认知才能去思考其中的逻辑。</p>
<p>血沼认为，从物理层面来说，没有任何理论是限制了时间这个参数的方向性的，那么为什么没有人的意识中时间总是从过去到未来这样线性的呢，这就涉及到自古以来人类对因果律的深刻认同，因果律是人认识世界的基础，即便是一个意识混沌的婴儿，也能体会到按动开关时电灯忽明忽暗的“神奇”。如果人类掌握不了因果，人就无法对如此复杂的大千世界形成认识，整个文明的建立就无从谈起，从古至今一直如此，面对未知和无法解释的事物人天然的感到恐惧，即便是费尽脑细胞编造出宗教也要找到因果，千万年来这种诉求已经深进基因。除了联系这一特点外，因果更重要的一点就是<strong>次序是固定的</strong>，原因一定在结果之前，否则就不能称之为原因，这是无可争议的，仔细想想时间观念不正是依赖因果的产物吗。这本小说真正讨论的与其说是“时间”，不如说是在讨论是否真的有“因果”，关于血沼谈到时间没有方向性的限制这点笔者对物理学的基础理论知之甚少就不做评论了，而至于是否真的有时间认知障碍这种症状，至少从逻辑上这点我是接受的，因为如果因果律和时间概念是刻在人类基因中的，那么也很难保证人的神经系统中没有任何一个区域是主要负责这一方面的应激反应的，这是我们在阅读小说中要接受的第一个假设，或许可以称为“假说”（因为这一点也暂时没有被证伪）——即时间的单一方向性是人脑为了能够认识世界而对自身所做的限制。</p>
<p>下面我们来聊一个时间旅行假说中绕不开的一个话题——“祖母悖论”，目前学界比较有解释力的学说主要分为两种，分别在各种文学作品中都有描述。第一种称为“香蕉皮”假说，其观点为时间旅行过程中我们只能重复已经发生的行为，而无法做出改变未来既有事实的行为，具体表现为我们总会被各种因素干扰而无法改变未来，小到一块香蕉皮；第二种称为“平行时空”假说，其观点为我们在时间旅行的发生时会产生新的时间线，我们在该时间线下所做的任何改变都不会影响原本时间线上的世界。这两种假说都存在一定逻辑上的漏洞，“香蕉皮”假说暂时还无法提出高可信度的观点说明干扰因素的来源，这种阻止改变既有事实的力量总有点宗教的意味，而“平行时空”假说的问题是一旦实现了时间旅行，那么不同时间线下的时间速度就会出现混乱，是否存在旅行期间原本时间线暂停的问题，时间旅行中的人在不同时间线中是单一实体还是存在副本的问题。回到小说中，我觉得作者小林的观点更接近平行时空的观点但是又不能算是在平行时空的基础上做了补充完善，为什么这么说，首先排除香蕉皮假说观点，在小竹田的描述中并不存在时间旅行后无法改变既有事实的情况，那么套用平行时空假说的话又缺少了参考的坐标系，一般讲述平行时空的科幻作品中时间旅行大体上是个人可控的行为，即想要前往的时间点和做出改变后返回的时间点是可以预期的，我们基于这两个点的对比来判断作者想要表达的平行时空观点，但小竹田的时间旅行行为是不可控的，方向不定，时间点不定，另外还加上了波函数的干扰，这就使得这一模型更加复杂。</p>
<h2 id="神奇的“波函数”"><a href="#神奇的“波函数”" class="headerlink" title="神奇的“波函数”"></a>神奇的“波函数”</h2><p>前面提到这本小说并不是纯讨论时间旅行的，更重要的是因果，作为正常生活了很多年的人，很难想象一个没有因果的世界会是什么样子，作者为此引入了“波函数”这一概念，作为一个物理学的门外汉当然是不懂得波函数真正的含义，除了在《生活大爆炸》中看到谢耳朵和莱斯利因为量子力学和弦理论吵得不可开交，以及在B站看过几个科普双缝干涉实验的短片外，我对波函数再无更多的理解，如果依照小说中对这一概念的描述，波函数可以表现为两种状态——发散和坍缩，发散意味着无限可能，坍缩则表现为唯一实现。在我一个外行看来，量子力学中所讨论的观测行为对波函数的影响是难以证伪的，哥本哈根学派的不确定性理论似乎已经脱离了科学的范畴，虽然这样的假说类比现实世界也比较合理，我们身处在一个混沌系统中，系统的复杂程度远远超过了我们能够对其完备掌握和确定预测，但科学的目的就是能够确定和证伪一些事，可是现在量子力学领域的不完备导致了人们产生了迷茫和困惑，于是通过不确定性这种说辞来解释，颇有点诉求宗教的意味。</p>
<p>说回到小说内容，小竹田的解释中人的大脑神经中除了阻止时间跳跃的系统外，还有一部分是用于阻止波函数发散的能力，而血沼是因为某些原因（可能是出于程序操控手术时出现了偏差）还具备着时间的认知和控制能力，所以他自身的主观意识并没有因为时间的错乱而饱受折磨，但是从他自己的经历来看，他似乎是缺失了阻止波函数再次发散的能力。怎么理解这句话，回想前面量子力学中的解释，观测对于实在的影响甚至是决定作用，当我们还没有对一件事情进行观测之前，如果会产生结果A和结果B两种，类比于薛定谔的猫是死是活，我们是无法得知的，这就表现为波函数的发散状态。也许你会反驳，即便没有观测到，我也可以确定明天的太阳会从东边升起，这件事情如果运用哥本哈根学派波恩的概率诠释，可以说即使明天太阳是从东边升起也只是因为太阳从东边升起这个粒子在波函数内坍缩的概率比较大，即使大到了99.99999%，也不能说明这件事是一定的。但这不是重点，即使是一件对半开的可能性的结果，一旦我们进行了观测，那么结果一定是确定了的，相当于波函数坍缩成了粒子，这件事就再也不可能改变，这件事我相信每个人都是有生活经验的，但如果有人说因为外力导致自己对同一件事的观测结果出现了不同（例如昨天还看到的楼今天因为被拆迁所以消失了），那么就要区分一下这一次观测和上一次观测因为时间地点之类的条件不同，已经不能视为同一次观测行为了。但是如果出现血沼这样的情况，他由于缺失了阻止阻止波函数再次发散的能力，那么他对现实生活所做出的种种观测其实是毫无意义的，比如现在看到自己带着手表，过一会发现手表不见了，又过了一会发现自己又戴着手表之类的事情就会层出不穷的出现在他的记忆中，这看起来像是失忆或者记忆错乱的表现，但其实他的时间认知能力是完备的，他能清除把记忆中的时间线串联起来，昨天之后是今天，今天之后是明天，但许多事情因为自己无法阻止波函数再次发散而出现了不同的观察结果。在没有遇到小竹田之前，血沼还可以用一些理由搪塞自己，这些理由相当于将自己的两次观测行为强行解释为因为观测条件出现了不同而产生了不同的结果，例如记得上次和同事来喝酒的小酒馆不见了是因为自己上次喝太醉记错了或者酒馆因为生意不好搬走了；但是，在遇到小竹田之后，听了小竹田的故事，他再也没法骗自己，只能像个鸵鸟一样一头扎进土里，让自己尽最大可能的不听、不看、不想，以此来奢求平静的生活不被不同的观测结果所困扰，每天都走相同的路去上班，做相同的事，完成相同的工作，不在多看外面的世界一眼，如此往复，日日苟且。</p>
<h2 id="手儿奈"><a href="#手儿奈" class="headerlink" title="手儿奈"></a>手儿奈</h2><p>这本书最终让我起一身鸡皮疙瘩的地方在小说末尾血沼问出的关于手儿奈的问题，一般而言，时间旅行系列的小说总有一个明确的目的，主角为了挽回某个错误穿越到过去，最终可能改变了历史，欢喜回到原本时间线，也可能无法改变历史，却改变了心态，结尾回到原本时间线后放下负担，乐观面对新生活。这样的叙事结果虽然经典但也乏善可陈，缺乏新意，有一些比较优秀的叙事结构能够将两条时间线拼接成一个莫比乌斯环，首尾相连，因果循环，例如《环形使者》。但这本小说中从小竹田的叙述来看，两个人时间旅行的初衷是挽救手儿奈的死亡，但最终小竹田却说发生着一切的原因是两个人进行了神经系统的手术，手儿奈的故事只不过是波函数发散的无数种可能之一，这也正好印证了小说想要表达的这种否定因果论的主题。到最后连小竹田自己都开始怀疑，为什么与手儿奈相关的许多经历都很奇怪，例如看到声音，听见颜色，触摸气味等等通感的体会，又或是了解还未发生的事情，这些经历都是小竹田自己在经过手术以后才拥有的感受，小竹田说自己最近才想明白这件事，自己的主管意识由于脱离了客观实在，作为一个幽灵一样观察者飘渺了上千年，加上自己没有对时间的认知和控制能力，生活也是错乱的，可以想象以这样的状态生活，即使不疯不傻，记忆也早已出现混乱，关于手儿奈的经历，有多少是自己的臆想，又有多少是不自觉的进行了美化，就连这件事有没有真实发生过，也无从探究了。所以小竹田才说，救没救活手儿奈，甚至手儿奈是谁，都是没有意义的问题了。</p>
<p>《醉步男》这本小说通读下来也不过半天时间，但它所带给我的思考却持续了很久，虽然披着科幻小说的皮，但本质上讨论了很多哲学上的问题，想来经典硬核的科幻作品大都有这样的特质，如《黑客帝国》就在讨论哲学上经典的“缸中之脑”。小说从始至终都蕴含着浓浓的唯心主义气息，不论是对时间的理解还是因果的考量，我不敢说这样的哲学观点一定是错的，但要去接受也是不太容易，毕竟深受马哲教育多年。其实本书传达的哲学态度是比较消极的，如果我们否定了因果，就等于否定了目的和手段之间的联系，我们便失去了实现目标的方法论，可能就会丧失前进的动力；但是这种观点对于反驳一些所谓的成功学倒是很有帮助，如今每个人都想成功，而又不知道如何成功，只会盲目地复制他人的成功，而已经成功的人靠贩卖自己的成功经验赚得盆满钵满，如果用本书的观点来看，成功人士的行为和他成功这一结果之间，有必然的联系吗？我们生活在这样一个复杂的混沌系统中，量子计算机还没有实现，我们还不知道P＝还是≠NP，因果律究竟存不存在，就去附和他人的成功，不可笑吗。“一千个人的眼中有一千个哈姆雷特”，这本小说带给我的思考可能还会延续很久，相信其他人看过也会有不同的思考吧。</p>
<hr />
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>书评</tag>
        <tag>科幻</tag>
        <tag>小林泰三</tag>
      </tags>
  </entry>
  <entry>
    <title>从FIRST开始的蜕变</title>
    <url>/first.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我的电影启蒙可以追溯到童年时期，那还是音像制品火热的年代，互联网媒体还并不发达，父亲常常去音像店租影碟回来，多是八九十年代的港片，一家人围在电视机前看的不亦乐乎。印象中这样的时光并没有维持多久，慢慢地就被学业的负担淹没了。现在则是我每年假期回到家中，用U盘下载一些精挑细选适合一家人观赏的电影插在电视机上招呼父母过来一起看，试着找找童年的回忆。<br>在成长的过程中，也渐渐听说和了解到一些电影节相关的信息，诸如奥斯卡、金棕榈、金马、威尼斯等等，但总觉得这是离自己很遥远的事情，直到大学加入影协，参与到长春青年电影展和FIRST青年电影节，才第一次意识到，自己离电影节如此之近。社团大佬是FIRST资深影迷，后来还去担任过西宁FIRST影展的志愿者，当时社团在承接吉大FIRST 影展的放映时，我仍然是担任了平面元素的设计工作，相比于之前我们社团自己组织的观影活动，承接影展时主办方会提供一些主题上的设计元素和文案信息，使得我在制作海报，请柬等内容的时候有据可依。从这次设计开始，我有意识的尝试在设计过程中融入自己在学习设计基础知识过程中掌握到的一些原则和方法，加上之前经验的积累以及已有设计元素的依托，整个作品的布局和配色都显得更加成熟和完善，自己的设计风格也开始逐步成型。</p>
<a id="more"></a>

<h2 id="文字版海报"><a href="#文字版海报" class="headerlink" title="文字版海报"></a>文字版海报</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/first1.jpg" alt="文字版海报"></p>
<h2 id="校园网广告"><a href="#校园网广告" class="headerlink" title="校园网广告"></a>校园网广告</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/first2.jpg" alt="校园网广告"></p>
<h2 id="票务（正面）"><a href="#票务（正面）" class="headerlink" title="票务（正面）"></a>票务（正面）</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/first3.jpg" alt="票务（正面）"></p>
<h2 id="票务（反面）"><a href="#票务（反面）" class="headerlink" title="票务（反面）"></a>票务（反面）</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/first4.jpg" alt="票务（反面）"></p>
<h2 id="请柬（面子）"><a href="#请柬（面子）" class="headerlink" title="请柬（面子）"></a>请柬（面子）</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/first5.jpg" alt="请柬（面子）"></p>
<h2 id="请柬（里子）"><a href="#请柬（里子）" class="headerlink" title="请柬（里子）"></a>请柬（里子）</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/first6.jpg" alt="请柬（里子）"></p>
<h2 id="书签（正）"><a href="#书签（正）" class="headerlink" title="书签（正）"></a>书签（正）</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/first7.jpg" alt="书签（正）"></p>
<h2 id="书签（反）"><a href="#书签（反）" class="headerlink" title="书签（反）"></a>书签（反）</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/first8.jpg" alt="书签（反）"></p>
<blockquote>
<p>相关链接</p>
<ol>
<li>知乎回答 <a href="https://www.zhihu.com/question/36467111/answer/101863660" target="_blank" rel="noopener">https://www.zhihu.com/question/36467111/answer/101863660</a></li>
<li>FIRST官网 <a href="http://www.firstfilm.org.cn/render/index" target="_blank" rel="noopener">http://www.firstfilm.org.cn/render/index</a></li>
</ol>
</blockquote>
<hr />
]]></content>
      <categories>
        <category>平面设计</category>
      </categories>
      <tags>
        <tag>海报</tag>
        <tag>电影</tag>
        <tag>影展</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序及堆的应用</title>
    <url>/heapSort.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不同于直接对序列中的数据进行排序的归并排序和快排，堆排序是一种利用数据结构的特性来辅助排序的算法，排序的过程可以分为建堆和减堆两个阶段。除了排序功能外，堆这个结构对于解决一些实时的流数据的调整问题是极为高效的，在操作系统中，处理进程的优先级队列就是堆的一种应用方式。本文重点介绍一下堆排序的算法思想，实现以及堆这种结构在算法中的应用。</p>
<a id="more"></a>

<h2 id="堆结构"><a href="#堆结构" class="headerlink" title="堆结构"></a>堆结构</h2><p>学习堆排序之前我们必须要对堆这种结构有一个清楚地认识，而要认识堆这个结构，我们先要铺垫一些关于二叉树的概念。</p>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>我们都知道，树是一种双分支的层次结构，从根结点开始，每一个结点最多可以有左右两个分支，也可以没有分支，我们将没有子结点的结点称为叶子结点，而一棵二叉树的层数我们也称为深度。下面来理清两个概念：</p>
<ul>
<li>满二叉树：对于一棵二叉树，每一层都满足第i层的结点个数为2<sup>i-1</sup>个时，这棵二叉树为满二叉树；直观来看整个二叉树呈三角形，且每一个结点都是补全的，如图所示：</li>
</ul>
<p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/heapSort1.jpg" alt="heapSort1"></p>
<ul>
<li>完全二叉树：对于一棵二叉树，其深度为i，如果前i-1层满足满二叉树的定义，且第i层的结点排列顺序是由左往右依次补全，这棵二叉树为完全二叉树；直观来看是在满二叉树的基础上由右往左，由下往上的缺失结点（或者说由左往右，由上往下的增添结点），如图所示：</li>
</ul>
<p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/heapSort2.jpg" alt="heapSort2"></p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>实质上，堆的<strong>逻辑结构</strong>就是一颗完全二叉树，只不过完全二叉树只关心整棵树的逻辑结构，不关心结点之间的顺序，而堆这个结构要求的是各个结点所代表的值必须呈现出一定的规律性。具体来说可以分为大根堆和小根堆两种结构，大根堆要求树中每一个结点的值都要小于自己的父结点（如果存在），大于自己的左右子结点（如果存在）；类似的小根堆则要求树中每一个结点的值都要大于自己的父结点（如果存在），小于自己的左右子结点（如果存在），如图所示：</p>
<p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/heapSort3.jpg" alt="heapSort3"></p>
<p>注意，这里我们为什么要强调逻辑结构，之前在讲解对数器的时候我们说四种基本数据类型（集合，线性表，树和图）都属于逻辑结构，即拓扑意义上的表达，这样的结构便于我们对其进行研究和理解，而在实现层面上，我们可以任意地选择线性结构和链式结构来对其实现。具体到堆这个结构，顺序结构的实现我们一般采用数组，链式结构的实现则会才采用二叉树的结点实现方式，虽然理论上这两种结构都可以实现堆，但是堆的特性要求使得我们在建堆的过程中要不断对新加入的结点进行位置调整，以保证堆结构的顺序性，因此采用顺序结构的实现，我们可以很容易的实现结点之间的检索和交换，同时排序算法中给定序列也一般用顺序结构存储，故采用顺序结构可以在排序时之间进行建堆的操作。</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>通过上文中对堆排序的介绍，我们了解到堆这个结构天生就有一定的顺序关系，利用这个特性，当我们将某个序列中的所有元素建成一个堆后，可以直接获取到序列中的最大值或最小值；此时将这个值拿掉之后，剩余的元素重新建堆，则获取到原序列中的次最大值或次最小值……以此类推，直到堆中的元素全部耗尽，我们也就得到了一个有序的序列。</p>
<h3 id="建堆过程"><a href="#建堆过程" class="headerlink" title="建堆过程"></a>建堆过程</h3><p>上面只是将堆排序的思路从逻辑结构的角度大致描述了一下，但是涉及到具体数据结构的算法，因为代码的实现需要利用物理结构相应的优势和特性，逻辑层面的设想和物理层面的实现之间还要进行一系列相应的转换。具体到堆排序这个过程中，我们首先要考虑如何用顺序结构来模拟一个堆和堆的各种操作。</p>
<ul>
<li>数组模拟堆：由于完全二叉树的结构特点，我们可以采用层序遍历的顺序对结点进行编号，同时对应数组的下标位置，如图所示：</li>
</ul>
<p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/heapSort4.jpg" alt="heapSort4"></p>
<p>在介绍堆结构时我们提到过，用顺序结构来实现堆可以很容易的实现结点之间的检索，这里我们就可以体会到，对于任意一个结点来说，他的父结点和左右孩子结点都可以通过简单地数组下标变换得到，总结后的规律如下：</p>
<p>若堆中结点x在数组中存放于i位置，如果存在父结点或左右孩子结点（数组中的判定条件为下标不越界），则有：</p>
<blockquote>
<p>其父结点的数组下标：<strong>(i - 1) / 2</strong></p>
<p>其左孩子的数组下标：<strong>2 * i + 1</strong></p>
<p>其右孩子的数组下标：<strong>2 * i + 2</strong></p>
</blockquote>
<ul>
<li>模拟建堆过程</li>
</ul>
<p>堆的建立过程是一个逐步插入新元素同时逐步调整堆结构的过程，初始时堆内为空，每插入一个元素，就要对堆的整体结构进行调整。一般新插入的元素位于堆的最后一个位置（依完全二叉树的层序遍历顺序），调整的过程是该元素和父结点不断交换，逐渐上浮合理的位置，保证堆的“有序”。我们以大根堆为例，建堆的过程如图所示：</p>
<p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/heapSort5.jpg" alt="heapSort5"></p>
<p>图中展示了序列【15,3,10,7,5,16,11,12】这个序列建堆的过程，绿色元素表示需要新插入堆中的元素，橙色双箭头的线代表元素之间存在交换关系，蓝色元素表示新插入的元素在调整堆结构后确定的位置。下面我们通过物理结构再来模拟一遍这个过程，如图所示：</p>
<p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/heapSort6.jpg" alt="heapSort6"></p>
<p>与上一张图所表示的含义相同，绿色部分为新插入堆中的元素，蓝色部分为堆结构调整后的元素，不同的是这张图用实线和虚线区别开了元素比较和交换的过程，虚线表示元素之间的比较，实现表示元素之间的交换。我们看到基本上每插入一个新的元素，都要与其父结点的元素进行比较（根结点除外），根据的是上文中我们总结到的顺序结构下堆中具有父子关系的元素下标之间的规律，通过简单地下标变换我们就能知道新插入的元素是否需要上移；而只有当元素需要上移时，才进行父子结点的元素交换，依然可以通过下表变换实现。</p>
<p>注意，图中由于区域有限，将比较和交换的过程进行了统一的标注，并非表示比较和交换是分割的两个阶段，在实际的代码逻辑中比较和交换是交替进行的，一次比较之后进行一次交换，之后再次比较，直到交换到合适的位置。</p>
<p>下面我们来构建建堆的代码，这里仍旧以大根堆为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 建立大根堆，将新加入的结点逐步向上调整，形成大根堆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 兼顾根结点和自身的比较</span></span><br><span class="line">	<span class="keyword">while</span> (arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">		swap(arr, index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">		index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到，建立大根堆的代码非常简洁，通过外部循环传入要插入的新元素的数组下标，与现有的大根堆进行调整合并，由于比较和交换的逻辑是一旦子结点的元素值大于父结点就需要交换，否则说明当前位置就是新插入的元素合理的位置。heapInsert直接通过一个while循环，同时兼顾了这两方面的逻辑，如果新插入的元素值大于父结点的元素，则两个结点交换，新元素再次和新的父结点作比较，一旦到新元素的值小于父结点，该方法直接返回。</p>
<p>有同学可能会担心数组的下标是否有可能越界，其实是不会的，因为代码逻辑对数组的下标只会减小不会增大，所以当新元素交换到根结点时，他会经历一次自己和自己比较的过程，由于自己不会大于自己所以也会循环结束跳出方法。</p>
<h3 id="减堆过程"><a href="#减堆过程" class="headerlink" title="减堆过程"></a>减堆过程</h3><p>现在整个包含所有元素的大根堆已经建好，堆顶元素即为该序列的最大值，我们下一步的任务就是把最大值从堆中排除出去，重新调整堆找出次最大值，逐渐把这个堆减小，最终获得整个有序序列。这个过程我们首先要考虑的问题是，这个排除出堆的最大值，我们应该如何处理，如何保存，是否需要额外的辅助空间？其实是不用的，这就又要说道顺序结构来实现堆这一逻辑结构的优势，正如我们在建堆的过程中，也并没有申请额外的辅助空间来保存这个新建好的堆，因为序列中的元素是一定的，不论是在建堆还是减堆的过程中，任何一个序列中的元素要么在堆中，要么在堆外（可以认为在原数组中），即我们可以将整个数组看做堆部分与非堆部分，只要这两个部分相互隔离（用指针区分），就不用申请多的辅助空间，因此我们可以将建好的堆的最大元素与堆中末尾的元素交换位置，同时将堆的大小减一，就可以解决这个问题。</p>
<p>至于为什么一定要选择最后一个位置来做交换呢，两个原因。第一，正如上面所说的，我们需要让堆部分和非堆部分分隔开，那么只有把元素往两边放，不能跨元素产生交叉；那为什么不直接将最大值留在原地，堆的范围向后缩减呢？这就是第二个原因导致的，我们在建堆的过程中已经形成的大根堆通过元素的下标变化可以得到他的父子结点，而他们之间的次序关系已经是调整好了的，如果我们这时去掉队尾的元素，其实对整个堆的结构不会产生任何影响，反而一旦我们损失了堆头的位置，整个堆的结构就无法再利用，需要重新排列（建堆），生成新的堆顶，这样会产生很多额外的时间成本，得不偿失。综上，我们选择堆尾元素作为与堆顶最大值交换的元素，这样队尾元素就成了新的堆顶元素。</p>
<p>如此一来虽然堆的大小减一，但是整个堆的结构性被破坏了，需要重新调整堆顶元素的位置，这也是减堆过程中最关键的步骤。不用于建堆过程中元素从下往上移动，减堆时队尾元素本来应该位于堆的最底层，下载要从堆顶位置向下移动和合适的位置。</p>
<p>还是通过上面举的例子，下面我们通过第一次换元素并重新调整堆的过程来看一下减堆时应当如何对堆进行调整，如图所示：</p>
<p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/heapSort7.jpg" alt="heapSort7"></p>
<p>为了便于对比，我们直接将逻辑结构的减堆过程和物理结构的减堆过程画在同一张图中，我们看到，初始状态下整个堆结构有序，指针也指向数组的最后一个位置，当交换堆顶和堆尾元素后，指针前移，指针以后的数组部分“变黑”，表示之后的部分已经不在堆结构之中。接下来，交换到堆顶的元素开始和他的左右孩子结点的值两两比较，同时当该元素的值小于孩子结点的元素时与孩子结点中较大值交换，直到该元素的值大于任何一个孩子结点或者该元素下移至叶子结点（图中结点3的情况）。</p>
<p>下面我们配合代码再加深一步理解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 已形成的大根堆在某个结点发生变化后如何进行调整，调整结点逐步下沉</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> current</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index	要调整的堆的范围</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> current,<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>((current *<span class="number">2</span> + <span class="number">1</span>)&lt;index) &#123;</span><br><span class="line">		<span class="keyword">int</span> leftChild = current *<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> rightChild = current *<span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> large = rightChild&lt;index&amp;&amp;arr[rightChild]&gt;arr[leftChild]?rightChild:leftChild;</span><br><span class="line">		large = arr[current]&lt;arr[large]?large:current;</span><br><span class="line">		<span class="comment">//当前数比左右孩子都大，不用再进行交换</span></span><br><span class="line">		<span class="keyword">if</span>(current == large)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		swap(arr, current, large);</span><br><span class="line">		current = large;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，代码相比之前分析的逻辑更进一步进行了封装，使得该方法的适用范围更广，功能更强大。我们的减堆逻辑是将最后堆顶元素和堆尾元素进行交换，之后从堆顶开始重新调整堆结构，而这其中其实隐含着一个更普遍的功能需求，即在一个堆中，从某一个结点开始，其下的堆结构需要重新排序，也就是说这个结点不一定是根结点，也有可能是堆中的任何一个结点。current变量就是用来指明需要从哪个结点开始从上到下重新调整堆，index变量限制了堆的大小，将堆内元素和堆外元素做了分隔。</p>
<div class="note info"><p>注意：代码中的index边界返回与我们图中的index所指向的位置有所出入，代码为了书写简洁将index的位置向后移动了一位，大家理解时要注意这一点。</p></div>

<p>下面我们来看一下代码的内部逻辑，与建堆过程中结点向上移动的逻辑不同，向下移动时涉及到结点选择的问题，毕竟二叉树结构中父结点只有一个，子结点可能有多个；并且，结点的向下移动意味着在迭代的过程中索引值会不断变大，我们要注意数组下标的越界问题。</p>
<p>整个函数的逻辑嵌套在一个循环中，循环的条件是新的堆顶元素在下移的过程中是否移动到了叶结点处，一点该元素移动到了叶子结点处，即该元素没有下移空间了，直接跳出循环；循环内部使用了两个三目表达式用于求出当前元素以及其左右孩子结点的值之间的最大值，同时兼顾了对下标越界的判断，将最大值的下标保存在large变量中。这时，判断large和current是否相等，即判断当前值是否就是三者中的最大值，如果是则不需要再下移，直接break跳出循环；否则，交换当前元素和large所指向的元素，current指针更新，进行下一次的迭代。</p>
<p>现在，学习完了堆排序的两个阶段，我们再来将建堆和减堆的堆调整函数放入整个堆排序的流程中，体会一下整个过程，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr==<span class="keyword">null</span>||arr.length&lt;<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//建堆过程</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">		heapInsert(arr, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//减堆过程</span></span><br><span class="line">	<span class="keyword">int</span> heapSize = arr.length;</span><br><span class="line">	<span class="keyword">while</span>(heapSize--&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		swap(arr, <span class="number">0</span>, heapSize);</span><br><span class="line">		heapify(arr, <span class="number">0</span>, heapSize);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外部函数的代码逻辑基本上和逻辑层面的堆排序过程如出一辙，首先进行建堆，建堆的过程是逐个将数组中的元素插入到堆中，插入的同时进行堆结构调整（这一过程封装在heapInsert函数中）；建堆完成后开始减堆，随着堆范围一步步向内缩减，堆顶的元素被交换出堆外，再对新交换到堆顶的元素进行调整（这一过程封装在heapify函数中），直到堆内元素耗尽。</p>
<h3 id="算法剖析"><a href="#算法剖析" class="headerlink" title="算法剖析"></a>算法剖析</h3><p>前面我们说到，堆排序虽然借助了额外的数据结构来辅助我们进行排序，但是这只是逻辑上的应用，物理结构上我们不论是建堆还是减堆的过程，自始至终使用的都是原始的给定数组，并没有申请额外的辅助空间，因此堆排序的空间复杂度是O(1)的。而时间复杂度我们可以将两个阶段分开来看，因为建堆和减堆的过程完全是串行执行的，因此总的时间复杂度应该是建堆时间加上减堆时间。</p>
<p>注意，除了上文中所介绍的<strong>自顶向下</strong>（maxHeapInsert）的建堆方式以外，其实还有一种<strong>自底向上</strong>（buildMaxHeap）的建堆方法，所谓的自底向上指的是我们在建堆之前已知所有要插入的元素及其顺序的情况下，先将其构建成一棵完全二叉树，接着按照层序遍历的逆序方式，从第一个非叶子结点开始，依次对每个结点执行一个heapify的过程，即对完全二叉树中的每一棵子树逐渐调整建堆，最终建出整个堆来，这个过程和自顶向下的建堆顺序正好相反，先处理下层节点的位置和下层子树的堆结构，逐渐向上形成最终整个堆结构的有序。</p>
<p>下面我们来比较一下这两种建堆方式的时间复杂度，看看这两种建堆方式在时间上谁更快一些。我们先来对整个堆上的基准数据做一假设和定义，假设整个堆是一棵满二叉树，叶子结点为第0层，由下往上依次递进，总结点个数为N，则有堆的深度为log<sub>2</sub>N，建堆过程中结点的比较和交换只与其所在的层数有关，和整个堆的结点个数无关，因此同一层的结点所要比较和交换的次数相同，堆的层数，每一层的节点数以及两种建堆方式每一层需要比较和移动的次数的对应关系如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">层数</th>
<th align="center">结点个数</th>
<th align="center">自顶向下移动次数</th>
<th align="center">自底向上移动次数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">(N+1)/2</td>
<td align="center">log<sub>2</sub>N</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">(N+1)/4</td>
<td align="center">log<sub>2</sub>N-1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">(N+1)/8</td>
<td align="center">log<sub>2</sub>N-2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">……</td>
<td align="center">……</td>
<td align="center">……</td>
<td align="center">……</td>
</tr>
<tr>
<td align="center">k</td>
<td align="center">N+1/2<sup>k+1</sup></td>
<td align="center">log<sub>2</sub>N-k</td>
<td align="center">k</td>
</tr>
<tr>
<td align="center">……</td>
<td align="center">……</td>
<td align="center">……</td>
<td align="center">……</td>
</tr>
<tr>
<td align="center">log<sub>2</sub>N-1</td>
<td align="center">(N+1)/2<sup>log<sub>2</sub>N</sup></td>
<td align="center">1</td>
<td align="center">log<sub>2</sub>N-1</td>
</tr>
<tr>
<td align="center">log<sub>2</sub>N</td>
<td align="center">(N+1)/2<sup>log<sub>2</sub>N+1</sup></td>
<td align="center">0</td>
<td align="center">log<sub>2</sub>N</td>
</tr>
</tbody></table>
<div class="note warning"><p>注意，以下我们所提到的结点之间的比较和交换只按单次计算，一般以第一次加入堆结构时的调整次数为准，之后因为其他结点的调整所产生的被动比较和交换不计入时间复杂度中。</p></div>

<ul>
<li>自顶向下</li>
</ul>
<p>自顶向下的建堆方式，结点的比较和交换是一个从下到上的过程，越靠下层的结点越晚加入到堆结构中，所需要进行移动的次数也更多。堆顶元素自然成堆，无须比较和交换，堆顶的下一层结点最多需要比较和交换一次，即可到达堆顶位置……以此类推，最后一次叶子结点需要比较和交换总的深度减一次。一次建堆过程总的比较次数累加表达式如下图所示：</p>
<p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/heapSort8.jpg" alt="heapSort8"></p>
<p>推导结果中当N趋于无穷大时，常数项无意义，1/2N趋于0，最终结果化简为Nlog<sub>2</sub>N，因此自顶向下的建堆方式时间复杂度为<strong>O(Nlog(N))</strong>。</p>
<ul>
<li>自底向上</li>
</ul>
<p>自底向上的建堆方式，结点的比较和交换是一个从上到下的过程，越靠下层的结点越早加入到堆结构中，所需要进行移动的次数也越少。叶子结点不需要进行下移直接有序，叶子结点的上一层结点最多需要比较和交换一次，即可到达堆底位置……以此类推，最后一次堆顶结点需要比较和交换总的深度减一次。一次建堆过程总的比较次数累加表达式如下图所示：</p>
<p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/heapSort9.jpg" alt="heapSort9"></p>
<p>推导结果中当N趋于无穷大时，常数项无意义，1/2N趋于0，指数函数和一次函数的比值可用洛必达公式化简得结果任然趋于0（显然指数函数是比一次函数更高阶的无穷小），最终结果化简为N，因此自底向上的建堆方式时间复杂度为<strong>O(N)</strong>。</p>
<blockquote>
<p>这篇<a href="https://www.cnblogs.com/shytong/p/5364470.html" target="_blank" rel="noopener" title="博客">博客</a>对两种建堆的方式进行了更深入比较和数学证明，有兴趣的同学可以阅读一下。</p>
</blockquote>
<p>虽然我们最终得出的结论是自底向上的建堆方式在时间性能上更优，但是前提是我们需要在建堆之前就得到所有的结点信息和减堆次序，对数据状况的要求更为苛刻，适用度不如自顶向下的方式更加通用，并且我们提到堆结构的优势正是在于处理实时的流数据，因此对于一般情况我们还是采取自顶向下的建堆方式，用一一点的时间成本获得更大的功能扩展。</p>
<p>至于建堆的时间复杂度，我们可以参考自底向上的建堆过程，因为这一过程使用的方式也是减堆过程中大量使用的heapify操作。与建堆过程不同的是，减堆时所执行的heapify操作都是对整个堆的堆顶元素执行的，而每一次操作堆顶元素都要执行整个堆的深度的比较和交换，因此时间复杂度为O(log(N))，直到堆中所有元素全部出堆，整个过程的时间复杂度为O(Nlog(N))。综上，不论建堆的时间复杂度如何，减堆的过程直接限制了堆排序的时间复杂度维持在O(Nlog(N))的层级上，无法再降低。</p>
<h2 id="堆的应用"><a href="#堆的应用" class="headerlink" title="堆的应用"></a>堆的应用</h2><p>由于堆这个结构利用了完全二叉树这一数据分布非常平均的结构，因此任何时候对堆中的元素进行调整的代价只会和堆的深度有关，而不会和整个数量级相关，而O(log(N))的代价无疑是非常低的，对于一个四十多亿的数据量O(log(N))的代价也仅仅是32次。不仅如此，堆结构对整个序列中最值的检索操作是O(1)的，这就为我们设计许多实时处理信息检索的数据结构提供了便利，下面我们来看一个案例。</p>
<h3 id="求中位数"><a href="#求中位数" class="headerlink" title="求中位数"></a>求中位数</h3><ul>
<li>题目：设计一个结构，实现将一个数据流中不断产生的整数保存起来，并且在任意时刻给出当前序列的中位数</li>
<li>要求：求中位数的时间复杂度为O(1)</li>
<li>分析：<ul>
<li>对于一个有序序列，我们很容易通过中间位置的索引值得到中位数，时间复杂度为O(1)，但是面对一个无序的序列，我们想用通过次序关系获取中位数，就不得不先承担一个排序的时间复杂度，而我们已知的排序算法中，最短也需要O(Nlog(N))的时间，但是本题处理的是一个流式数据，就是说我们如果要通过以上方式获取中位数，那么只需要从最开始建立序列的时候保持每次获得数时序列的有序性，即我们每获得一个数就通过插入的方式将新获得的数插入到原有序列的适当位置，继续保持序列的有序性，这样只需要花费O(N)的时间复杂度，我们就可以任何时刻以O(1)的时间获取整个序列中位数。</li>
<li>但是我们考虑对于题目求中位数的要求，我们只需要知道整个序列较大的一半数（以及其中的最小值）和较小的一半数（以及其中的最大值）即可，两个部分其中的次序关系对于求整个序列的中位数其实没有帮助，但是为了得到有序序列我们还是付出了额外的时间复杂度。有没有方式能够保存一个流式数据的最值呢，很自然的我们想到堆结构，利用堆结构对处理流数据的低时间成本我们还能有效降低保持局部有序性的时间复杂度。</li>
</ul>
</li>
<li>思路：正如上面的分析，我们可以创建两个堆，分别保存流序列中较大的一半值和较小的一半值，储存较大值的为小根堆，储存较小值的为大根堆，这样就能分别保存位于中间位置的两个值，在获取数的时候我们通过一定的逻辑选择数进哪个堆，而当堆之间出现失衡时（元素数量差大于1），两个堆之间出堆入堆在调整堆结构，这些操作都可以在O(log(N))的时间内完成。</li>
</ul>
<p>详细的控制逻辑我们用程序的流程图来表示：</p>
<ul>
<li>元素进入结构流程图：</li>
</ul>
<p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/heapSort10.jpg" alt="heapSort10"></p>
<ul>
<li>获取中位数流程图：</li>
</ul>
<p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/heapSort11.jpg" alt="heapSort11"></p>
<p>通过利用堆结构进行这样一个巧妙的设计，我们成功将建立元素有序性的时间成本由O(N)降到了O(log(N))，获取中位数的操作依然能维持在O(1)，这就是对这个结构带给我们的好处。</p>
<hr />
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>日语日常用语</title>
    <url>/japanese1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>包含日常问候后语和教室问候语</p>
<a id="more"></a>

<h1 id="日常表达用语"><a href="#日常表达用语" class="headerlink" title="日常表达用语"></a>日常表达用语</h1><hr>
<h2 id="注意，日语中和用以区分时态，ました针对过去发生的行为，ます针对现在或将来要发生的行为"><a href="#注意，日语中和用以区分时态，ました针对过去发生的行为，ます针对现在或将来要发生的行为" class="headerlink" title="注意，日语中和用以区分时态，ました针对过去发生的行为，ます针对现在或将来要发生的行为"></a>注意，日语中和用以区分时态，<code>ました</code>针对过去发生的行为，<code>ます</code>针对现在或将来要发生的行为</h2><ol>
<li>おはようございます。／おはよう。<blockquote>
<p>早上好。（用于早上11点以前或一天中第一次见面问候，常用）</p>
</blockquote>
</li>
<li>こんにちは。<blockquote>
<p>你好。（通常用于上午以后）</p>
</blockquote>
</li>
<li>こんばんは。<blockquote>
<p>晚上好。</p>
</blockquote>
</li>
<li>おやすみなさい。<blockquote>
<p>晚安。</p>
</blockquote>
</li>
<li>さようなら。／ではまた。／じゃまた。／じゃねえ。<blockquote>
<p>再见。（语气逐渐缓和，部分地区さようなら用于较为郑重的道别或恋人分手）</p>
</blockquote>
</li>
<li>すみません。<blockquote>
<p>抱歉打扰。（类似于excuse me）</p>
</blockquote>
</li>
<li>ごめんなさい。／ごめん。<blockquote>
<p>对不起。（语气逐渐缓和）</p>
</blockquote>
</li>
<li>ありがとうございます。／ありがとう。<blockquote>
<p>谢谢。（语气逐渐缓和）</p>
</blockquote>
</li>
<li>いいえ、どういたしまして。<blockquote>
<p>不用谢。</p>
</blockquote>
</li>
<li>失礼(しつれい)します。／失礼しました。<blockquote>
<p>失礼了，对不起了，我要进来了，我要走了（对将要进行的实力行为致歉）；失礼了。（对已经发生的失礼事情表示致歉）</p>
</blockquote>
</li>
<li>お世話(せわ)になります。／お世話になっておりました。<blockquote>
<p>麻烦您，给您添麻烦了。</p>
</blockquote>
</li>
<li>お邪魔します。／お邪魔しました。<blockquote>
<p>打扰您了。（特指要去拜访他人或已经拜访过他人）</p>
</blockquote>
</li>
<li>お疲(つか)れ様(さま)です。／お疲れ様でした。／お疲れ様。<blockquote>
<p>辛苦了。</p>
</blockquote>
</li>
<li>ご苦労(くろう)様。／ご苦労さん。<blockquote>
<p>辛苦了（一般是上级对下属使用）。</p>
</blockquote>
</li>
</ol>
<h1 id="教师及课堂用语"><a href="#教师及课堂用语" class="headerlink" title="教师及课堂用语"></a>教师及课堂用语</h1><ul>
<li>おかりましたか。<ul>
<li>明白了吗？听懂了吗？</li>
</ul>
</li>
<li>はい、おかりました。<ul>
<li>明白了，听懂了。</li>
</ul>
</li>
<li>いいえ、わかりません。<ul>
<li>没有，还不明白。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>いいですが。<ul>
<li>对吗？正确吗？准备好了吗？可以了吗？</li>
</ul>
</li>
<li>いいです。<ul>
<li>对，正确。</li>
</ul>
</li>
<li>残念(ざんねん)ですね。<ul>
<li>很遗憾（不正确）。</li>
</ul>
</li>
<li>違(ちが)います。<ul>
<li>不对，不是这样的。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>みなさん、いいですが。<ul>
<li>大家准备好了吗？</li>
</ul>
</li>
<li>はい(、いいです)。<ul>
<li>好了。</li>
</ul>
</li>
<li>いいえ(、まだです)。<ul>
<li>还没有。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>聞(き)き取(と)れましたが。<ul>
<li>听懂了吗？</li>
</ul>
</li>
<li>はい</li>
<li>いいえ</li>
</ul>
<hr>
<ul>
<li>読(よ)んでください。<ul>
<li>请读一下。</li>
</ul>
</li>
<li>一緒(いっしょ)に　読んでください。<ul>
<li>请一起读。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>よく聞いでください。<ul>
<li>请好好听。</li>
</ul>
</li>
<li>見(み)でください。<ul>
<li>请看。</li>
</ul>
</li>
<li>言(い)ってください。<ul>
<li>请说一下。</li>
</ul>
</li>
<li>訳(やく)してください。<ul>
<li>请翻译一下。</li>
</ul>
</li>
<li>～ページを見てください。<ul>
<li>请看~页。</li>
</ul>
</li>
<li>次(つぎ)の人(ひと)はどうぞ。<ul>
<li>下一位请。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>これは何(なん)と読みますが。<ul>
<li>这个读作什么？</li>
</ul>
</li>
<li>これはどう言いますが。<ul>
<li>这个怎么说？</li>
</ul>
</li>
<li>これはどういう意味(いみ)ですが。／これは何という意味ですが。<ul>
<li>这是什么意思？</li>
</ul>
</li>
<li>もう一度(いちど)。<ul>
<li>再来一次</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>日本語</category>
      </categories>
      <tags>
        <tag>外语</tag>
      </tags>
  </entry>
  <entry>
    <title>日语数字表达</title>
    <url>/japanese2.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>日语中数字的读法和写法和汉语很相似，不存在不同位数的变形，但要注意部分（3的倍数）数字在百位以上的读音和写法。</p>
<a id="more"></a>

<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">れい／ぜろ</td>
<td align="center">いち</td>
<td align="center">に</td>
<td align="center">さん</td>
<td align="center">し／よ／よん</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">6</td>
<td align="center">7</td>
<td align="center">8</td>
<td align="center">9</td>
</tr>
<tr>
<td align="center">ご</td>
<td align="center">ろく</td>
<td align="center">しち／なな</td>
<td align="center">はち</td>
<td align="center">く／きゅう</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">11</td>
<td align="center">12</td>
<td align="center">13</td>
<td align="center">14</td>
</tr>
<tr>
<td align="center">じゅう</td>
<td align="center">じゅういち</td>
<td align="center">じゅうに</td>
<td align="center">じゅうさん</td>
<td align="center">じゅうよん</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">16</td>
<td align="center">17</td>
<td align="center">18</td>
<td align="center">19</td>
</tr>
<tr>
<td align="center">じゅうご</td>
<td align="center">じゅうろく</td>
<td align="center">じゅうなな</td>
<td align="center">じゅうはち</td>
<td align="center">じゅうきょう／じゅうく</td>
</tr>
<tr>
<td align="center">20</td>
<td align="center">30</td>
<td align="center">40</td>
<td align="center">50</td>
<td align="center">60</td>
</tr>
<tr>
<td align="center">にじゅう</td>
<td align="center">さんじゅう</td>
<td align="center">よんじゅう</td>
<td align="center">ごじゅう</td>
<td align="center">ろくじゅう</td>
</tr>
<tr>
<td align="center">70</td>
<td align="center">80</td>
<td align="center">90</td>
<td align="center">100</td>
<td align="center">200</td>
</tr>
<tr>
<td align="center">ななじゅう</td>
<td align="center">はちじゅう</td>
<td align="center">きょうじゅう</td>
<td align="center">ひゃく</td>
<td align="center">にひゃく</td>
</tr>
<tr>
<td align="center">300</td>
<td align="center">400</td>
<td align="center">500</td>
<td align="center">600</td>
<td align="center">700</td>
</tr>
<tr>
<td align="center"><strong>さんびゃく</strong></td>
<td align="center">よんひゃく</td>
<td align="center">ごひゃく</td>
<td align="center"><strong>ろっぴゃく</strong></td>
<td align="center">ななひゃく</td>
</tr>
<tr>
<td align="center">800</td>
<td align="center">900</td>
<td align="center">1000</td>
<td align="center">2000</td>
<td align="center">3000</td>
</tr>
<tr>
<td align="center"><strong>はっぴゃく</strong></td>
<td align="center">きょうひゃく</td>
<td align="center">せん</td>
<td align="center">にせん</td>
<td align="center"><strong>さんぜん</strong></td>
</tr>
<tr>
<td align="center">4000</td>
<td align="center">5000</td>
<td align="center">6000</td>
<td align="center">7000</td>
<td align="center">8000</td>
</tr>
<tr>
<td align="center">よんせん</td>
<td align="center">ごせん</td>
<td align="center">ろくせん</td>
<td align="center">ななせん</td>
<td align="center"><strong>はっせん</strong></td>
</tr>
<tr>
<td align="center">9000</td>
<td align="center">10,000</td>
<td align="center">100,000</td>
<td align="center">1,000,000</td>
<td align="center">10,000,000</td>
</tr>
<tr>
<td align="center">きゅうせん</td>
<td align="center"><strong>いちまん</strong></td>
<td align="center">じゅうまん</td>
<td align="center"><strong>ひゃくまん</strong></td>
<td align="center"><strong>いっせんまん</strong></td>
</tr>
<tr>
<td align="center">100,000,000</td>
<td align="center">o.1</td>
<td align="center">2/3</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>いちおく</strong>(一億)</td>
<td align="center"><strong>れいてんいち</strong></td>
<td align="center"><strong>さんぶのに</strong></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<div class="note info"><p>注意加粗字体的不规律读法和写法。</p></div>

<hr />
]]></content>
      <categories>
        <category>日本語</category>
      </categories>
      <tags>
        <tag>外语</tag>
      </tags>
  </entry>
  <entry>
    <title>韩国电影专题</title>
    <url>/korea.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这一期的设计是韩国电影专题月的时候制作的海报，相比上一次发的几张并没有很大的进步，甚至时间太久我也想不起哪一组的制作时间更加靠前。这一阶段的自已很明显的暴露出因为缺乏设计理念和技巧上的知识，能够分辨什么是好的设计，但是面对自己需要表达的主题和内容，不知道该使用怎样的元素，进行怎样的布局和安排，只会一股脑的居中再居中……而自己也渐渐意识到了这些问题，于是开始看一些入门级别的设计书，这里推荐给大家。</p>
<ul>
<li>写给大家看的设计书（第3版）</li>
</ul>
<blockquote>
<p>作者:  [美] Robin Williams<br>出版社: 人民邮电出版社<br>丛书: 图灵交互设计丛书<br>ISBN: 9787115188120</p>
</blockquote>
<ul>
<li>版式设计原理</li>
</ul>
<blockquote>
<p>作者:  [日] 佐佐木刚士<br>出版社: 中国青年出版社<br>丛书: 版式设计丛书<br>ISBN: 9787500677390</p>
</blockquote>
<ul>
<li>配色设计原理</li>
</ul>
<blockquote>
<p>作者:  奥博斯科<br>出版社: 中国青年出版社<br>ISBN: 9787500690351</p>
</blockquote>
<a id="more"></a>

<h2 id="排片表"><a href="#排片表" class="headerlink" title="排片表"></a>排片表</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/korea1.jpg" alt="排片表"></p>
<h2 id="马粥街残酷史"><a href="#马粥街残酷史" class="headerlink" title="马粥街残酷史"></a>马粥街残酷史</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/korea2.jpg" alt="马粥街残酷史"></p>
<h2 id="蔷花红莲"><a href="#蔷花红莲" class="headerlink" title="蔷花红莲"></a>蔷花红莲</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/korea3.jpg" alt="蔷花红莲"></p>
<h2 id="我要复仇"><a href="#我要复仇" class="headerlink" title="我要复仇"></a>我要复仇</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/korea4.jpg" alt="我要复仇"></p>
<hr />
]]></content>
      <categories>
        <category>平面设计</category>
      </categories>
      <tags>
        <tag>海报</tag>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown学习笔记</title>
    <url>/markdown-learning.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>markdown可以理解为一种解释型的编程语言（类似于Python），在转换的时候根据不同的标签转换为HTML语句，从而实践不同的排版效果。</p>
<a id="more"></a>

<h2 id="1-区块元素"><a href="#1-区块元素" class="headerlink" title="1.区块元素"></a>1.区块元素</h2><p>###段落</p>
<p>markdown的段落由一个或多个连续的文本行组成，每个文本行前后要有一个以上的空行,且可以对段落中的文字进行<strong>加粗</strong>、<em>斜体</em>、<u>加下划线</u>或<del>删除字样</del>的处理。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">markdown的段落由一个或多个连续的文本行组成</span><br><span class="line">每个文本行前后要有一个以上的空行</span><br><span class="line">且可以对段落中的文字进行**加粗**、*斜体*、<span class="tag">&lt;<span class="name">u</span>&gt;</span>加下划线<span class="tag">&lt;/<span class="name">u</span>&gt;</span>或~~删除字样~~的处理。</span><br><span class="line">注意：加粗可以选中文字后使用快捷键Ctrl+B，斜体可以选中文字后使用快捷键Ctrl+I。</span><br></pre></td></tr></table></figure>

<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">以此类推，最多支持六级标题，注意#后要有空格且行首不能有空格，否则无法渲染。</span><br></pre></td></tr></table></figure>
<h3 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h3><blockquote>
<p>这里是区块引用的内容</p>
<blockquote>
<p>区块引用也可以采取嵌套形式</p>
</blockquote>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;这里是区块引用的内容</span><br><span class="line"><span class="meta">&gt;&gt;</span>区块引用也可以采取嵌套形式</span><br></pre></td></tr></table></figure>

<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul>
<li>无序列表项</li>
<li>无序列表项</li>
<li>无序列表项</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>无序列表项</span><br><span class="line"><span class="bullet">* </span>无序列表项</span><br><span class="line"><span class="bullet">* </span>无序列表项</span><br><span class="line">此处<span class="strong">*可以替换为+或-，注意符号与内容之间要有空格</span></span><br></pre></td></tr></table></figure>

<ol>
<li>有序列表项</li>
<li>有序列表项</li>
<li>有序列表项</li>
</ol>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 有序列表项</span><br><span class="line"><span class="number">2.</span> 有序列表项</span><br><span class="line"><span class="number">3.</span> 有序列表项</span><br><span class="line">此处第二项以及以后的开头数字和.可以用-替代，同样注意符号与内容之间的空格</span><br></pre></td></tr></table></figure>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><table>
<thead>
<tr>
<th>表头1</th>
<th align="right">表头2</th>
<th align="center">表头3</th>
</tr>
</thead>
<tbody><tr>
<td>条目1内容1aaaaaa</td>
<td align="right">条目1内容2</td>
<td align="center">条目1内容3</td>
</tr>
<tr>
<td>条目2内容1</td>
<td align="right">条目2内容2bbbbbb</td>
<td align="center">条目2内容3</td>
</tr>
<tr>
<td>条目3内容1</td>
<td align="right">条目3内容2</td>
<td align="center">条目3内容3cccccc</td>
</tr>
</tbody></table>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">默认每列元素左对齐，通过：设置对齐方式</span><br><span class="line">| 表头<span class="number">1</span> | 表头<span class="number">2</span> | 表头<span class="number">3</span> |</span><br><span class="line">| --- | ---: | :---: |</span><br><span class="line">| 条目<span class="number">1</span>内容<span class="number">1</span>aaaaaa | 条目<span class="number">1</span>内容<span class="number">2</span> | 条目<span class="number">1</span>内容<span class="number">3</span> |</span><br><span class="line">| 条目<span class="number">2</span>内容<span class="number">1</span> | 条目<span class="number">2</span>内容<span class="number">2</span>bbbbbb | 条目<span class="number">2</span>内容<span class="number">3</span> |</span><br><span class="line">| 条目<span class="number">3</span>内容<span class="number">1</span> | 条目<span class="number">3</span>内容<span class="number">2</span> | 条目<span class="number">3</span>内容<span class="number">3</span>cccccc |</span><br></pre></td></tr></table></figure>

<h3 id="角标文字"><a href="#角标文字" class="headerlink" title="角标文字"></a>角标文字</h3><p>这是一段有上方角标<sup>你好</sup>和下方角标<sub>世界</sub>的文字段落。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">这是一段有上方角标<span class="tag">&lt;<span class="name">sup</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">sup</span>&gt;</span>和下方角标<span class="tag">&lt;<span class="name">sub</span>&gt;</span>世界<span class="tag">&lt;/<span class="name">sub</span>&gt;</span>的文字段落，鼠标停留在文字上显示全程。</span><br></pre></td></tr></table></figure>

<h3 id="文本居中"><a href="#文本居中" class="headerlink" title="文本居中"></a>文本居中</h3><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>人生乃是一面镜子，<br>从镜子里认识自己，<br>我要称之为头等大事，<br>也只是我们追求的目的！</p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name">cq</span> %&#125;</span></span><br><span class="line"><span class="xml">人生乃是一面镜子，</span></span><br><span class="line"><span class="xml">从镜子里认识自己，</span></span><br><span class="line"><span class="xml">我要称之为头等大事，</span></span><br><span class="line"><span class="xml">也只是我们追求的目的！</span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name">endcq</span> %&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="note标签"><a href="#note标签" class="headerlink" title="note标签"></a>note标签</h3><div class="note default"><p>default</p></div>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>="<span class="symbol">note</span> <span class="symbol">default</span>"&gt;&lt;<span class="symbol">p</span>&gt;<span class="symbol">default</span>&lt;/<span class="symbol">p</span>&gt;&lt;/<span class="symbol">div</span>&gt;</span><br></pre></td></tr></table></figure>

<div class="note primary"><p>primary</p></div>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>="<span class="symbol">note</span> <span class="symbol">primary</span>"&gt;&lt;<span class="symbol">p</span>&gt;<span class="symbol">primary</span>&lt;/<span class="symbol">p</span>&gt;&lt;/<span class="symbol">div</span>&gt;</span><br></pre></td></tr></table></figure>

<div class="note success"><p>success</p></div>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>="<span class="symbol">note</span> <span class="symbol">success</span>"&gt;&lt;<span class="symbol">p</span>&gt;<span class="symbol">success</span>&lt;/<span class="symbol">p</span>&gt;&lt;/<span class="symbol">div</span>&gt;</span><br></pre></td></tr></table></figure>

<div class="note info"><p>info</p></div>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>="<span class="symbol">note</span> <span class="symbol">info</span>"&gt;&lt;<span class="symbol">p</span>&gt;<span class="symbol">info</span>&lt;/<span class="symbol">p</span>&gt;&lt;/<span class="symbol">div</span>&gt;</span><br></pre></td></tr></table></figure>

<div class="note warning"><p>warning</p></div>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>="<span class="symbol">note</span> <span class="symbol">warning</span>"&gt;&lt;<span class="symbol">p</span>&gt;<span class="symbol">warning</span>&lt;/<span class="symbol">p</span>&gt;&lt;/<span class="symbol">div</span>&gt;</span><br></pre></td></tr></table></figure>

<div class="note danger"><p>danger</p></div>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>="<span class="symbol">note</span> <span class="symbol">danger</span>"&gt;&lt;<span class="symbol">p</span>&gt;<span class="symbol">danger</span>&lt;/<span class="symbol">p</span>&gt;&lt;/<span class="symbol">div</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="tabs-标签"><a href="#tabs-标签" class="headerlink" title="tabs 标签"></a>tabs 标签</h3><div class="tabs" id="选项卡"><ul class="nav-tabs"><li class="tab"><a href="#选项卡-1">选项卡 1</a></li><li class="tab active"><a href="#选项卡-2">选项卡 2</a></li><li class="tab"><a href="#选项卡-3">选项卡 3</a></li></ul><div class="tab-content"><div class="tab-pane" id="选项卡-1"><p><strong>这是选项卡 1</strong> 哇，你找到我了！φ(≧ω≦*)♪～</p></div><div class="tab-pane active" id="选项卡-2"><p><strong>这是选项卡 2</strong> 默认显示</p></div><div class="tab-pane" id="选项卡-3"><p><strong>这是选项卡 3</strong> 哇，你找到我了！φ(≧ω≦*)♪～</p></div></div></div>

<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name">tabs</span> 选项卡, 2 %&#125;</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- tab --&gt;</span></span></span><br><span class="line"><span class="xml">**这是选项卡 1** 哇，你找到我了！φ(≧ω≦*)♪～</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- endtab --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- tab --&gt;</span></span></span><br><span class="line"><span class="xml">**这是选项卡 2** 默认显示</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- endtab --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- tab --&gt;</span></span></span><br><span class="line"><span class="xml">**这是选项卡 3** 哇，你找到我了！φ(≧ω≦*)♪～</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- endtab --&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name">endtabs</span> %&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="专有名词缩写"><a href="#专有名词缩写" class="headerlink" title="专有名词缩写"></a>专有名词缩写</h3><p>这是一段有专有名词<acronym title="National Basketball Association">NBA</acronym>和<abbr title="西安电子科技大学">西电</abbr>的文字段落。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">这是一段有专有名词<span class="tag">&lt;<span class="name">acronym</span> <span class="attr">title</span>=<span class="string">"National Basketball Association"</span>&gt;</span>NBA<span class="tag">&lt;/<span class="name">acronym</span>&gt;</span>和<span class="tag">&lt;<span class="name">abbr</span> <span class="attr">title</span>=<span class="string">"西安电子科技大学"</span>&gt;</span>西电<span class="tag">&lt;/<span class="name">abbr</span>&gt;</span>的文字段落。</span><br></pre></td></tr></table></figure>

<h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>这是一段包含行内代码<code>&lt;a href=&quot;shitsurei.github.io&quot;&gt;个人博客&lt;/a&gt;</code>的文字</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">这是一段包含行内代码`<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"shitsurei.github.io"</span>&gt;</span>个人博客<span class="tag">&lt;/<span class="name">a</span>&gt;</span>`的文字</span><br><span class="line">注意：设置行内引用可以选中文字后使用快捷键Ctrl+K。</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    num+=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br></pre></td></tr></table></figure>

<h3 id="Todo列表（待办事宜-）"><a href="#Todo列表（待办事宜-）" class="headerlink" title="Todo列表（待办事宜 ）"></a>Todo列表（待办事宜 ）</h3><ul>
<li><input disabled="" type="checkbox"> 待办事件1</li>
<li><input checked="" disabled="" type="checkbox"> 待办事件2</li>
<li><input checked="" disabled="" type="checkbox"> 待办事件3</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">- [ ] 待办事件<span class="number">1</span></span><br><span class="line">- [x] 待办事件<span class="number">2</span></span><br><span class="line">- [x] 待办事件<span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="2-资源链接"><a href="#2-资源链接" class="headerlink" title="2. 资源链接"></a>2. 资源链接</h2><h3 id="文字链接"><a href="#文字链接" class="headerlink" title="文字链接"></a>文字链接</h3><p>这段文字中包含<a href="https://shitsurei.github.io/" target="_blank" rel="noopener">个人博客</a>的链接。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这段文字中包含[<span class="string">个人博客</span>](<span class="link">https://shitsurei.github.io/</span>)的链接。</span><br></pre></td></tr></table></figure>

<h3 id="图片链接"><a href="#图片链接" class="headerlink" title="图片链接"></a>图片链接</h3><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/test_pic.jpg" alt="夏至未至"></p>
<p><img data-src="http://ww3.sinaimg.cn/mw690/81b78497jw1emfgwjrh2pj21hc0u01g3.jpg" alt="Caption"></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">采取相对路径，需要先上传文件至相应的文件夹中</span><br><span class="line">![<span class="string">夏至未至</span>](<span class="link">/uploads/test_pic.jpg</span>)</span><br><span class="line">采取绝对路径，对路径格式有要求，不一定成功</span><br><span class="line">![<span class="string">Caption</span>](<span class="link">http://ww3.sinaimg.cn/mw690/81b78497jw1emfgwjrh2pj21hc0u01g3.jpg</span>)</span><br></pre></td></tr></table></figure>

<h3 id="表情"><a href="#表情" class="headerlink" title="表情"></a>表情</h3><p>:bowtie::smile::laughing::blush::smiley::relaxed::smirk::heart_eyes::kissing_heart::kissing_closed_eyes::flushed::relieved::satisfied::grin::wink:</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:bowtie</span>::smile::laughing::blush::smiley::relaxed::smirk::heart_eyes::kissing_heart::kissing_closed_eyes::flushed::relieved::satisfied::grin::<span class="symbol">wink:</span></span><br><span class="line">更多表情信息参考：</span><br><span class="line"><span class="symbol">https:</span>/<span class="regexp">/www.webpagefx.com/tools</span><span class="regexp">/emoji-cheat-sheet/</span></span><br></pre></td></tr></table></figure>

<h2 id="3-各种语言代码高亮"><a href="#3-各种语言代码高亮" class="headerlink" title="3. 各种语言代码高亮"></a>3. 各种语言代码高亮</h2><h3 id="普通代码块"><a href="#普通代码块" class="headerlink" title="普通代码块"></a>普通代码块</h3><figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">alert</span>(<span class="string">'Hello World!'</span>);</span></span><br></pre></td></tr></table></figure>

<pre><code>print &apos;helloworld&apos;</code></pre><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">代码块课通过`包裹或<span class="literal">tab</span>键缩进标识</span><br></pre></td></tr></table></figure>

<h3 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert( <span class="string">'Hello, world!'</span> );</span><br></pre></td></tr></table></figure>

<h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> <span class="string">'helloworld'</span></span><br></pre></td></tr></table></figure>

<h3 id="ruby"><a href="#ruby" class="headerlink" title="ruby"></a>ruby</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span></span><br><span class="line">  puts <span class="string">'foo'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">string</span> str;</span><br><span class="line">  foo(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="python-1"><a href="#python-1" class="headerlink" title="python"></a>python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># A comment</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure>

<h2 id="4-其他细节"><a href="#4-其他细节" class="headerlink" title="4. 其他细节"></a>4. 其他细节</h2><h3 id="文章简介"><a href="#文章简介" class="headerlink" title="文章简介"></a>文章简介</h3><p>每篇博客的简介（用于首页显示）和正文部分通过<code>&lt;!--more--&gt;</code>语句分隔。</p>
<h3 id="引擎渲染"><a href="#引擎渲染" class="headerlink" title="引擎渲染"></a>引擎渲染</h3><p>不同的markdown引擎的解释效果是不同的，原因是采用的技术不同，有的是PHP有的是JS，本文主要针对jekyll+next的实现效果（即文章所演示出来的效果）</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>MarkdownPad2</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序及其应用</title>
    <url>/mergeSort.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>归并排序是一种典型的采用分治策略进行排序的算法，其中合并的过程用到了外部排序的方式，算法的时间复杂度可以通过master公式进行计算，空间复杂度为O(N)，本文我们来讨论一下归并排序的算法思路以及该算法适用的题型。</p>
<a id="more"></a>

<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>归并排序的排序过程可以大体划分为两个阶段：划分阶段和合并阶段。并且根据每次对原序列划分的个数分为二路归并和多路归并两种，两者的区别仅仅在于划分的路数不同，本文以基本的二路归并为例进行研究。</p>
<blockquote>
<p>划分阶段：将一个数组进行不断二分，直到将整个序列划分到单独一个元素为一部分为止<br>合并阶段：将相邻的划分好的部分进行合并，每次合并申请一个长度为要合并的两部分长度之和的数组作为辅助空间进行外部排序，排序好之后再将有序序列拷贝回这两个相邻的部分，即代表一次合并结束；不断合并直到合并到原序列</p>
</blockquote>
<p>我们通过一个案例来分析这个过程，假设原序列为【2，0，7，3，8，5，4】，那么归并排序的过程大致如下：</p>
<ul>
<li>划分过程：<ol>
<li>第一次划分：【2，0，7，3】；【8，5，4】</li>
<li>第二次划分：【2，0】；【7，3】；【8，5】；【4】</li>
<li>第三次划分：【2】；【0】；【7】；【3】；【8】；【5】；【4】</li>
</ol>
</li>
</ul>
<p>注意，这其中可能存在奇数偶数的问题，即划分过程不一定是很平均的，如果元素总个数为奇数个，那么必然会有一个元素提前一次划分完毕，成为单个部分。</p>
<ul>
<li>合并过程：<ol>
<li>第一次合并：【0，2】；【3，7】；【5，8】</li>
<li>第二次合并：【0，2，3，7】；【4，5，8】</li>
<li>第三次合并：【0，2，3，4，5，7，8】</li>
</ol>
</li>
</ul>
<p>我们发现，合并和拆分正好是一个逆序的关系，且各个部分的划分与合并严格对应，在划分过程中被拆开的两个部分一定会在合并的阶段进行合并，这样的表现方式或许不够直观，通过下面这幅划分合并图我们可以看得更加清楚（图中不带箭头的实线表示划分过程，带箭头的实线表示合并过程）：</p>
<p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/mergeSort1.jpg" alt="mergeSort1"></p>
<p>如图所示，每一层的代表一次划分或合并，从第二层开始依次是三次划分和三次合并。这里我们就可以直观的看出各个部分的划分与合并是严格对应的，第二次划分就单独成为一部分的元素4，在第一次的合并中就没有参与，而是直到倒数第二次合并才与其划分出来的85这个部分进行合并，由此我们可以得出两条推论，即在归并排序中：</p>
<ol>
<li>第i次划分得到的两个部分在倒数第i次合并时才会进行合并</li>
<li>第i次划分时不需要再被划分的部分在倒数第i次合并中不会参与合并</li>
</ol>
<h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><p>到目前为止，我们对归并排序的流程已经有了大致的把握，接下来就是函数实现的细节问题，例如边界值的判断，执行流程的控制等。从这个划分的过程来看，必然是一个递归函数的调用，在学习递归函数时我们说写一个递归函数，首先要考虑函数的终止条件，避免无休止的递归导致函数栈溢出，很显然这里的终止条件是划分的部分只有一个元素；第二步考虑递归的依赖条件，即我们想要完成对整个序列的排序，依赖于左半部分和右半部分的有序，同理左右两个部分的排序也依赖于其各自的左右两个部分的有序，以此类推……最终单个元素必然是有序的。<br>分析了这两方面的条件，我们来构造这个递归函数，为了便于函数参数的传递，我们将递归函数的参数设为本次划分出来的部分的首位下标，这样既便于函数的调用，也能够对base case作出判断；确定了函数的参数，接下来我们考虑是否需要返回值，显然我们的目的是对数组进行排序，而排序的过程可以在方法内完成，因此不需要返回值；函数内部流程我们可以抽象的分为下面几个步骤：</p>
<ol>
<li>判断当前要排序的这个部分是否已经达到了终止条件，如果是则无需再进行排序，直接返回；否则在对其进行排序</li>
<li>将当前部分划分成左右两个部分，递归调用排序方法，使得左右两个子部分各自有序</li>
<li>将排序完成的左右两个部分通过外排的方式进行合并，使当前这个部分有序</li>
</ol>
<p>根据上述分析，我们的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr==<span class="keyword">null</span>||arr.length&lt;<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	sortProcess(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 划分函数，二分</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortProcess</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left==right)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> middle = (left+right)/<span class="number">2</span>;</span><br><span class="line">	sortProcess(arr, left, middle);</span><br><span class="line">	sortProcess(arr, middle+<span class="number">1</span>, right);</span><br><span class="line">	merge(arr, left, middle, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中第一个函数是归并排序递归方法的第一个入口，同时对数组的可排序性进行了验证，我们也可以直接调用该方法的最后一行代码进入递归过程；而第二个递归函数的内部过程也和我们的分析过程如出一辙。这里对左右子序列的合并过程我们将其抽象出来，封装成一个函数，下面我们来讨论一下这个函数应当如何实现，前面我们说过归并的过程实际上是通过辅助数组来完成的，因为左右两个子部分通过递归调用排序方法已经达到有序，那么只需要两个指针从左右两个子部分的头开始，逐渐将两个子部分遍历一遍，每比较一次拷贝出一个小数，指针向后移动一下，直到某个部分的数全部拷贝完，再将另一部分剩余的数拷贝出来（最终再将辅助数组中的有序结果拷贝回原部分即可）。</p>
<p>假设现有有序的左右两个子部分【2,3,5】和【0,7,8】，则先申请一个长度为6的辅助数组【<em>,</em>,<em>,</em>,<em>,</em>】，合并的过程如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">阶段</th>
<th align="center">左子部分</th>
<th align="center">右子部分</th>
<th align="center">辅助数组</th>
</tr>
</thead>
<tbody><tr>
<td align="center">比较拷贝</td>
<td align="center">【2,3,5】</td>
<td align="center">【~,7,8】</td>
<td align="center">【0,<em>,</em>,<em>,</em>,_】</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">【~,3,5】</td>
<td align="center">【~,7,8】</td>
<td align="center">【0,2,<em>,</em>,<em>,</em>】</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">【<del>,</del>,5】</td>
<td align="center">【~,7,8】</td>
<td align="center">【0,2,3,<em>,</em>,_】</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">【<del>,</del>,~】</td>
<td align="center">【~,7,8】</td>
<td align="center">【0,2,3,5,<em>,</em>】</td>
</tr>
<tr>
<td align="center">补全拷贝</td>
<td align="center">【<del>,</del>,~】</td>
<td align="center">【<del>,</del>,8】</td>
<td align="center">【0,2,3,5,7,_】</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">【<del>,</del>,~】</td>
<td align="center">【<del>,</del>,~】</td>
<td align="center">【0,2,3,5,7,8】</td>
</tr>
<tr>
<td align="center">拷回原序列</td>
<td align="center">【0,2,3】</td>
<td align="center">【5,7,8】</td>
<td align="center">【0,2,3,5,7,8】</td>
</tr>
</tbody></table>
<p>通过这个表格我们发现，在往辅助数组中拷贝元素时，必然存在某一个部分的元素提前拷贝完成的情况，但是不清楚数据情况的前提下我们是无法确定哪个部分会剩下元素的，因此我们需要在比较拷贝阶段结束后，再对两个部分进行判断和补全拷贝工作，这样才能保证每个元素都不会丢失，最终用辅助数组中的序列覆盖掉原数组中的序列即可。该方法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并函数，复杂度为O(N)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> middle</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> middle , <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> p = left, q = middle+<span class="number">1</span> , i = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//比较拷贝</span></span><br><span class="line">	<span class="keyword">while</span>(p&lt;=middle&amp;&amp;q&lt;=right)</span><br><span class="line">		help[i++] = arr[p] &lt; arr[q] ? arr[p++] : arr[q++];</span><br><span class="line">	<span class="comment">//补全拷贝</span></span><br><span class="line">	<span class="comment">//右子部分有剩余元素未拷贝结束</span></span><br><span class="line">	<span class="keyword">while</span>(q&lt;=right)</span><br><span class="line">		help[i++] = arr[q++];</span><br><span class="line">	<span class="comment">//左子部分有剩余元素未拷贝结束</span></span><br><span class="line">	<span class="keyword">while</span>(p&lt;=middle)</span><br><span class="line">		help[i++] = arr[p++];</span><br><span class="line">	<span class="comment">//拷回原序列</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; help.length ; i++)</span><br><span class="line">		arr[left++] = help[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后要注意写完算法之后使用对数器对该算法进行测试，避免边界值界定的失误导致代码出现漏洞。下面我们来分析一下算法的复杂度，空间复杂度很好判断，辅助数组只在每一次合并时申请，合并结束后直接释放，因此每一次合并不论分成多少个部分，其加起来的总和<strong>不会超过</strong>原数组的长度，这个通过观察上文中划分和合并图即可确定，合并的每一层各个部分都只不过是对原数组长度的划分，而辅助空间的申请也是依据子部分的长度，因此空间复杂度为O(N)。</p>
<blockquote>
<ol>
<li>注意，这里之所以说不会超过而不是直接说等于原数组的长度，是因为存在如上文中单个元素4的这种情况，这样就会使得某一次的合并时申请的空间没有原数组的长度那么长；</li>
<li>并且，也并非只有划分出单个元素会出现这种情况，工程应用中，子部分长度小于一定值时会直接对其使用插入排序（插入排序对样本量较少的序列时间成本更低），也会导致不再划分的情况</li>
</ol>
</blockquote>
<p>而对时间复杂度的判断我们就需要借助master公式进行求解，因为归并排序对于子过程的划分是相等的，这里忽略奇数个元素的情况，因为均分只估计规模不考虑常数。而不论是二路归并还是多路归并，其子部分划分的个数和总共要执行的子过程次数是一样的（一次划分过程中），因此a=b推出log(b,a)=1，同时通过观察合并函数，也可以发现剩余过程的时间复杂度是O(N)，因此d=1.由master公式我们可知，归并排序算法的时间复杂度为O(N*log(N))。</p>
<h2 id="算法应用"><a href="#算法应用" class="headerlink" title="算法应用"></a>算法应用</h2><p>学习归并排序不只是要了解该算法的实现和细节，更重要的是要掌握该算法的思想，能够将其灵活的运用到各种题目中。这里我们不妨反思一下为什么归并排序相比冒泡，选择，插入这三个O(N<sup>2</sup>)级别的算法时间复杂度更优，我们说排序无非是比较和交换两部分组成，当我们在比较数组中每个元素时，如果能将已经比较过的顺序关系重复利用，而不是重复比较，那么必然能节省更多的时间。反观冒泡，选择和插入这三个算法，每次遍历（比较）完整个序列只能确定一个数据的位置，下一次比较又要重头开始，等于之前比较的结果都浪费了，时间复杂度必然是差的。</p>
<p>反观归并排序，每一次子部分的排序结果都能在下一次合并的过程中用上，组内比较的次数是不会被浪费的，这是该算法时间复杂度较快的根本原因。</p>
<h3 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h3><ul>
<li>题目：在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。</li>
<li>举例：[1,3,4,2,5]<ul>
<li>1左边比1小的数， 没有；</li>
<li>3左边比3小的数， 1；</li>
<li>4左边比4小的数， 1、 3；</li>
<li>2左边比2小的数， 1；</li>
<li>5左边比5小的数， 1、 3、 4、 2；</li>
<li>所以小和为1+1+3+1+1+3+4+2=16</li>
</ul>
</li>
<li>对数器：遍历整个数组，每个数的左边再遍历一遍，累加比当前数小的数，时间复杂度O(N<sup>2</sup>)</li>
<li>思路：小和的实质是要确定当前数的右边有多少个数比他大，借助归并排序可以加速这个过程。归并排序能够使得子部分的元素在<strong>组内有序</strong>，因此在两个子部分合并的过程中，<strong>一旦比较出左部分的某个元素（设为a）的值小于右部分的某个元素（设为b），通过与子部分右边界的下表变换即可确定右部分至少有几个元素的值比a大</strong>。且合并过程中，指针是从左往右依次遍历的，因此不会漏掉任何一个可累加的小和；每一个子部分合并完成时，该部分可以被榨取的小和全部榨取完成，在之后的合并过程中不会重复榨取，因此也不会多加任何一个小和。</li>
</ul>
<p>下面我们根据题目的要求和解题思路来对归并算法做修改，首先大框架不变，依旧是划分和合并两个部分，不同的是这次我们要求小和，因此在合并的过程中不仅要将子部分排序，还要将榨取的小和返回回来进行累加。故递归函数和合并函数的返回值需要改为整型，相应的递归函数base case的返回值要改为0，因为单个元素的子部分不产生小和；而递归的依赖关系则是，整个序列的小和是通过左右两个子部分各自内部榨取的小和之和加上当前左右两个子部分之间可以榨取的小和得到的，因此递归调用过程是三个部分的累加和作为返回值，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">smallSum</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> divide(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left == right)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> divide(arr, left, middle) + divide(arr, middle + <span class="number">1</span>, right) + merge(arr, left, right, middle);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面考虑对合并函数的修改，其实相比归并排序中合并函数的功能，小和问题只需要在比较拷贝阶段榨取小和并最终返回即可，不涉及到其他代码逻辑的更改，因为小和是在比较的前提下产生的，而合并函数中只有比较拷贝阶段涉及左右两个子部分元素的比较。因此，我们需要在合并函数中增加一个累加小和的变量，并在比较阶段，对于左部分指针指向的值小于右部分指针指向的值时榨取小和，算法是由右部分指针下标和右子部分末端下标相减加一得出有多少个元素的值大于左部分指针指向的元素，相乘累加即可。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> middle)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> p = left;</span><br><span class="line">	<span class="keyword">int</span> q = middle + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p &lt;= middle &amp;&amp; q &lt;= right) &#123;</span><br><span class="line">		<span class="comment">//榨取每个小组中的所有小和</span></span><br><span class="line">		sum += arr[p] &lt; arr[q] ? (right - q + <span class="number">1</span>) * arr[p] : <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//先榨取后拷贝（指针后移）</span></span><br><span class="line">		help[i++] = arr[p] &lt; arr[q] ? arr[p++] : arr[q++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (p &lt;= middle)</span><br><span class="line">		help[i++] = arr[p++];</span><br><span class="line">	<span class="keyword">while</span> (q &lt;= right)</span><br><span class="line">		help[i++] = arr[q++];</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</span><br><span class="line">		arr[left + i] = help[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到，这道题的代码与归并排序的代码非常相似，且时间复杂度任然保持在O(N*log(N))，时间复杂度优于直接嵌套遍历查找，原因在于利用归并排序的思路求小和实质上是分批查找，而不是单个查找，每一次子部分合并，即可累加出一批小和，大大加速了查找效率。</p>
<h3 id="逆序对问题"><a href="#逆序对问题" class="headerlink" title="逆序对问题"></a>逆序对问题</h3><ul>
<li>题目：在一个数组中，左边的数如果比右边的数大，则这两个数构成一个逆序对，请打印所有逆序对。</li>
<li>思路：延续小和问题的思路，在两个相对有序的子部分中，很容易知道某个数左右有几个大于或小于该数的元素，因此可以在合并的过程中比较左右两个指针指向的数的大小关系，符合逆序对时，左部分指针往后的数都是比当前数大的，故都能与右部分指针指向的数组成逆序对，故直接遍历输出即可。</li>
<li>代码修改：相比小和问题，本题对归并排序的代码改动更少，因为不涉及合并结果的累计，我们只需在合并时将符合条件的值输出即可，故只需在合并函数的比较拷贝阶段添加如下代码即可（注意以下代码要放在拷贝和指针后移之前执行）：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(arr[p]&gt;arr[q]) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = p; j &lt;= middle; j++) &#123;</span><br><span class="line">		System.out.println(<span class="string">"逆序对["</span>+arr[j]+<span class="string">","</span>+arr[q]+<span class="string">"]"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr />
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP学习笔记1</title>
    <url>/php1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>PHP的底层由C语言编写，是一种运行在服务器端解释执行的脚本语言，具有以下几个特性：<br>1.由于不需要编译，其变量类型在运行时进行创建和确定，是一种弱类型语言<br>2.PHP代码可以和HTML代码互相嵌套，易于学习和开发</p>
<a id="more"></a>

<p>##基本语法</p>
<h3 id="注释方式"><a href="#注释方式" class="headerlink" title="注释方式"></a>注释方式</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单行注释方式1</span></span><br><span class="line"><span class="comment">#单行注释方式2</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多行注释方式</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><ul>
<li>定义变量,以$开头，其余规则和c相同</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#注意，PHP没有创建变量的命令，变量会在首次为其赋值时被创建</span></span><br><span class="line"><span class="comment">#不赋值的变量不分配内存空间,类型类NULL</span></span><br><span class="line">$a;</span><br><span class="line">var_dump($a);<span class="comment">//NULL</span></span><br><span class="line">$a=<span class="number">1</span>;</span><br><span class="line"><span class="comment">#PHP是弱类型语言，数据类型会根据上下文进行变化</span></span><br><span class="line">$b=<span class="number">1.5</span>;</span><br><span class="line">$c=$a+$b;</span><br><span class="line"><span class="keyword">echo</span> $c;	<span class="comment">//2.5</span></span><br></pre></td></tr></table></figure>

<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><ul>
<li>PHP的变量有三种作用域local，global，static</li>
<li>默认作用域</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#函数之外声明的拥有global作用域，只能在函数以外访问</span></span><br><span class="line"> $d=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scope</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">#函数之内声明的拥有local作用域，只能在函数以内访问</span></span><br><span class="line">	$e=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">echo</span> $e;<span class="comment">//2</span></span><br><span class="line">	<span class="keyword">echo</span> $d;<span class="comment">//Notice: Undefined variable</span></span><br><span class="line">&#125;</span><br><span class="line">scope();</span><br><span class="line"><span class="keyword">echo</span> $d;<span class="comment">//1</span></span><br><span class="line"><span class="keyword">echo</span> $e;<span class="comment">//Notice: Undefined variable</span></span><br></pre></td></tr></table></figure>

<ul>
<li>global关键词</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#global关键词用于函数内访问全局变量</span></span><br><span class="line">$f=<span class="number">5</span>;</span><br><span class="line">$g=<span class="number">6</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">global_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">global</span> $f,$g;</span><br><span class="line">	<span class="keyword">echo</span> $f;<span class="comment">//5</span></span><br><span class="line">	<span class="keyword">echo</span> $g;<span class="comment">//6</span></span><br><span class="line">&#125;</span><br><span class="line">global_test();</span><br><span class="line"></span><br><span class="line"><span class="comment">#在函数内部的$GLOBALS[index]数组存储了所有的全局变量，下标为变量名</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">globals_test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">echo</span> $GLOBALS[<span class="string">'f'</span>];<span class="comment">//5</span></span><br><span class="line">	<span class="keyword">echo</span> $GLOBALS[<span class="string">'g'</span>];<span class="comment">//6</span></span><br><span class="line">&#125;</span><br><span class="line">globals_test();</span><br></pre></td></tr></table></figure>

<ul>
<li>static关键字</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#static关键字用于函数内部变量的静态化，即调用函数后变量不回收</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">static_test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> $h=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">echo</span> $h;</span><br><span class="line">	$h++;</span><br><span class="line">&#125;</span><br><span class="line">static_test();<span class="comment">//0</span></span><br><span class="line">static_test();<span class="comment">//1</span></span><br><span class="line">static_test();<span class="comment">//2</span></span><br><span class="line">static_test();<span class="comment">//3</span></span><br><span class="line"><span class="comment">#该变量仍然是函数的局部变量</span></span><br><span class="line"><span class="keyword">echo</span> $h;<span class="comment">//Notice: Undefined variable</span></span><br></pre></td></tr></table></figure>

<h3 id="输出方式"><a href="#输出方式" class="headerlink" title="输出方式"></a>输出方式</h3><ul>
<li>echo</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#echo能够输出一个以上的字符串</span></span><br><span class="line"><span class="comment">#拼串方式</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>;<span class="comment">//abc</span></span><br><span class="line"><span class="comment">#显示字符串和变量</span></span><br><span class="line">$i=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"i=$i"</span>;<span class="comment">//i=3</span></span><br><span class="line"><span class="comment">#显示数组元素</span></span><br><span class="line">$arr=<span class="keyword">array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"arr[0]=&#123;$arr[0]&#125;"</span>;<span class="comment">//arr[0]=1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>print</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#print只能输出一个字符串，并始终返回 1</span></span><br><span class="line">$j=<span class="keyword">print</span> <span class="string">"i=$i"</span>;<span class="comment">//i=3</span></span><br><span class="line"><span class="keyword">print</span> $j;<span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><blockquote>
<p>var_dump(变量);函数输出变量的类型和值，非十进制自动转为十进制,字符串类型输出变量长度和值</p>
</blockquote>
<h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>PHP不支持无符号整数(一个整数占用四个字节，一个字节占8bit，PHP整数二进制的最高位只能表示符号，0表示整数，1表示负数)</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#PHP_INT_SIZE该常量显示当前机器一个整数用几个字节表示</span></span><br><span class="line"><span class="keyword">echo</span> PHP_INT_SIZE;<span class="comment">//8</span></span><br><span class="line"><span class="comment">#PHP_INT_MAX该常量表示int所能表示的最大整数</span></span><br><span class="line"><span class="keyword">echo</span> PHP_INT_MAX;<span class="comment">//9223372036854775807</span></span><br><span class="line"><span class="comment">#超出整型最大表示数会自动变成float类型</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span><br><span class="line">$a=<span class="number">12</span>;</span><br><span class="line">var_dump($a);<span class="comment">//int(12)</span></span><br><span class="line">$b=<span class="number">1.5</span>;</span><br><span class="line">var_dump($b);<span class="comment">//float(1.5)</span></span><br><span class="line">$c=<span class="number">053</span>;</span><br><span class="line">var_dump($c);<span class="comment">//int(43)</span></span><br><span class="line">$d=<span class="number">0x5a</span>;</span><br><span class="line">var_dump($d);<span class="comment">//int(90)</span></span><br></pre></td></tr></table></figure>

<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>字长与平台相关，通常最大值为1.8e308，精度是14</p>
<blockquote>
<p>小数的精度从左边第一个非零数开始算起</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$e=<span class="number">2.4e3</span>;</span><br><span class="line">var_dump($e);<span class="comment">//float(2400)</span></span><br><span class="line">$f=<span class="number">8E-5</span>;</span><br><span class="line">var_dump($f);<span class="comment">//float(8.0E-5)</span></span><br></pre></td></tr></table></figure>

<h3 id="bool类型"><a href="#bool类型" class="headerlink" title="bool类型"></a>bool类型</h3><p>以下值也会被当做false对待：整型0，浮点数0.0，空字符串，字符串”0”，空数组，NULL</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$is_true=<span class="keyword">true</span>;</span><br><span class="line">$is_true=<span class="keyword">false</span>;</span><br><span class="line">var_dump($is_true);<span class="comment">//bool(false)</span></span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$arr = <span class="keyword">array</span>(<span class="string">'a'</span>, <span class="string">'b'</span>);</span><br><span class="line">var_dump($arr);<span class="comment">//array(2) &#123; [0]=&gt; string(1) "a" [1]=&gt; string(1) "b" &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><blockquote>
<p>单双引号均可<br>双引号：$表示变量，\表示转移符<br>单引号：仅输出$符号，仅输出\符号<br>单引号只解析单引号，双引号只解析双引号</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$txt2=<span class="string">'string2'</span>;</span><br><span class="line">var_dump($txt2);<span class="comment">//string(7) "string2"</span></span><br></pre></td></tr></table></figure>

<h3 id="NULL值"><a href="#NULL值" class="headerlink" title="NULL值"></a>NULL值</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$h=<span class="keyword">null</span>;</span><br><span class="line">var_dump($h);<span class="comment">//NULL</span></span><br></pre></td></tr></table></figure>

<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $color;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($color=<span class="string">"green"</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;color = $color;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">what_color</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">$g=<span class="keyword">new</span> Car(<span class="string">"white"</span>);</span><br><span class="line"><span class="keyword">echo</span> $g-&gt;what_color();</span><br><span class="line">var_dump($g);<span class="comment">//object(Car)#1 (1) &#123; ["color"]=&gt; string(5) "white" &#125;</span></span><br></pre></td></tr></table></figure>


<h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><h3 id="计算字符串长度"><a href="#计算字符串长度" class="headerlink" title="计算字符串长度"></a>计算字符串长度</h3><p>strlen函数，返回字符串长度</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">echo</span> strlen($txt);<span class="comment">//12</span></span><br></pre></td></tr></table></figure>


<h3 id="字符串匹配检索"><a href="#字符串匹配检索" class="headerlink" title="字符串匹配检索"></a>字符串匹配检索</h3><p>返回找到匹配串的下标(从0开始)，找不到返回false,可选项第三个参数可以限定开始检索的位置</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$txt=<span class="string">"hello worLd."</span>;</span><br><span class="line">$find = strpos($txt, <span class="string">"a"</span>);</span><br><span class="line"><span class="keyword">if</span>($find)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"find"</span>;<span class="comment">//不输出</span></span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"not_find"</span>;<span class="comment">//输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>strpos</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$txt=<span class="string">"hello worLd."</span>;</span><br><span class="line"><span class="comment">#strpos函数，第一次出现，区分大小写</span></span><br><span class="line"><span class="keyword">echo</span> strpos($txt, <span class="string">"l"</span>);<span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>strrpos</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$txt=<span class="string">"hello worLd."</span>;</span><br><span class="line"><span class="comment">#strrpos函数，最后一次出现，区分大小写</span></span><br><span class="line"><span class="keyword">echo</span> strrpos($txt, <span class="string">"l"</span>);<span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>strripos</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$txt=<span class="string">"hello worLd."</span>;</span><br><span class="line"><span class="comment">#strripos函数，最后一次出现，不区分大小写</span></span><br><span class="line"><span class="keyword">echo</span> strripos($txt, <span class="string">"l"</span>);<span class="comment">//9</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串检索替换"><a href="#字符串检索替换" class="headerlink" title="字符串检索替换"></a>字符串检索替换</h3><p>str_ireplace不区分大小写，str_replace区分大小写</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$txt=<span class="string">"hello worLd."</span>;</span><br><span class="line">$txt = str_ireplace(<span class="string">'l'</span>, <span class="string">'233'</span>, $txt);</span><br><span class="line"><span class="keyword">echo</span> $txt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#也可以用于替换数组,最后一个参数用于统计替换次数</span></span><br><span class="line">$color = <span class="keyword">array</span>(<span class="string">'red'</span> , <span class="string">'blue'</span> , <span class="string">'black'</span>);</span><br><span class="line">$color2 = str_ireplace(<span class="string">'red'</span>, <span class="string">'yellow'</span>, $color , $index);</span><br><span class="line"><span class="keyword">echo</span> $color2[<span class="number">0</span>];<span class="comment">//yellow</span></span><br><span class="line"><span class="keyword">echo</span> $index;<span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串相似度匹配"><a href="#字符串相似度匹配" class="headerlink" title="字符串相似度匹配"></a>字符串相似度匹配</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#计算两个字符串的相似度，返回百分比</span></span><br><span class="line">similar_text(<span class="string">"Hello World"</span>,<span class="string">"Hello Shanghai"</span>,$percent);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"$percent%"</span>;<span class="comment">//48%</span></span><br></pre></td></tr></table></figure>

<h3 id="比较字符串大小"><a href="#比较字符串大小" class="headerlink" title="比较字符串大小"></a>比较字符串大小</h3><blockquote>
<p>strcmp区分大小写，strcasecmp不区分大小写</p>
</blockquote>
<ul>
<li>=0 - 如果两个字符串相等</li>
<li>&lt;0 - 如果 string1 小于 string2</li>
<li>&gt;0 - 如果 string1 大于 string2</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">echo</span> strcmp(<span class="string">"Hello world!"</span>,<span class="string">"Hello world!"</span>);<span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串拆分"><a href="#字符串拆分" class="headerlink" title="字符串拆分"></a>字符串拆分</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$city=<span class="string">"北京 上海 天津 西安 武汉"</span>;</span><br><span class="line">$city_arr=explode(<span class="string">" "</span>, $city);</span><br><span class="line">print_r($city_arr);<span class="comment">//Array ( [0] =&gt; 北京 [1] =&gt; 上海 [2] =&gt; 天津 [3] =&gt; 西安 [4] =&gt; 武汉 )</span></span><br></pre></td></tr></table></figure>

<hr />
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>基本语法</tag>
        <tag>数据类型</tag>
        <tag>字符串函数</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP预定义超全局变量学习笔记</title>
    <url>/php10.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>所谓预定义超全局变量，指的是全部作用域中始终可用的内置变量，函数中无需通过global关键字访问。PHP提供了9中超全局变量，有助于方便快捷的写代码</p>
<a id="more"></a>

<p>我们之前学习过PHP的基本语法中有一种全局变量，在整个作用域（当前PHP脚本文件）中可见，而预定义的超全局变量，除了有全局变量的特点之外，可以无需声明直接引用。</p>
<h2 id="GET"><a href="#GET" class="headerlink" title="$_GET"></a>$_GET</h2><p>使用场景：浏览器通过超链接传送信息给服务器</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;a href='get.php?param1=你好啊'&gt;传输数据&lt;/a&gt;"</span>;<span class="comment">//点击跳转到get.php页面</span></span><br><span class="line"><span class="comment">## 处理低版本IE浏览器（5/6）的中文乱码问题</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">$str=urlencode("中文字符");</span></span><br><span class="line"><span class="comment">echo "&lt;a href='get.php?param1='".$str."&gt;传输数据&lt;/a&gt;";</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>通过URL参数传递给当前脚本的变量的数组，原理如下：</p>
<ol>
<li>浏览器点击超链接，遵循http协议发送请求</li>
<li>Apache服务器接受到请求后调用PHP模块</li>
<li>PHP模块处理请求，创建进程并封装相关参数到超全局数组$_GET中</li>
<li>PHP脚本处理超全局数组中的参数，处理完成后返回给服务器</li>
<li>服务器遵循http协议返回响应给浏览器</li>
<li>浏览器解析响应数据，展示界面</li>
</ol>
<ul>
<li>不同的进程对应不同的浏览器请求，封装不同的超全局数组，请求较多时要考虑服务器的并发承受能力</li>
<li>禁止在php.ini中启用register_globals（默认取全局数组中的变量），防止sql注入</li>
</ul>
<h2 id="POST"><a href="#POST" class="headerlink" title="$_POST"></a>$_POST</h2><p>使用场景：</p>
<ol>
<li>浏览前通过表单传输信息给服务器（注意多选框的name值应该以数组方式填写）</li>
<li>流数据的传输，文件、图片等</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">"</span></span><br><span class="line"><span class="string">&lt;h1&gt;用户注册&lt;/h1&gt;</span></span><br><span class="line"><span class="string">&lt;form action='post.php' method='post'&gt;</span></span><br><span class="line"><span class="string">用户名：&lt;input type='text' name='username'/&gt;&lt;br/&gt;</span></span><br><span class="line"><span class="string">密码：&lt;input type='password' name='password'/&gt;&lt;br/&gt;</span></span><br><span class="line"><span class="string">性别：男&lt;input type='radio' name='sex' value='1'/&gt;女&lt;input type='radio' name='sex' value='0'/&gt;&lt;br/&gt;</span></span><br><span class="line"><span class="string">爱好：唱歌&lt;input name='hobby[]' type='checkbox' value='1'/&gt;读书&lt;input name='hobby[]' type='checkbox' value='2'/&gt;跳舞&lt;input name='hobby[]' type='checkbox' value='3'/&gt;&lt;br/&gt;</span></span><br><span class="line"><span class="string">年级：&lt;select name='class'&gt;</span></span><br><span class="line"><span class="string">&lt;option value='1'&gt;一年级&lt;/option&gt;</span></span><br><span class="line"><span class="string">&lt;option value='2'&gt;二年级&lt;/option&gt;</span></span><br><span class="line"><span class="string">&lt;option value='3'&gt;三年级&lt;/option&gt;</span></span><br><span class="line"><span class="string">&lt;/select&gt;&lt;br/&gt;</span></span><br><span class="line"><span class="string">&lt;textarea rows='10' cols='50' name='introduce'&gt;&lt;/textarea&gt;&lt;br/&gt;</span></span><br><span class="line"><span class="string">&lt;input type='submit' value='提交'&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">"</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">提交跳转到post.php页面</span></span><br><span class="line"><span class="comment">echo "&lt;pre&gt;";</span></span><br><span class="line"><span class="comment">print_r($_POST);</span></span><br><span class="line"><span class="comment">Array</span></span><br><span class="line"><span class="comment">(</span></span><br><span class="line"><span class="comment">    [username] =&gt; aaa</span></span><br><span class="line"><span class="comment">    [password] =&gt; 222</span></span><br><span class="line"><span class="comment">    [sex] =&gt; 1</span></span><br><span class="line"><span class="comment">    [hobby] =&gt; Array</span></span><br><span class="line"><span class="comment">        (</span></span><br><span class="line"><span class="comment">            [0] =&gt; 1</span></span><br><span class="line"><span class="comment">            [1] =&gt; 3</span></span><br><span class="line"><span class="comment">        )</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    [class] =&gt; 1</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">echo "&lt;/pre&gt;";</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="REQUEST"><a href="#REQUEST" class="headerlink" title="$_REQUEST"></a>$_REQUEST</h2><p>其中包含$_GET/$_POST/$_COOKIE三个超全局数组的信息，更完整。如果不知道提交方式，可以通过$_SERVER中的参数判断，官方不建议使用这个变量。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ($_SERVER[<span class="string">'REQUEST_METHOD'</span>]==<span class="string">"post"</span>) &#123;</span><br><span class="line">	$echo $_POST[<span class="string">'xxx'</span>];</span><br><span class="line">&#125;<span class="keyword">elseif</span> ($_SERVER[<span class="string">'REQUEST_METHOD'</span>]==<span class="string">"get"</span>) &#123;</span><br><span class="line">	$echo $_GET[<span class="string">'xxx'</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SERVER"><a href="#SERVER" class="headerlink" title="$_SERVER"></a>$_SERVER</h2><p>主要包含了http请求行和请求头的信息，以及客户端和服务器的一些信息，例如服务器文档根目录</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;pre&gt;"</span>;</span><br><span class="line">print_r($_SERVER);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;/pre&gt;"</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取请求该页面的客户机的IP地址 <strong>$_SERVER[‘REMOTE_ADDR’]</strong></li>
<li>获取服务器端的软件版本 <strong>$_SERVER[‘SERVER_SOFTWARE’]</strong></li>
</ul>
<h2 id="ENV"><a href="#ENV" class="headerlink" title="$_ENV"></a>$_ENV</h2><p>该全局数组可以获取全局变量，出于安全性的考虑默认禁用，在开发和生产环境中不要启用。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;pre&gt;"</span>;</span><br><span class="line">print_r($_ENV);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;/pre&gt;"</span>;</span><br></pre></td></tr></table></figure>

<h2 id="GLOBALS"><a href="#GLOBALS" class="headerlink" title="$GLOBALS"></a>$GLOBALS</h2><p>包含全部变量的全局组合数组，变量的名字就是数组的键，一个自定义的全局变量也会被该数组管理。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$a=<span class="number">22</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;pre&gt;"</span>;</span><br><span class="line">print_r($GLOBALS);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;/pre&gt;"</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Array</span></span><br><span class="line"><span class="comment">(</span></span><br><span class="line"><span class="comment">    [_GET] =&gt; Array</span></span><br><span class="line"><span class="comment">        (</span></span><br><span class="line"><span class="comment">        )</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    [_POST] =&gt; Array</span></span><br><span class="line"><span class="comment">        (</span></span><br><span class="line"><span class="comment">        )</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    [_COOKIE] =&gt; Array</span></span><br><span class="line"><span class="comment">        (</span></span><br><span class="line"><span class="comment">            [Hm_lvt_94d8610c17caaa5b58069613ba4c67cf] =&gt; 1541080289,1541147321,1541260617</span></span><br><span class="line"><span class="comment">            [__atuvc] =&gt; 8|44</span></span><br><span class="line"><span class="comment">            [scroll-cookie] =&gt; 0|/</span></span><br><span class="line"><span class="comment">        )</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    [_FILES] =&gt; Array</span></span><br><span class="line"><span class="comment">        (</span></span><br><span class="line"><span class="comment">        )</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    [GLOBALS] =&gt; Array</span></span><br><span class="line"><span class="comment"> *RECURSION*</span></span><br><span class="line"><span class="comment">    [a] =&gt; 22</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr />
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>get</tag>
        <tag>post</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP学习笔记2</title>
    <url>/php2.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>PHP在运算符和语句结构方面的语法与其他语言差别不大，并且由于弱类型语言的机制，在数组、字符串方面的运算更加灵活，强大。这里要注意对位运算的熟悉和加强，有助于对底层技术的学习。函数方面PHP支持值传递和引用传递两种方式，细节方面与强类型语言也有差别，注意区分。</p>
<a id="more"></a>

<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><ul>
<li>+ 加</li>
<li>- 减</li>
<li>* 乘</li>
<li>/ 除</li>
<li>% 取模</li>
</ul>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><ul>
<li>= </li>
<li>+= </li>
<li>-= </li>
<li>*= </li>
<li>/= </li>
<li>%=</li>
</ul>
<blockquote>
<p>除不尽是自动转化为浮点型14位精度（参考学习笔记1中基本数据类型关于精度的解释）</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="number">7</span>/<span class="number">3</span>;<span class="comment">//2.3333333333333</span></span><br></pre></td></tr></table></figure>

<h3 id="自增自减云算法-分左右"><a href="#自增自减云算法-分左右" class="headerlink" title="自增自减云算法(分左右)"></a>自增自减云算法(分左右)</h3><ul>
<li>++ 加1</li>
<li>-- 减1</li>
</ul>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><ul>
<li>全等(值相同且类型相同) ===</li>
<li>等于 ==</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="string">"0"</span>===<span class="keyword">false</span>) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"全等"</span>;<span class="comment">//输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">elseif</span> (<span class="string">"0"</span>==<span class="keyword">false</span>) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"相等"</span>;<span class="comment">//不输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不等于 !=  &lt;&gt;</li>
<li>不全等于(值不相等或类型不相等) !==</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="string">"0"</span>!=<span class="keyword">false</span>) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"不等于"</span>;<span class="comment">//不输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">elseif</span> (<span class="string">"0"</span>!==<span class="keyword">false</span>) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"不全等"</span>;<span class="comment">//输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>大于 &gt;</li>
<li>小于 &lt;</li>
<li>大于等于 &gt;=</li>
<li>小于等于 &lt;=</li>
</ul>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul>
<li>与 and &amp;&amp;</li>
<li>或 or  ||</li>
<li>非 !</li>
<li>异或(有且仅有一个正确才满足) xor</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="number">1</span>&gt;<span class="number">0</span>)<span class="keyword">xor</span>(<span class="number">2</span>&gt;<span class="number">1</span>)) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"两个都对"</span>;<span class="comment">//不输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">elseif</span> ((<span class="number">1</span>&gt;<span class="number">2</span>)<span class="keyword">xor</span>(<span class="number">2</span>&gt;<span class="number">1</span>)) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"只对一个"</span>;<span class="comment">//输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>and和or的运算优先级低于=(赋值)</strong></p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$h= <span class="keyword">false</span> <span class="keyword">or</span> <span class="keyword">true</span>;</span><br><span class="line">$i= <span class="keyword">false</span> || <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"h=$h"</span>;<span class="comment">//不输出(即false)</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"i=$i"</span>;<span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h3><p>拼串,任何类型都会当成字符串，注意.后要有空格 </p>
<ul>
<li>. </li>
<li>.=</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$a=<span class="string">"hello"</span>;</span><br><span class="line">$b=$a.<span class="string">" world"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"$b"</span>;<span class="comment">//hello world</span></span><br><span class="line">$a.=<span class="string">" world"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"$a"</span>;<span class="comment">//hello world</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span><br></pre></td></tr></table></figure>

<h3 id="数组运算符"><a href="#数组运算符" class="headerlink" title="数组运算符"></a>数组运算符</h3><ul>
<li>全等(拥有相同的键/值对，且顺序相同类型相同) ===</li>
<li>相等(拥有相同的键/值对) ==</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$f = <span class="keyword">array</span>(<span class="string">'1'</span> =&gt; <span class="number">1</span>,<span class="string">'2'</span> =&gt; <span class="number">2</span>);</span><br><span class="line">$g = <span class="keyword">array</span>(<span class="string">'2'</span> =&gt; <span class="number">2</span>,<span class="string">'1'</span> =&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> ($f===$g) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"全等"</span>;<span class="comment">//不输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">elseif</span> ($f==$g) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"相等"</span>;<span class="comment">//输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不相等(类似集合概念) !=  &lt;&gt;</li>
<li>不全等(键/值，顺序有一项不满足即可) !==</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$f = <span class="keyword">array</span>(<span class="string">'1'</span> =&gt; <span class="number">1</span>,<span class="string">'2'</span> =&gt; <span class="number">2</span>);</span><br><span class="line">$g = <span class="keyword">array</span>(<span class="string">'2'</span> =&gt; <span class="number">2</span>,<span class="string">'1'</span> =&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> ($f!=$g) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"不相等"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">elseif</span> ($f!==$g) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"完全不同"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型运算符"><a href="#类型运算符" class="headerlink" title="类型运算符"></a>类型运算符</h3><p>判断某一个变量是否属于某一类，不能用于判断基本数据类型</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span></span>&#123;&#125;</span><br><span class="line">$j=<span class="keyword">new</span> Cat;</span><br><span class="line"><span class="keyword">echo</span> $j <span class="keyword">instanceof</span> Cat;<span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>需要计算机组成原理中原码、反码和补码相关知识基础，主要包括以下几条规则：</p>
<blockquote>
<p>位运算符运算时将十进制整数转换为二进制进行运算，一个整数4个字节（与电脑的操作系统位数相关，这里适用于64位操作系统），每个字节8位，因此一个整数的二进制共32位。</p>
</blockquote>
<ol>
<li>最高位表符号(PHP不支持无符号整数)    0正1负</li>
<li>正数的原码反码补码都一样</li>
<li>负数的反码等于符号为不变，其余位取反</li>
<li>负数的补码等于其反码加一</li>
<li>0的反码补码都是0</li>
<li>计算机运算时都是以补码运算的</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">举例：<span class="number">-5</span>的二进制</span><br><span class="line">原码<span class="number">10000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000101</span></span><br><span class="line">反码<span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111010</span></span><br><span class="line">补码<span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111011</span></span><br></pre></td></tr></table></figure>

<ul>
<li>位与(同1取1否则取0)&amp;</li>
<li>位或(同0取0否则取1)|</li>
<li>位异或(相同取0不同取1)^</li>
<li>位非(取反)~</li>
<li>左移(符号为不变，低位补0)&lt;&lt;</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#举例：-5&lt;&lt;3</span></span><br><span class="line"><span class="comment">#补码11111111 11111111 11111111 11111011</span></span><br><span class="line"><span class="comment">#左移11111111 11111111 11111111 11011000</span></span><br><span class="line"><span class="comment">#反码11111111 11111111 11111111 11010111</span></span><br><span class="line"><span class="comment">#原码10000000 00000000 00000000 00101000</span></span><br><span class="line"><span class="comment">#-40</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">-5</span>&lt;&lt;<span class="number">3</span>;<span class="comment">//-40</span></span><br></pre></td></tr></table></figure>
<ul>
<li>右移(符号位不变，低位溢出，用符号位补高位)&gt;&gt;</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#举例：5&gt;&gt;3</span></span><br><span class="line"><span class="comment">#补码00000000 00000000 00000000 00000101</span></span><br><span class="line"><span class="comment">#右移00000000 00000000 00000000 00000000</span></span><br><span class="line"><span class="comment">#原码00000000 00000000 00000000 00000000</span></span><br><span class="line"><span class="comment">#0</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">5</span>&gt;&gt;<span class="number">3</span>;<span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<h2 id="语句结构"><a href="#语句结构" class="headerlink" title="语句结构"></a>语句结构</h2><h3 id="条件分支语句"><a href="#条件分支语句" class="headerlink" title="条件分支语句"></a>条件分支语句</h3><ul>
<li>if elseif else</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>+<span class="number">1</span>!=<span class="number">2</span>) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"1+1!=2"</span>;<span class="comment">//不输出</span></span><br><span class="line">&#125; <span class="keyword">elseif</span> (<span class="number">2</span>+<span class="number">2</span>!=<span class="number">4</span>) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"2+2!=4"</span>;<span class="comment">//不输出</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"other"</span>;<span class="comment">//输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>switch</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$a=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">switch</span> ($a) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'1'</span>:</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"a=1"</span>;<span class="comment">//不输出</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'2'</span>:</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"a=2"</span>;<span class="comment">//输出</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"other"</span>;<span class="comment">//不输出</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环结构语句"><a href="#循环结构语句" class="headerlink" title="循环结构语句"></a>循环结构语句</h3><ul>
<li>while</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">while</span> ($a &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"a=$a"</span>;<span class="comment">//a=2a=3a=4a=5a=6a=7a=8a=9a=10</span></span><br><span class="line">	$a++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>do while</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">while</span> ($a &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"a=$a"</span>;</span><br><span class="line">	$a++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"a=$a"</span>;<span class="comment">//a=11</span></span><br><span class="line">&#125; <span class="keyword">while</span> ($a &lt;= <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>for</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> ($b=<span class="number">0</span>; $b &lt; <span class="number">5</span>; $b++) &#123; </span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"b=$b"</span>;<span class="comment">//b=0b=1b=2b=3b=4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>foreach</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#只适用于遍历数组</span></span><br><span class="line">$color = <span class="keyword">array</span>(<span class="string">'1'</span> =&gt; <span class="string">'red'</span> , <span class="string">'2'</span> =&gt; <span class="string">'yellow'</span> ,<span class="string">'3'</span> =&gt; <span class="string">'green'</span> ,<span class="string">'4'</span> =&gt; <span class="string">'blue'</span>);</span><br><span class="line"><span class="keyword">foreach</span> ($color <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"$key=$value"</span>;<span class="comment">//1=red2=yellow3=green4=blue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li>函数名对大小写不敏感</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"f1"</span>;</span><br><span class="line">&#125;</span><br><span class="line">F1();<span class="comment">//f1</span></span><br><span class="line">f1();<span class="comment">//f1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数(PHP提供默认参数，不传参时采用默认参数)</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span><span class="params">($default=<span class="string">'aaa'</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"$default"</span>;</span><br><span class="line">&#125;</span><br><span class="line">f2();<span class="comment">//aaa</span></span><br><span class="line">f2(<span class="string">'bbb'</span>);<span class="comment">//bbb</span></span><br></pre></td></tr></table></figure>

<ul>
<li>PHP默认采用值传递，如需引用（地址）传递，变量名前加取地址符(&amp;)</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"$num"</span>;<span class="comment">//0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f4</span><span class="params">(&amp;$temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	$temp++;</span><br><span class="line">&#125;</span><br><span class="line">f4($num);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"$num"</span>;<span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>函数返回值，直接使用return语句，无需在函数头声明返回值类型</li>
<li>每次执行函数PHP都会开辟一个新栈，各个栈之间的变量相互独立</li>
<li>unset()方法可用于销毁一个变量</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$a=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">global</span> $a;</span><br><span class="line">	$a=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">unset</span>($a);</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"$a"</span>;<span class="comment">//报错，$a未定义，此处对$a的引用已销毁</span></span><br><span class="line">	<span class="keyword">global</span> $a;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"$a"</span>;<span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line">f3();</span><br><span class="line"><span class="keyword">unset</span>($a);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"$a"</span>;<span class="comment">//报错，$a未定义，此处$a变量已销毁</span></span><br></pre></td></tr></table></figure>
<hr />
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>运算符</tag>
        <tag>语句结构</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP学习笔记3</title>
    <url>/php3.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>PHP中的数组是一个非常有意思的数据结构，我们最常用的两种用于保存数据的结构是list和map，不论是链式存储还是顺序存储，不论是散列存储还是其他的二叉树存储，保存相同数据类型的集合与复杂数据类型内部结构的存储都是日常开发中最基本的需求。而在PHP中的数组可以看做是这两种数据结构的综合，弱类型语言的机制使得数组不再是单一数据类型的集合，我们既可以把数组当成一个map，用于保存键值对，又可以作为list保存同类型元素。<br>其次，PHP是基于C语言编写的面向对象脚本语言，他的内存模型也类似于C，分为堆、栈、常量区等几个部分，在今后的面向对象学习中还需要更深的理解。</p>
<a id="more"></a>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组创建"><a href="#数组创建" class="headerlink" title="数组创建"></a>数组创建</h3><p>PHP的数组支持动态增长，跳跃赋值</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#PHP中的数组使用array()函数创建</span></span><br><span class="line">$value=<span class="number">1</span>;</span><br><span class="line">$arrayName = <span class="keyword">array</span>(<span class="string">'index'</span> =&gt; $value, );</span><br></pre></td></tr></table></figure>

<h3 id="数组分类"><a href="#数组分类" class="headerlink" title="数组分类"></a>数组分类</h3><ul>
<li>索引数组</li>
</ul>
<p>带有数字索引的数组，可采用自动分配(索引从0开始)或手动分配(不重复即可,重复时以后分配的为准)</p>
<ul>
<li>关联数组</li>
</ul>
<p>带有指定键的数组，任意分配给数组的指定键的数组，可在创建数组时直接分配或之后的赋值中再分配</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$arr1 = <span class="keyword">array</span>(<span class="string">'a'</span> =&gt; <span class="number">1</span>,<span class="string">'b'</span> =&gt; <span class="number">2</span>);</span><br><span class="line">$arr1[<span class="string">'c'</span>]=<span class="number">3</span>;</span><br><span class="line">var_dump($arr1);<span class="comment">//array(6) &#123; ["a"]=&gt; int(1) ["b"]=&gt; int(2) ["c"]=&gt; int(3) &#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>缺省键值分配原则</p>
<ul>
<li>从首个元素遍历至当前元素，寻找是否有以数字作为键值的元素<ul>
<li>如果没有，以0作为默认的缺省键值</li>
<li>如果有，将距离缺省元素最近的前一位符合1条件的元素的键值加1作为缺省元素的键值</li>
</ul>
</li>
<li>如果之后的元素占用了当且缺省元素所分配的键值，遵循重复覆盖的原则</li>
</ul>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$arr2 = <span class="keyword">array</span>(<span class="string">'3'</span> =&gt; <span class="number">1</span>,<span class="string">'8'</span> =&gt; <span class="number">2</span>,<span class="string">'a'</span> =&gt; <span class="number">3</span>,<span class="number">4</span>,<span class="string">'c'</span> =&gt; <span class="number">5</span>);</span><br><span class="line">var_dump($arr2);<span class="comment">//array(6) &#123; [3]=&gt; int(1) [8]=&gt; int(2) ["a"]=&gt; int(3) [9]=&gt; int(4) ["c"]=&gt; int(5) &#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>非正常值作为键名</p>
<ol>
<li>使用true作为键名即使用1为键名，使用false作为键名即使用0作为键名</li>
<li>使用小数作为键名时，自动截断小数部分</li>
</ol>
</blockquote>
<ul>
<li>多维数组</li>
</ul>
<p>包含一个或多个数组的数组</p>
<h3 id="数组函数"><a href="#数组函数" class="headerlink" title="数组函数"></a>数组函数</h3><ul>
<li>获得数组的长度</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$arr2_len=count($arr2);</span><br><span class="line"><span class="keyword">echo</span> $arr2_len;<span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<ul>
<li>判断数据类型是否为数组</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">"is_array"</span>.is_array($arr2);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>删除数组的任意个键值，但不会重建索引</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$arr3 = <span class="keyword">array</span>(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>);</span><br><span class="line"><span class="keyword">unset</span>($arr3[<span class="number">0</span>],$arr3[<span class="number">1</span>]);</span><br><span class="line">print_r($arr3);<span class="comment">//Array ( [2] =&gt; c [3] =&gt; d )</span></span><br></pre></td></tr></table></figure>

<ul>
<li>遍历数组</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span> ($arr1 <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"$key=$value"</span>;<span class="comment">//a=1b=2c=3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#for循环只能用于遍历索引数组</span></span><br><span class="line"><span class="keyword">for</span> ($i=<span class="number">0</span>; $i &lt; $arr2_len; $i++) &#123; </span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"$arr2[$i]"</span>;<span class="comment">//遍历关联数组输出报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>数组排序</p>
<ul>
<li>索引数组<ul>
<li>sort() - 以升序对数组排序</li>
<li>rsort() - 以降序对数组排序</li>
</ul>
</li>
<li>关联数组<ul>
<li>asort() - 根据值，以升序对关联数组进行排序</li>
<li>ksort() - 根据键，以升序对关联数组进行排序</li>
<li>arsort() - 根据值，以降序对关联数组进行排序</li>
<li>krsort() - 根据键，以降序对关联数组进行排序</li>
</ul>
</li>
<li>冒泡排序 - bubbleSort();</li>
<li>选择排序 - selectSort();</li>
<li>插入排序 - insertSort();</li>
</ul>
</li>
</ul>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><ul>
<li>定义</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可采用直接定义或单个元素定义，每一行数组个数可以不同</span></span><br><span class="line">$arr4 = <span class="keyword">array</span>(</span><br><span class="line"><span class="keyword">array</span>(<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>),</span><br><span class="line"><span class="keyword">array</span>(<span class="string">'11'</span>,<span class="string">'21'</span>,<span class="string">'25'</span>),</span><br><span class="line"><span class="keyword">array</span>(<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>),</span><br><span class="line"><span class="keyword">array</span>(<span class="string">'10'</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line">$arr4[<span class="number">0</span>] = <span class="keyword">array</span>(<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>);</span><br><span class="line">$arr4[<span class="number">1</span>] = <span class="keyword">array</span>(<span class="string">'11'</span>,<span class="string">'21'</span>,<span class="string">'25'</span>);</span><br><span class="line">$arr4[<span class="number">2</span>] = <span class="keyword">array</span>(<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>);</span><br><span class="line">$arr4[<span class="number">3</span>] = <span class="keyword">array</span>(<span class="string">'10'</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>遍历二维数组</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ($i=<span class="number">0</span>; $i &lt; count($arr4); $i++) &#123; </span><br><span class="line">	<span class="keyword">for</span> ($j=<span class="number">0</span>; $j &lt; count($arr4[$i]); $j++) &#123; </span><br><span class="line">		<span class="keyword">echo</span> $arr4[$i][$j].<span class="string">"&amp;nbsp;"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">1 2 3 4 5 </span></span><br><span class="line"><span class="comment">11 21 25 </span></span><br><span class="line"><span class="comment">1 2 3 4 5 </span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


<h2 id="PHP内存模型"><a href="#PHP内存模型" class="headerlink" title="PHP内存模型"></a>PHP内存模型</h2><h3 id="栈区：存放基本数据类型"><a href="#栈区：存放基本数据类型" class="headerlink" title="栈区：存放基本数据类型"></a>栈区：存放基本数据类型</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#a和b都是存放在栈区不同地址空间的变量，其保存的值都为int型整数，a赋值给b时将0这一值赋给b的内存空间，因此对b的操作不会影响a的值</span></span><br><span class="line">$a=<span class="number">0</span>;</span><br><span class="line">$b=$a;</span><br><span class="line">$b++;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"$a/$b"</span>;<span class="comment">//0/1</span></span><br><span class="line"><span class="comment">#当把a的地址赋给b之后，b的内存空间存放的即为a的地址，对b的操作实际上是对a地址的操作，即对a的值的操作</span></span><br><span class="line">$b=&amp;$a;</span><br><span class="line">$b++;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"$a/$b"</span>;<span class="comment">//1/1</span></span><br></pre></td></tr></table></figure>

<h3 id="堆区：存放对象"><a href="#堆区：存放对象" class="headerlink" title="堆区：存放对象"></a>堆区：存放对象</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> $name;</span><br><span class="line">	<span class="keyword">public</span> $age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#p1变量存放在栈中，p1对象存放在堆中</span></span><br><span class="line">$p1=<span class="keyword">new</span> Person;</span><br><span class="line"><span class="comment">#p1通过地址引用访问堆中对象的成员变量</span></span><br><span class="line">$p1-&gt;name=<span class="string">"Jack"</span>;</span><br><span class="line">$p1-&gt;age=<span class="number">20</span>;</span><br><span class="line"><span class="comment">#调用函数时，栈区会开辟一片新栈，存放p变量，p和p1分别位于栈区不同的地址空间，但是其中保存的值相同，都指向堆中p1对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change_name</span><span class="params">($p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	$p-&gt;name=<span class="string">"Tom"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"$p1-&gt;name"</span>;<span class="comment">//Jack</span></span><br><span class="line">change_name($p1);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"$p1-&gt;name"</span>;<span class="comment">//Tom</span></span><br></pre></td></tr></table></figure>

<h3 id="全局区（静态数据区）"><a href="#全局区（静态数据区）" class="headerlink" title="全局区（静态数据区）"></a>全局区（静态数据区）</h3><ul>
<li>存放global关键字修饰的全局变量，全局变量在所有的栈中都可以访问</li>
<li>存放static关键字修饰的成员变量，一次创建，不随着对象的销毁而销毁</li>
</ul>
<h3 id="常量区：存放常量"><a href="#常量区：存放常量" class="headerlink" title="常量区：存放常量"></a>常量区：存放常量</h3><ul>
<li>存放常量，const关键字修饰的常量，声明时就要赋初值<h3 id="代码区：存放指令"><a href="#代码区：存放指令" class="headerlink" title="代码区：存放指令"></a>代码区：存放指令</h3></li>
</ul>
<hr />
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP学习笔记4</title>
    <url>/php4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>PHP中的异常处理（广义）和其他语言有些不同，在PHP中，最初时没有异常处理机制的，只有自身的错误处理机制，用来处理脚本编译运行过程中出现的语法错误和运行环境问题，根据错误的严重程度分为不同的级别；后来在引入异常处理机制的过程中为了和已有的错误处理机制不冲突，就将PHP中的异常处理设定为只能捕获用户自定义的异常，而对于编译过程中的语法问题，PHP默认由自身的错误处理机制处理，用户无法进行捕获，这样两种机制各司其职，分别应对不同的情况。相比于其它语言中将所有运行中的错误都当做异常来处理，PHP的异常处理机制学习起来较为繁琐。</p>
<a id="more"></a>

<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="错误级别"><a href="#错误级别" class="headerlink" title="错误级别"></a>错误级别</h3><table>
<thead>
<tr>
<th align="center">值</th>
<th align="center">常量名</th>
<th align="center">描述</th>
<th align="center">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">E_ERROR</td>
<td align="center">这类错误一般不可恢复，例如内存分配导致的问题。导致脚本终止不再继续运行。</td>
<td align="center">Error：Invalid parameters. Invalid parameter name</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">E_WARNING</td>
<td align="center">运行时警告 (非致命错误)。脚本不会终止运行。</td>
<td align="center">Warning: require_once</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">E_PARSE</td>
<td align="center">编译时语法解析错误。如字符、变量或结束的地方写规范有误。</td>
<td align="center">Parse error: syntax error, unexpected $end in</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">E_NOTICE</td>
<td align="center">运行时通知。如变量未定义等。</td>
<td align="center">Notice: Undefined variable: p in E:index.php on line 17</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">E_CORE_ERROR</td>
<td align="center">在PHP初始化启动过程中发生的致命错误。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">32</td>
<td align="center">E_CORE_WARNING</td>
<td align="center">PHP初始化启动过程中发生的警告 (非致命错误) 。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">64</td>
<td align="center">E_COMPILE_ERROR</td>
<td align="center">致命编译时错误。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">128</td>
<td align="center">E_COMPILE_WARNING</td>
<td align="center">编译时警告 (非致命错误)。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">256</td>
<td align="center">E_USER_ERROR</td>
<td align="center">用户产生的错误信息。由用户使用PHP函数 trigger_error() 产生。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">512</td>
<td align="center">E_USER_WARNING</td>
<td align="center">用户产生的警告信息。由用户使用PHP函数 trigger_error() 产生。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1024</td>
<td align="center">E_USER_NOTICE</td>
<td align="center">用户产生的通知信息。由用户使用PHP函数 trigger_error() 产生。</td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="三种错误处理方式"><a href="#三种错误处理方式" class="headerlink" title="三种错误处理方式"></a>三种错误处理方式</h3><ul>
<li>die函数</li>
</ul>
<blockquote>
<p>die()语句，可以输出提示信息后退出，不再执行之后的代码</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!file_exists(<span class="string">"filename"</span>)) &#123;</span><br><span class="line">	<span class="comment">#die("diediedie");//diediedie</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#简洁写法</span></span><br><span class="line">file_exists(<span class="string">"filename"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"over"</span>);<span class="comment">//over</span></span><br></pre></td></tr></table></figure>

<ul>
<li>自定义错误处理</li>
</ul>
<p>1.自定义错误处理器，用于处理系统错误</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建自定义错误函数（处理器）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my_error</span><span class="params">($error_level,$error_mess)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"	&lt;font size='5' color='red'&gt;$error_level&lt;/font&gt;&lt;br/&gt;"</span>;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"错误信息:$error_mess"</span>;</span><br><span class="line">	<span class="keyword">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#改写回调函数 set_error_handler 处理器，改变系统默认的错误处理函数</span></span><br><span class="line"><span class="comment">#第一个参数是错误函数名，第二个参数是错误级别</span></span><br><span class="line">set_error_handler(<span class="string">"my_error"</span>,E_WARNING);</span><br><span class="line"></span><br><span class="line"><span class="comment">#$fp=fopen("aaa.php", "r");//2(5号红色字体) 错误信息:fopen(aaa.php): failed to open stream: No such file or directory</span></span><br></pre></td></tr></table></figure>

<p>2.自定义错误触发器，用于处理逻辑错误</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#trigger_error("业务逻辑不合理");//Notice: 业务逻辑不合理 in F:\work\php_workspace\错误异常处理1.php on line 59</span></span><br><span class="line"><span class="comment">#创建自定义错误函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my_error2</span><span class="params">($error_level,$error_mess)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"&lt;font size='3' color='green'&gt;$error_level&lt;/font&gt;&lt;br/&gt;"</span>;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"错误信息:$error_mess"</span>;</span><br><span class="line">	<span class="keyword">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#设置修改系统默认的错误触发器</span></span><br><span class="line">set_error_handler(<span class="string">"my_error2"</span>,E_USER_NOTICE);</span><br><span class="line">trigger_error(<span class="string">"业务逻辑不合理"</span>);<span class="comment">//1024(3号绿色字体) 错误信息:业务逻辑不合理</span></span><br><span class="line"><span class="comment">#注意，trigger_error默认的错误级别是E_USER_NOTICE，，当set_error_handler设置的错误级别不是E_USER_NOTICE时，trigger_error函数需要指明</span></span><br><span class="line">set_error_handler(<span class="string">"my_error2"</span>,E_USER_WARNING);</span><br><span class="line">trigger_error(<span class="string">"业务逻辑不合理"</span>,E_USER_WARNING);<span class="comment">//512(3号绿色字体) 错误信息:业务逻辑不合理</span></span><br></pre></td></tr></table></figure>

<div class="note info"><p>总结，自定义错误处理时需要厘清以下要点：
1. 自定义的错误属于系统错误还是业务逻辑错误，前者采用错误处理器，使用不带_USER的错误级别；后者采用错误触发器，使用带_USER的错误级别
2. 需要输出哪些错误信息和说明
3. 错误的严重程度如何，发生错误提示后是否还要继续执行之后的代码，即是否用exit函数中断程序

</p></div>

<ul>
<li>错误日志</li>
</ul>
<p>PHP支持向服务器的错误记录系统或文件发送错误日志，包括本地保存和远程发送，默认错误日志输出信息的在php.in中的error_log配置，也可以通过在自定义错误函数中设置error_log()函数实现</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my_error3</span><span class="params">($error_level,$error_mess)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	date_default_timezone_set(<span class="string">"PRC"</span>);</span><br><span class="line">	$error_info=<span class="string">"错误时间："</span>.date(<span class="string">"Y-m-d G:i:s"</span>).<span class="string">"\t错误号："</span>.$error_level.<span class="string">"--"</span>.$error_mess;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"错误信息已保存至\myerror.txt"</span>;</span><br><span class="line">	<span class="comment">#第一个参数是要输出的错误信息，第二个参数是错误信息发送位置，第三个参数取决于第二个参数，设置发送的目的地地址</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	0 message 发送到 PHP 的系统日志，使用操作系统的日志机制或者一个文件，取决于 error_log 指令设置了什么。这是个默认的选项。  </span></span><br><span class="line"><span class="comment">	1 message 发送到参数 destination 设置的邮件地址。第四个参数 extra_headers 只有在这个类型里才会被用到。  </span></span><br><span class="line"><span class="comment">	2 不再是一个选项。  </span></span><br><span class="line"><span class="comment">	3 message 被发送到位置为 destination 的文件里。字符 message 不会默认被当做新的一行。  </span></span><br><span class="line"><span class="comment">	4 message 直接发送到 SAPI 的日志处理程序中。  </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	error_log($error_info.<span class="string">"\r\n"</span>,<span class="number">3</span>,<span class="string">"myerror.txt"</span>);</span><br><span class="line">	<span class="keyword">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line">set_error_handler(<span class="string">"my_error3"</span>,E_USER_WARNING);</span><br><span class="line">trigger_error(<span class="string">"错误日志测试"</span>,E_USER_WARNING);<span class="comment">//错误信息已保存至\myerror.txt</span></span><br><span class="line"><span class="comment">#当前文件目录下的myerror.txt文件追加信息：错误号是：512--错误日志测试</span></span><br></pre></td></tr></table></figure>

<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><p>该语句用于在指定错误发生时改变脚本的正常流程，可以有效的控制错误</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">($a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ($a) &#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"a"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">#抛出异常，第一个参数是异常信息，第二个参数为用户自定义异常编码，默认为0</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">"a Error"</span>, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span><span class="params">($b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ($b) &#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"b"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">#抛出异常</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">"b Error"</span>, <span class="number">2</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"enter"</span>;<span class="comment">//输出</span></span><br><span class="line">	f1(<span class="number">1</span>);<span class="comment">//a</span></span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"stop"</span>;<span class="comment">//输出</span></span><br><span class="line">	<span class="comment">#当异常被抛出后代码不会继续执行，PHP会尝试查找匹配的代码块</span></span><br><span class="line">	f2(<span class="number">0</span>);<span class="comment">//code:2 message:b Error line:26 file:F:\work\php_workspace\错误异常处理2.php</span></span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"end"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 捕获try中的潜在异常，可以使用多个catch块捕获多种异常</span></span><br><span class="line"><span class="keyword">catch</span>(<span class="keyword">Exception</span> $e)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">#捕获后的异常如果有能力处理，可以在此处处理</span></span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"code:"</span>.$e-&gt;getCode();</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"message:"</span>.$e-&gt;getMessage();</span><br><span class="line">	<span class="comment">#异常抛出位置</span></span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"line:"</span>.$e-&gt;getLine();</span><br><span class="line">	<span class="comment">#异常抛出文件及路径</span></span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"file:"</span>.$e-&gt;getFile();</span><br><span class="line"></span><br><span class="line">	<span class="comment">#捕获后的异常也可以继续抛出，直到系统默认的顶级异常处理器处理</span></span><br><span class="line">	<span class="comment">#throw $e;//Fatal error: Uncaught Exception</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">#异常处理完后执行代码</span></span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"finally codes"</span>;<span class="comment">//最后输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="顶级异常处理器"><a href="#顶级异常处理器" class="headerlink" title="顶级异常处理器"></a>顶级异常处理器</h3><p>对于当前代码段抛出后未捕获的异常会继续向上抛出，直到被PHP默认的顶级异常处理器捕获，用户也可以自己定义自己的顶级异常处理器</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#自定义一个顶级异常处理器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my_exception</span><span class="params">($e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"我的顶级异常处理器"</span>.$e-&gt;getMessage();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#修改默认的顶级异常处理函数</span></span><br><span class="line">set_exception_handler(<span class="string">"my_exception"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">#f2(0);//我的顶级异常处理器b Error</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> $e) &#123;</span><br><span class="line">	<span class="keyword">throw</span> $e;</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">#PHP不会自动抛出异常，错误代码会自动调用错误处理机制</span></span><br><span class="line">	$a=<span class="number">1</span>/<span class="number">0</span>;<span class="comment">//报错 Warning: Division by zero</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> $e) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"err"</span>;<span class="comment">//不输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr />
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>错误处理</tag>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP面向对象学习笔记1</title>
    <url>/php5.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>编程语言在发展过程中大致经历了三个阶段，早期开发面临的情况是简单重复的科学计算，机械笨重的硬件平台，因此编程语言要尽可能的贴近底层，便于开发。随着软硬件技术水平的进步，编程语言也取得了长足的发展，从最初面向机器的汇编语言，到后来面向过程的C语言（封装函数，便于功能的复用），再到现在面向对象的java、PHP（封装对象，便于组建的复用），编程语言越来越接近自然语言和自然人的思维方式，这一改变大大降低了编程语言学习的门槛。可以展望，在不远的未来，我们很有可能用自然语言去编写程序，正是这样一层一层的封装，把内部结构包裹起来，只暴露外部接口，将我们的开发过程和底层隔离开，因此抽象和封装是现代编程语言最重要的特点，也是现代社会运行分工协作的方式。</p>
<a id="more"></a>

<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><div class="note info"><p>请将本标题下的所有代码段链接起来学习理解。</p></div>

<h3 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h3><ul>
<li>成员属性，可以是基本数据类型或符合数据类型</li>
<li>构造方法，默认的访问修饰符是<strong>public</strong></li>
<li>析构方法，主要作用是释放资源，例如数据库连接，图片资源等，并非销毁对象本身（即无默认的析构方法）</li>
<li>成员方法，默认的访问修饰符是<strong>public</strong></li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="comment">#成员属性</span></span><br><span class="line">	<span class="keyword">public</span> $kind;</span><br><span class="line">	<span class="keyword">public</span> $number;</span><br><span class="line">	<span class="comment">#构造方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($kind,$number)</span></span>&#123;</span><br><span class="line">		<span class="comment">#this代表当前对象,实质上是对当前对象的引用,只能在构造方法中使用</span></span><br><span class="line">		<span class="comment">#创建对象时默认先调用对象的构造方法,假设没定义,系统默认提供空构造方法,this会通过对象变量名所保存的地址去堆区的对象出做初始化操作</span></span><br><span class="line">		<span class="keyword">$this</span>-&gt;kind=$kind;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;number=$number;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">#析构方法</span></span><br><span class="line">	<span class="comment">#一个类只有一个析构函数，且该方法不能传递参数</span></span><br><span class="line">	<span class="comment">#程序退出（进程结束）或该对象成为垃圾对象（一个对象没有任何引用指向他）时自动调用，同一类的不同对象的调用顺序是先创建的对象后被销毁（栈的FILO机制）</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"$this-&gt;kind被销毁"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">#成员方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"walking"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">eat</span><span class="params">($food)</span></span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"eating"</span>.$food;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对象的基本创建（实例化），后面括号可选 new</span></span><br><span class="line">$cat=<span class="keyword">new</span> Animal(<span class="string">"未定义"</span>,<span class="number">0</span>);<span class="comment">//construct method</span></span><br><span class="line">$dog=<span class="keyword">new</span> Animal(<span class="string">"未定义"</span>,<span class="number">0</span>);<span class="comment">//construct method</span></span><br><span class="line">var_dump($cat);<span class="comment">//object(Animal)#2 (2) &#123; ["kind"]=&gt; string(9) "未定义" ["number"]=&gt; int(0) &#125;</span></span><br><span class="line">var_dump($dog);<span class="comment">//object(Animal)#2 (2) &#123; ["kind"]=&gt; string(9) "未定义" ["number"]=&gt; int(0) &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="访问对象"><a href="#访问对象" class="headerlink" title="访问对象"></a>访问对象</h3><ul>
<li>访问对象的属性 <strong>-&gt;</strong></li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$cat-&gt;kind=<span class="string">"猫科"</span>;</span><br><span class="line">$cat-&gt;number=<span class="number">2</span>;</span><br><span class="line">$dog-&gt;kind=<span class="string">"犬科"</span>;</span><br><span class="line">$dog-&gt;number=<span class="number">3</span>;</span><br><span class="line">var_dump($cat);<span class="comment">//object(Animal)#1 (2) &#123; ["kind"]=&gt; string(6) "猫科" ["number"]=&gt; int(2) &#125;</span></span><br><span class="line">var_dump($dog);<span class="comment">//object(Animal)#1 (2) &#123; ["kind"]=&gt; string(6) "猫科" ["number"]=&gt; int(2) &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>访问对象的方法 <strong>-&gt;</strong></li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$cat-&gt;walk();<span class="comment">//walking</span></span><br><span class="line">$cat-&gt;eat(<span class="string">" meat"</span>);<span class="comment">//eating meat</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>对象的内存模型</strong><br>对象创建时在栈中存放变量名同时在堆中开辟空间用于存放真正的对象，变量名保存的是指向堆中对象位置的地址，因此PHP当中对象是按引用传递的，每个对象的变量都持有对象的引用，而非对象的拷贝</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$tiger=$cat;</span><br><span class="line"><span class="keyword">echo</span> $tiger-&gt;kind;<span class="comment">//猫科</span></span><br></pre></td></tr></table></figure>

<h2 id="静态变量和静态方法"><a href="#静态变量和静态方法" class="headerlink" title="静态变量和静态方法"></a>静态变量和静态方法</h2><ul>
<li>静态变量 <strong>static</strong> 与其相对的成为实例变量，同一个类的所有对象都共享的变量</li>
<li>类外部可以直接用类名访问静态变量，意味着静态变量不依赖于对象而存在</li>
<li>静态方法（类方法） <strong>static</strong> 不能访问非静态属性，普通成员方法可以访问静态变量和非静态变量</li>
<li>类外部可以直接用类名访问静态方法，意味着静态变量不依赖于对象而存在</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> $name;</span><br><span class="line">	<span class="comment">#定义并初始化一个静态变量，定义位置在常量区</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> $num = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($name)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;name=$name;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;num=<span class="number">20</span>;<span class="comment">//访问方式错误，但是不创建对象不会报错，说明PHP是运行时才执行的语言</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">#定义一个静态方法</span></span><br><span class="line">	<span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">get_num</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="keyword">self</span>::$num;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">#类内部访问静态变量，两种访问方式</span></span><br><span class="line">		People::$num++;</span><br><span class="line">		<span class="keyword">self</span>::$num++;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;name.<span class="string">"加入"</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">#类内部访问静态方法</span></span><br><span class="line">		<span class="keyword">self</span>::get_num();<span class="comment">//2</span></span><br><span class="line">		People::get_num();<span class="comment">//2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">$p1 = <span class="keyword">new</span> People(<span class="string">"Tom"</span>);</span><br><span class="line">$p1-&gt;add();<span class="comment">//22</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#类外部访问静态变量</span></span><br><span class="line"><span class="keyword">echo</span> People::$num;<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#类外部访问静态方法</span></span><br><span class="line">$p1-&gt;get_num();<span class="comment">//6</span></span><br><span class="line"><span class="comment">#直接用类名访问静态方法，意味着静态变量不依赖于对象而存在</span></span><br><span class="line">People::get_num();<span class="comment">//6</span></span><br></pre></td></tr></table></figure>

<hr />
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>类</tag>
        <tag>静态方法</tag>
        <tag>静态变量</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP面向对象学习笔记2</title>
    <url>/php6.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>任何一种面向对象的编程语言，无一例外的都要支持封装、继承、多态三大特性。所谓封装，即上一节所谈到的抽象原则的事项方法：提取一类事物的共有属性和行为，形成一个物理模型。java和PHP都是提供类来作为封装的基础组件，而C++中则提供了namespace和类两种设施用于实现封装；而继承，则是对应于自然社会中同类事物的不同特质，复用同类事物的相同特性，从而提升开发效率；多态表现出同类事物在某个行为上的不同表现，PHP对多态的支持力度尚不及java，在方法重载上需要借助魔术函数来实现。类似的，PHP也提供了抽象类和接口来支持面向对象风格程序的开发。</p>
<a id="more"></a>

<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ol>
<li>把抽象出来的数据和操作封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作（成员方法）才能对数据进行操作，这样有利于对访问权限做判断，或根据参数对数据做处理</li>
<li>访问形式是通过get和set方法访问私有变量，类似javabean的写法；同时PHP提供了魔术方法__set和__get管理所有的私有变量，但是不推荐使用这种方式，他破坏了私有变量的封装性，且不同私有变量无法进行不同处理</li>
</ol>
<blockquote>
<p>访问控制修饰符</p>
<ul>
<li>PHP提供了三种访问控制修饰符** public private protected** 均可以用于修饰变量和方法（静态或非静态）</li>
<li>默认的访问修饰符是 <strong>public</strong></li>
</ul>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="comment">#表示全局，内部、外部、子类都可以访问</span></span><br><span class="line">	<span class="keyword">public</span> $name;</span><br><span class="line">	<span class="comment">#表示私有，只有类的内部可以访问</span></span><br><span class="line">	<span class="keyword">private</span> $age;</span><br><span class="line">	<span class="comment">#表示受保护，可以在本类和子类中访问</span></span><br><span class="line">	<span class="keyword">protected</span> $address;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($name,$age,$address)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;name=$name;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;age=$age;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;address=$address;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;name.<span class="string">"|"</span>.<span class="keyword">$this</span>-&gt;age.<span class="string">"|"</span>.<span class="keyword">$this</span>-&gt;address.<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">#成员方法之间可以相互调用，但必须通过this关键字</span></span><br><span class="line">		<span class="keyword">$this</span>-&gt;show();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">#魔术方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__set</span><span class="params">($pro_name,$pro_val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;pro_name=$pro_val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span><span class="params">($pro_name)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">isset</span>($pro_name)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">$this</span>-&gt;pro_name;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">$p1=<span class="keyword">new</span> Person(<span class="string">"john"</span>,<span class="number">20</span>,<span class="string">"shanghai"</span>);</span><br><span class="line">$p1-&gt;show();<span class="comment">//报错 Call to private method 私有方法不能直接访问</span></span><br><span class="line">$p1-&gt;show1();<span class="comment">//john|20|shanghai 通过成员方法访问</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"$p1-&gt;age"</span>;<span class="comment">//报错，Cannot access private property 私有变量不能直接访问</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"$p1-&gt;address"</span>;<span class="comment">//报错，Cannot access protected property 受保护变量不能直接访问</span></span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li>通过 <strong>extends</strong> 关键字实现继承</li>
<li>PHP只支持单继承，即一个子类只能继承一个父类（直接继承），但通过多重继承可以实现多继承</li>
<li>继承时只能继承父类的public和protected属性和方法，不能继承父类的私有属性和方法</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> $name;</span><br><span class="line">	<span class="keyword">protected</span> $age;</span><br><span class="line">	<span class="keyword">protected</span> $address;</span><br><span class="line">	<span class="keyword">private</span> $kind = <span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($name,$age,$address)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;name=$name;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;age=$age;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;address=$address;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;name.<span class="string">"|"</span>.<span class="keyword">$this</span>-&gt;age.<span class="string">"|"</span>.<span class="keyword">$this</span>-&gt;address.<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pupil</span> <span class="keyword">extends</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show_kind</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"show_kind"</span>.<span class="keyword">$this</span>-&gt;kind;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graduate</span> <span class="keyword">extends</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($name,$age,$address)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"子类的构造方法"</span>;</span><br><span class="line">		<span class="comment">#两种方式显示的调用父类的构造函数，普通方法同样采用这种方法</span></span><br><span class="line">		<span class="comment">#Student::__construct($name,$age,$address);</span></span><br><span class="line">		<span class="comment">#parent不能大写</span></span><br><span class="line">		<span class="keyword">parent</span>::__construct($name,$age,$address);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$p1-&gt;show_kind();<span class="comment">//报错 Undefined property 没有继承父类的kind属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#子类没有定义构造函数时默认继承父类的构造函数</span></span><br><span class="line">$p1=<span class="keyword">new</span> Pupil(<span class="string">"tom"</span>,<span class="number">12</span>,<span class="string">"beijing"</span>);</span><br><span class="line">$p1-&gt;show();<span class="comment">//tom|12|beijing</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#子类定义构造函数时默认运行子类的构造方法</span></span><br><span class="line">$g1=<span class="keyword">new</span> Graduate(<span class="string">"john"</span>,<span class="number">22</span>,<span class="string">"shanghai"</span>);</span><br><span class="line">$g1-&gt;show();<span class="comment">//子类的构造方法john|22|shanghai</span></span><br></pre></td></tr></table></figure>

<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="方法重载（overload）"><a href="#方法重载（overload）" class="headerlink" title="方法重载（overload）"></a>方法重载（overload）</h3><p>方法重载指的是同一个类中的相同函数名、不同参数个数或类型的函数，在调用时通过参数的不同来区分</p>
<div class="note warning"><p>PHP中默认不支持方法重载，需要通过魔术函数**__call**来实现。</p></div>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="comment"># java的方法重载写法</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	public function eating()</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		echo "eating";</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	public function eating($food)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		echo "eating".$food;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment"># PHP的方法重载写法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">eat0</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"eating"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">eat1</span><span class="params">($food)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"eating"</span>.$food;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">#魔术函数 __call 模拟方法重载</span></span><br><span class="line">	<span class="comment">#一个对象调用某个不存在的方法时，系统会自动调用__call方法</span></span><br><span class="line">	<span class="comment">#第一个参数是函数名，第二个参数是函数参数，以数组形式传递</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">__call</span><span class="params">($method,$p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> ($method==<span class="string">"eat"</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (count($p)==<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">$this</span>-&gt;eat0();</span><br><span class="line">			&#125;<span class="keyword">elseif</span> (count($p)==<span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">$this</span>-&gt;eat1($p[<span class="number">0</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$p1=<span class="keyword">new</span> People;</span><br><span class="line"><span class="comment"># java的方法重载调用方法</span></span><br><span class="line"><span class="comment"># $p1-&gt;eating();</span></span><br><span class="line"><span class="comment"># $p1-&gt;eating("bread");//Cannot redeclare People::eat() 不支持这种重载方式</span></span><br><span class="line"><span class="comment"># php的方法重载调用方法</span></span><br><span class="line">$p1-&gt;eat();<span class="comment">//eating</span></span><br><span class="line">$p1-&gt;eat(<span class="string">"bread"</span>);<span class="comment">//eatingbread</span></span><br></pre></td></tr></table></figure>

<h3 id="方法重写（overwrite）"><a href="#方法重写（overwrite）" class="headerlink" title="方法重写（overwrite）"></a>方法重写（overwrite）</h3><p>方法重写（方法覆盖）指的是父类的方法在子类中不同的实现，要求方法名和参数完全相同，访问修饰符可以不同，但必须满足子类的访问范围&gt;=父类的访问范围</p>
<ul>
<li>子类父类都是private修饰的相同方法也不能覆盖，因为覆盖的前提是继承父类，私有方法不能继承</li>
<li>所谓的覆盖并非完全覆盖，而是父类子类中方法名和参数相同时优先调用子类中的方法</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> $name;</span><br><span class="line">	<span class="keyword">protected</span> $price;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($name,$price)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;name=$name;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;price=$price;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"unknow"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"wang"</span>;</span><br><span class="line">		<span class="comment">#覆盖后依然可以显式的调用父类的方法</span></span><br><span class="line">		<span class="keyword">parent</span>::speak();<span class="comment">//unknow</span></span><br><span class="line">		Animal::speak();<span class="comment">//unknow</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"miao"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">$d1=<span class="keyword">new</span> Dog(<span class="string">"mimi"</span>,<span class="number">250</span>);</span><br><span class="line">$c1=<span class="keyword">new</span> Cat(<span class="string">"sunge"</span>,<span class="number">2050</span>);</span><br><span class="line">$d1-&gt;speak();<span class="comment">//wang</span></span><br><span class="line">$c1-&gt;speak();<span class="comment">//miao</span></span><br></pre></td></tr></table></figure>

<h2 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h2><h3 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h3><ul>
<li>抽象类用于不需要被实例化的类，主要为了让子类去实现</li>
<li>被abstract修饰的类就是抽象类，可以包含抽象方法或普通方法</li>
<li>被abstract修饰的方法就是抽象方法，抽象方法不能包含方法体，用分号结尾</li>
<li>含有的抽象方法的类就是抽象类，必须用abstract修饰</li>
<li>一个类继承了抽象类之后必须实现所有的抽象方法，除非该类也是抽象类</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义一个抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="comment">#创建一个好凑想方法</span></span><br><span class="line">	<span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#继承抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="comment">#实现抽象方法</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">b</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"b"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">$c1=<span class="keyword">new</span> C;</span><br><span class="line">$c1-&gt;b();<span class="comment">//b</span></span><br></pre></td></tr></table></figure>

<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>接口用于定义规范（方法、属性），实现高内聚低耦合</li>
<li>定义接口使用 <strong>interface</strong> 关键字，实现接口使用 <strong>implements</strong> 关键字</li>
<li>一个类可以实现多个接口</li>
<li>实现接口时类必须实现接口及其该接口所继承的其他接口中的所有抽象方法</li>
</ul>
<blockquote>
<p>使用场景：<br>定规范<br>团队合作写代码<br>多个平级的类都要实现某个功能，但实现方式不同</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">D</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="comment">#接口中可以有属性，要求必须是公开的常量</span></span><br><span class="line">	<span class="comment">#默认的方法修饰符是public</span></span><br><span class="line">	<span class="keyword">const</span> D1 = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">#接口中的方法都不能有方法体</span></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">e</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">($g,$h)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">D2</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">I</span> <span class="keyword">implements</span> <span class="title">D</span>,<span class="title">D2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">e</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"e"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">($g,$h)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"f"</span>.$g.$h;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">$i1=<span class="keyword">new</span> I;</span><br><span class="line"><span class="keyword">echo</span> D::D1;<span class="comment">//0</span></span><br><span class="line">$i1-&gt;e();<span class="comment">//e</span></span><br><span class="line">$i1-&gt;f(<span class="string">"gg"</span>,<span class="string">"hh"</span>);<span class="comment">//fgghh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#接口之间可以多继承</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">J</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">K</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">L</span> <span class="keyword">extends</span> <span class="title">J</span>,<span class="title">K</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>补充说明：</p>
<ul>
<li>一个类可以同时继承抽象类和实现接口</li>
<li>实现接口是对单一继承的补充</li>
<li>可以在不破坏类层级关系的前提下对某个类功能扩展</li>
</ul>
</blockquote>
<h3 id="静态关键字"><a href="#静态关键字" class="headerlink" title="静态关键字"></a>静态关键字</h3><ul>
<li>final</li>
</ul>
<blockquote>
<ol>
<li>如果父类中的方法被声明为final，则子类无法覆盖此方法</li>
<li>如果一个类被声明为final，则这个类不能被继承</li>
<li>需求：出于安全考虑，不希望自己写的类被继承或自己写的方法被改写</li>
<li>final不能修饰属性</li>
</ol>
</blockquote>
<ul>
<li>const</li>
</ul>
<blockquote>
<ol>
<li>用于修饰成员变量，使得变量无法被修改</li>
<li>定义常量，定义初始就要赋初值，否则会报错；前面不要加修饰符（默认为public），否则也会报错</li>
</ol>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> Con = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_con</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="keyword">self</span>::Con;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">N</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> Cons = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#访问常量</span></span><br><span class="line"><span class="keyword">echo</span> M::Con;<span class="comment">//0</span></span><br><span class="line"><span class="keyword">echo</span> N::Cons;<span class="comment">//1</span></span><br><span class="line">$m1=<span class="keyword">new</span> M;</span><br><span class="line">$m1-&gt;get_con();<span class="comment">//0</span></span><br></pre></td></tr></table></figure>


<hr />
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>封装</tag>
        <tag>继承</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP数据库编程学习笔记1</title>
    <url>/php7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数据库软件是位于操作系统之上对数据提供持久化支持的主要程序，在软件编程中有着广泛的应用，主要分为三层结构，分别是客户端（面向应用软件所提供的接口），数据库管理系统DBMS（mysql，Oracle，SQL server等）和数据对象（表，存储过程，函数等）。<br>由于历史的原因，PHP在初期并没有对面向对象编程风格太多支持，而在后期转向面向对象的过程中为了向下兼容，PHP在数据库的连接方面保留了不同的扩展库。以mysql数据库的连接为例，PHP提供了三种扩展库，用来支持不同的编程风格，PHP通过扩展库中的函数操作数据库。其中mysql扩展库最早，主要支持面向过程的编程风格，最新的PHP7中以及不再支持该扩展库，取而代之的是mysqli扩展库。</p>
<a id="more"></a>

<h2 id="mysql扩展库调用过程"><a href="#mysql扩展库调用过程" class="headerlink" title="mysql扩展库调用过程"></a>mysql扩展库调用过程</h2><div class="note info"><p>请将本标题下的所有代码段链接起来学习理解。</p></div>

<h3 id="获取连接"><a href="#获取连接" class="headerlink" title="获取连接"></a>获取连接</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 连接参数：IP+端口（默认3306），用户名，密码</span></span><br><span class="line">$conn=mysql_connect(<span class="string">"127.0.0.1"</span>,<span class="string">"root"</span>,<span class="string">"mysql"</span>);</span><br><span class="line"><span class="keyword">if</span> ($conn) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment"># 返回错误信息</span></span><br><span class="line">	<span class="keyword">die</span>(<span class="string">"failure"</span>.mysql_error());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">mysql_select_db(<span class="string">"dbname"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(mysql_error());</span><br></pre></td></tr></table></figure>

<h3 id="设置操作编码"><a href="#设置操作编码" class="headerlink" title="设置操作编码"></a>设置操作编码</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#保证PHP程序按照utf8操作</span></span><br><span class="line">mysql_query(<span class="string">"set names utf8"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="发送sql指令"><a href="#发送sql指令" class="headerlink" title="发送sql指令"></a>发送sql指令</h3><p>SQL指令分为四类：其中ddl（数据定义语句）一般在数据库建库时使用，很少通过应用软件连接数据库发送指令更改数据库、表和字段的属性；而dtl数据事务语句在mysql扩展库中并没有函数支持，而是通过发送SQL指令实现，进而在mysqli扩展库中增加了事务处理的相关函数。</p>
<ul>
<li>dml</li>
</ul>
<p>数据操作语句，包括 update insert delete</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$sql=<span class="string">"insert into tablename(key1,key2,key3,key4) values('value1','value2','value3','value4') "</span></span><br><span class="line"><span class="comment">### 注意在插入密码时，最好使用md5()进行加密，格式为md5('password')</span></span><br><span class="line">$res=mysql_query($sql,$conn);</span><br><span class="line"><span class="keyword">if</span> ($res) &#123;</span><br><span class="line">	<span class="comment"># mysql_affected_rows用于返回受影响的行数</span></span><br><span class="line">	<span class="keyword">if</span> (mysql_affected_rows($conn)&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"operate success"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment"># 删除操作有可能无删除数据</span></span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"没有受影响的行数"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment"># 操作失败，输出失败原因</span></span><br><span class="line">	<span class="keyword">die</span>(<span class="string">"operate failure"</span>.mysql_error());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>dql</li>
</ul>
<p>数据查询语句 select</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$sql=<span class="string">"select * from tablename"</span>;</span><br><span class="line"><span class="comment">#第一个参数是语句，第二个参数是连接符，用于确认是哪个连接（缺省时使用上一个打开的连接）</span></span><br><span class="line">$res=mysql_query($sql,$conn);</span><br></pre></td></tr></table></figure>

<div class="note warning"><p>
1. res在从数据库结果集中取完数据后指向内存中的数据，因此在这句后关闭conn连接也不影响后续数据的使用，但是这句后释放结果集资源后则无法再操作数据
2. 返回的res是一个资源类型 mysql_result
3. 如果执行dml语句 返回类型是 bool
</p></div>

<h3 id="接受返回结果并处理"><a href="#接受返回结果并处理" class="headerlink" title="接受返回结果并处理"></a>接受返回结果并处理</h3><p>返回的数据集属于一个资源类型，PHP提供了多种封装形式，故可以采用多种取法处理返回结果。</p>
<ul>
<li>取法1 mysql_fetch_row 会返回一个索引数组，并依次取下一行</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ($row=mysql_fetch_row($res)) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"&lt;br&gt;$row[0]--$row[1]--$row[2]--$row[3]"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>取法2 mysql_fetch_assoc 会返回一个关联数组（键值对），并依次取下一行</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ($row=mysql_fetch_assoc($res)) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"&lt;br&gt;$row['key1']--$row['key2']--$row['key3']--$row['key4']"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>取法3 mysql_fetch_array 会返回索引数组和关联数组（两套），并依次取下一行</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ($row=mysql_fetch_array($res)) &#123;</span><br><span class="line">	<span class="comment">#两种方式都可以取到</span></span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"&lt;br&gt;$row[0]--$row[1]--$row[2]--$row[3]"</span>;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"&lt;br&gt;$row['key1']--$row['key2']--$row['key3']--$row['key4']"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>取法4 mysql_fetch_object 会把一行数据当做一个对象返回，并依次取下一行</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ($row=mysql_fetch_object($res)) &#123;</span><br><span class="line">	<span class="keyword">echo</span> $row-&gt;key1.<span class="string">"---"</span>.$row-&gt;key2.<span class="string">"---"</span>.$row-&gt;key3.<span class="string">"---"</span>.$row-&gt;key4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>取法5 mysql_fetch_field 会把表的表头属性名当做一个数组返回</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ($field_info=mysql_fetch_field($res)) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>.$field_info-&gt;name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>取法6 mysql_affected_rows和mysql_num_fields 返回所取数据的行数和列数</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$rows=mysql_affected_rows($conn);<span class="comment">//行数</span></span><br><span class="line">$colums=mysql_num_fields($res);<span class="comment">//列数</span></span><br></pre></td></tr></table></figure>

<h3 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 释放结果集中的资源，回收内存</span></span><br><span class="line">mysql_free_result($res);</span><br></pre></td></tr></table></figure>

<h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以不写，脚本执行结束后会自动关闭，执行语句后也不会立刻关闭</span></span><br><span class="line">mysql_close($conn);</span><br></pre></td></tr></table></figure>

<h2 id="mysql封装类"><a href="#mysql封装类" class="headerlink" title="mysql封装类"></a>mysql封装类</h2><p>以上代码的可维护性和复用性不高，在面向对象编程中，我们通常将其封装成一个工具类SqlTool.class.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据库操作工具类</span></span><br><span class="line"><span class="comment"> * 适用于mysql扩展库</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlTool</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> $connection;</span><br><span class="line">	<span class="keyword">private</span> $host;</span><br><span class="line">	<span class="keyword">private</span> $username;</span><br><span class="line">	<span class="keyword">private</span> $password;</span><br><span class="line">	<span class="keyword">private</span> $dbname;</span><br><span class="line">	<span class="comment"># 构造函数，创建连接</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($host,$username,$password,$dbname)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;connection=mysql_connect($host,$username,$password);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;connection) &#123;</span><br><span class="line">			<span class="keyword">$this</span>-&gt;dbname=$dbname;</span><br><span class="line">			mysql_select_db($dbname,<span class="keyword">$this</span>-&gt;connection);</span><br><span class="line">			mysql_query(<span class="string">"set names utf8"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">die</span>(<span class="string">"connection failure:"</span>.mysql_error());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment"># 析构函数，关闭连接</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		mysql_close(<span class="keyword">$this</span>-&gt;connection);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment"># 将查询的数据作为对象索引数组返回</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">execute_dql</span><span class="params">($sql)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		$res=mysql_query($sql,<span class="keyword">$this</span>-&gt;connection) <span class="keyword">or</span> <span class="keyword">die</span>(mysql_error());</span><br><span class="line">		$res_set=<span class="keyword">array</span>();</span><br><span class="line">		<span class="keyword">while</span> ($row=mysql_fetch_object($res)) &#123;</span><br><span class="line">			array_push($res_set, $row);</span><br><span class="line">		&#125;</span><br><span class="line">		mysql_free_result($res);</span><br><span class="line">		<span class="keyword">return</span> $res_set;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">execute_dml</span><span class="params">($sql)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		$res=mysql_query($sql,<span class="keyword">$this</span>-&gt;connection);</span><br><span class="line">		<span class="keyword">if</span> ($res) &#123;</span><br><span class="line">			<span class="keyword">return</span> mysql_affected_rows(<span class="keyword">$this</span>-&gt;connection);<span class="comment">//返回受影响的行数</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//语句执行失败</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment"># 将查询的表头信息作为索引数组返回</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">query_field</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		$res=mysql_query(<span class="string">"select * from"</span>.$tablename,<span class="keyword">$this</span>-&gt;connection) <span class="keyword">or</span> <span class="keyword">die</span>(mysql_error());</span><br><span class="line">		$filed=<span class="keyword">array</span>();</span><br><span class="line">		<span class="keyword">while</span> ($field_info=mysql_fetch_field(result)) &#123;</span><br><span class="line">			array_push($filed, $field_info-&gt;name);</span><br><span class="line">		&#125;</span><br><span class="line">		mysql_free_result($res);</span><br><span class="line">		<span class="keyword">return</span> $filed;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr />
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>数据库连接</tag>
        <tag>mysql扩展库</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP数据库编程学习笔记2</title>
    <url>/php8.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在新版的PHP7中，PHP越来越向面向对象风格靠拢，原有的mysql已经不再支持，因此PHP更加推荐用户使用mysqli扩展库，相比mysql扩展库，mysqli扩展库具有以下优势：</p>
<ul>
<li>稳定性，安全性，效率有所提升</li>
<li>支持面向对象编程风格，同时也向后兼容，支持面向过程编程风格（具备两套函数库）</li>
</ul>
<a id="more"></a>

<h2 id="mysqli扩展库调用过程（面向对象风格）"><a href="#mysqli扩展库调用过程（面向对象风格）" class="headerlink" title="mysqli扩展库调用过程（面向对象风格）"></a>mysqli扩展库调用过程（面向对象风格）</h2><div class="note info"><p>请将本标题下的所有代码段链接起来学习理解。</p></div>

<h3 id="获取连接"><a href="#获取连接" class="headerlink" title="获取连接"></a>获取连接</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建mysqli对象</span></span><br><span class="line">$mysqli=<span class="keyword">new</span> MySQLi(<span class="string">"localhost"</span>,<span class="string">"root"</span>,<span class="string">"mysql"</span>,<span class="string">"test"</span>);</span><br><span class="line"><span class="comment">## 验证是否连接成功</span></span><br><span class="line"><span class="keyword">if</span> ($mysqli-&gt;connect_error) &#123;</span><br><span class="line">	<span class="keyword">die</span>(<span class="string">"connect failed"</span>.$mysqli-&gt;connect_error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送sql指令"><a href="#发送sql指令" class="headerlink" title="发送sql指令"></a>发送sql指令</h3><p>mysqli扩展库支持批量执行SQL语句。</p>
<ul>
<li>dml语句</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$sql=<span class="string">"insert into user(name,age,password) values('a',30,md5('qcz'))"</span>;</span><br><span class="line">$res=$mysqli-&gt;query($sql);</span><br></pre></td></tr></table></figure>

<ul>
<li>批量执行dml语句</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$sqls=<span class="string">"insert into user(name,age,password) values('b',23,md5('zxq'));"</span>;</span><br><span class="line">$sqls.=<span class="string">"insert into user(name,age,password) values('c',23,md5('xam'));"</span>;</span><br><span class="line">$sqls.=<span class="string">"insert into user(name,age,password) values('d',24,md5('mt'));"</span>;</span><br><span class="line">$sqls.=<span class="string">"update user set age=20 where id=1;"</span>;</span><br><span class="line">$sqls.=<span class="string">"delete from user where id=2;"</span>;</span><br><span class="line">$res=$mysqli-&gt;multi_query($sqls);</span><br></pre></td></tr></table></figure>

<ul>
<li>dql语句</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$sql=<span class="string">"select * from user"</span>;</span><br><span class="line">$res=$mysqli-&gt;query($sql);</span><br></pre></td></tr></table></figure>

<ul>
<li>批量执行dql语句</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$sqls=<span class="string">"select * from user where age&gt;23;"</span>;</span><br><span class="line">$sqls.=<span class="string">"select * from user where age&lt;=23;"</span>;</span><br><span class="line">$res=$mysqli-&gt;multi_query($sqls);</span><br></pre></td></tr></table></figure>

<h3 id="处理结果"><a href="#处理结果" class="headerlink" title="处理结果"></a>处理结果</h3><ul>
<li>dml语句</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ($res) &#123;</span><br><span class="line">	<span class="comment"># 操作影响行数</span></span><br><span class="line">	<span class="keyword">if</span> ($mysqli-&gt;affected_rows&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"success"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"no effects"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"operate failed"</span>.$mysqli-&gt;error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>dql语句</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ($row=$res-&gt;fetch_row()) &#123;</span><br><span class="line">	<span class="keyword">foreach</span> ($row <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"&lt;br&gt;--$value"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>批量执行dql语句（执行成功返回批量结果集，失败返回false）</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 必须使用do while循环取值</span></span><br><span class="line"><span class="keyword">if</span> ($res) &#123;</span><br><span class="line">	<span class="comment"># 如果执行成功说明至少有一个结果集</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment"># store_result从mysqli中取出第一个结果集，即mysqli_result对象</span></span><br><span class="line">		$result=$mysqli-&gt;store_result();</span><br><span class="line">		<span class="keyword">while</span> ($row=$result-&gt;fetch_row()) &#123;</span><br><span class="line">			<span class="keyword">foreach</span> ($row <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">				<span class="keyword">echo</span> <span class="string">"&lt;br&gt;--$value"</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment"># 关闭当前结果集</span></span><br><span class="line">		$result-&gt;free();</span><br><span class="line">		<span class="comment"># more_results 判断是否还有剩余未取出的结果集</span></span><br><span class="line">		<span class="keyword">if</span> ($mysqli-&gt;more_results()) &#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">"&lt;br&gt;new result"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment"># next_result 不加判断的取下一个结果集</span></span><br><span class="line">	&#125; <span class="keyword">while</span> ($mysqli-&gt;next_result());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关闭资源"><a href="#关闭资源" class="headerlink" title="关闭资源"></a>关闭资源</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 释放内存（执行dml语句不需要释放资源）</span></span><br><span class="line">$res-&gt;free();</span><br><span class="line"><span class="comment"># 关闭连接</span></span><br><span class="line">$mysqli-&gt;close();</span><br></pre></td></tr></table></figure>

<h2 id="mysqli扩展库调用过程（面向过程风格）"><a href="#mysqli扩展库调用过程（面向过程风格）" class="headerlink" title="mysqli扩展库调用过程（面向过程风格）"></a>mysqli扩展库调用过程（面向过程风格）</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 获取mysqli连接</span></span><br><span class="line">$mysqli=mysqli_connect(<span class="string">"localhost"</span>,<span class="string">"root"</span>,<span class="string">"mysql"</span>,<span class="string">"test"</span>);</span><br><span class="line"><span class="comment">## 验证是否连接成功</span></span><br><span class="line"><span class="keyword">if</span> (!$mysqli) &#123;</span><br><span class="line">	<span class="keyword">die</span>(<span class="string">"connect failed"</span>.mysqli_connect_error($mysqli));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 2 向数据库发送sql语句（ddl dml dql……）</span></span><br><span class="line">$sql=<span class="string">"select * from user"</span>;</span><br><span class="line">$res=mysqli_query($mysqli,$sql);</span><br><span class="line"><span class="comment"># 3 处理得到的结果</span></span><br><span class="line"><span class="keyword">while</span> ($row=mysqli_fetch_row($res)) &#123;</span><br><span class="line">	<span class="keyword">foreach</span> ($row <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"&lt;br&gt;--$value"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 4 关闭资源</span></span><br><span class="line"><span class="comment">## 释放内存</span></span><br><span class="line">mysqli_free_result($res);</span><br><span class="line"><span class="comment">## 关闭连接（遵循 晚创建早释放 的原则）</span></span><br><span class="line">mysqli_close($mysqli);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>操作mysqli扩展库时与mysql扩展库相似：</p>
<ul>
<li>如果执行的是dml语句，则返回bool类型；如果执行dql语句，则返回查询结果mysqli_result结果集对象</li>
<li>取res结果集的方式仍然有四种与mysql扩展库中的方法一一对应：<ul>
<li>$res-&gt;fetch_assoc()</li>
<li>$res-&gt;fetch_row()</li>
<li>$res-&gt;fetch_array()</li>
<li>$res-&gt;fetch_object()</li>
</ul>
</li>
<li>释放资源有三种方式：<ul>
<li>$mysqli-&gt;free()</li>
<li>$mysqli-&gt;close()</li>
<li>$mysqli-&gt;free_result()</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="mysqli封装类"><a href="#mysqli封装类" class="headerlink" title="mysqli封装类"></a>mysqli封装类</h2><p>以上代码的可维护性和复用性不高，在面向对象编程中，我们通常将其封装成一个工具类SqlTool.class.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据库操作工具类</span></span><br><span class="line"><span class="comment"> * 适用于mysqli扩展库</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlTool</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> $mysqli;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($host,$username,$password,$dbname)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;mysqli=<span class="keyword">new</span> MySQLi($host,$username,$password,$dbname);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;mysqli-&gt;connect_error) &#123;</span><br><span class="line">			<span class="keyword">die</span>(<span class="string">"connect failed"</span>.$mysqli-&gt;connect_error);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;mysqli-&gt;query(<span class="string">"set names utf8"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;mysqli-&gt;close();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">execute_dql</span><span class="params">($sql)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		$res=<span class="keyword">$this</span>-&gt;mysqli-&gt;query($sql) <span class="keyword">or</span> <span class="keyword">die</span>($sql.<span class="string">"--failed--"</span>.<span class="keyword">$this</span>-&gt;mysqli-&gt;error);</span><br><span class="line">		$res_set=<span class="keyword">array</span>();</span><br><span class="line">		<span class="keyword">while</span> ($row=$res-&gt;fetch_object()) &#123;</span><br><span class="line">			array_push($res_set, $row);</span><br><span class="line">		&#125;</span><br><span class="line">		$res-&gt;free();</span><br><span class="line">		<span class="keyword">return</span> $res_set;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">execute_dqls</span><span class="params">($sqls)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		$res=<span class="keyword">$this</span>-&gt;mysqli-&gt;multi_query($sqls) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"sqls failed--"</span>.<span class="keyword">$this</span>-&gt;mysqli-&gt;error);</span><br><span class="line">		$res_set=<span class="keyword">array</span>();</span><br><span class="line">		<span class="keyword">if</span> ($res) &#123;</span><br><span class="line">			<span class="keyword">do</span> &#123;</span><br><span class="line">				$result=<span class="keyword">$this</span>-&gt;mysqli-&gt;store_result();</span><br><span class="line">				$res_set_obj=<span class="keyword">array</span>();</span><br><span class="line">				<span class="keyword">while</span> ($row=$result-&gt;fetch_object()) &#123;</span><br><span class="line">					array_push($res_set_obj, $row);</span><br><span class="line">				&#125;</span><br><span class="line">				array_push($res_set, $res_set_obj);</span><br><span class="line">				$result-&gt;free();</span><br><span class="line">				<span class="keyword">if</span> (!<span class="keyword">$this</span>-&gt;mysqli-&gt;more_results()) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">while</span> (<span class="keyword">$this</span>-&gt;mysqli-&gt;next_result());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> $res_set;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">execute_dml</span><span class="params">($sql,$is_multi)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> ($is_multi) &#123;</span><br><span class="line">			$res=<span class="keyword">$this</span>-&gt;mysqli-&gt;multi_query($sql) <span class="keyword">or</span> <span class="keyword">die</span>($sql.<span class="string">"--failed--"</span>.<span class="keyword">$this</span>-&gt;mysqli-&gt;errno.<span class="keyword">$this</span>-&gt;mysqli-&gt;error);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			$res=<span class="keyword">$this</span>-&gt;mysqli-&gt;query($sql) <span class="keyword">or</span> <span class="keyword">die</span>($sql.<span class="string">"--failed--"</span>.<span class="keyword">$this</span>-&gt;mysqli-&gt;errno.<span class="keyword">$this</span>-&gt;mysqli-&gt;error);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ($res) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">$this</span>-&gt;mysqli-&gt;affected_rows;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>封装类的使用</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$sqltool=<span class="keyword">new</span> SqlTool(<span class="string">"localhost"</span>,<span class="string">"root"</span>,<span class="string">"mysql"</span>,<span class="string">"test"</span>);</span><br><span class="line"><span class="comment"># 查</span></span><br><span class="line">$sql=<span class="string">"select * from user"</span>;</span><br><span class="line">$res=$sqltool-&gt;execute_dql($sql);</span><br><span class="line"><span class="comment"># 处理</span></span><br><span class="line"><span class="keyword">foreach</span> ($res <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"&lt;br&gt;--"</span>.$value-&gt;name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量查</span></span><br><span class="line">$sqls=<span class="string">"select * from user where age&gt;23;"</span>;</span><br><span class="line">$sqls.=<span class="string">"select * from user where age&lt;=23;"</span>;</span><br><span class="line">$res=$sqltool-&gt;execute_dqls($sqls);</span><br><span class="line"><span class="comment"># 处理</span></span><br><span class="line"><span class="keyword">foreach</span> ($res <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"&lt;br&gt;new result"</span>;</span><br><span class="line">	<span class="keyword">foreach</span> ($value <span class="keyword">as</span> $key1 =&gt; $value1) &#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"&lt;br&gt;--"</span>.$value1-&gt;id.$value1-&gt;name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增</span></span><br><span class="line">$sql=<span class="string">"insert into user(name,age,password) values('a',25,md5('xyj'))"</span>;</span><br><span class="line"><span class="comment"># 删</span></span><br><span class="line">$sql=<span class="string">"delete from user1 where id=4"</span>;</span><br><span class="line">$res=$sqltool-&gt;execute_dml($sql);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量</span></span><br><span class="line">$sqls=<span class="string">"insert into user(name,age,password) values('b',23,md5('zxq'));"</span>;</span><br><span class="line">$sqls.=<span class="string">"insert into user(name,age,password) values('c',23,md5('xam'));"</span>;</span><br><span class="line">$sqls.=<span class="string">"insert into user(name,age,password) values('d',24,md5('mt'));"</span>;</span><br><span class="line">$sqls.=<span class="string">"update user set age=20 where id=1;"</span>;</span><br><span class="line">$sqls.=<span class="string">"delete from user where id=5;"</span>;</span><br><span class="line">$sqls.=<span class="string">"delete from user where id=6;"</span>;</span><br><span class="line">$sqls.=<span class="string">"delete from user where id=7;"</span>;</span><br><span class="line">$res=$sqltool-&gt;execute_dml($sqls,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理</span></span><br><span class="line"><span class="keyword">switch</span> ($res) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"no effects"</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"failed"</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"success"</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr />
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>数据库连接</tag>
        <tag>mysqli扩展库</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序及其优化</title>
    <url>/quickSort.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>快排由于其常数项比其他O(N*log(N))级别的排序算法低，是工程中常用的一种排序算法，但是排序算法的跨元素交换的特性也使得快排失去了稳定了，故常用于基本数据类型的排序；经典快排是对冒泡排序的一种改进，因此一次排序依然只能确定一个元素的位置，并且对于趋近于有序的数据状况，快排的时间复杂度反而会变差。本文以经典快排为基础，讨论一下对于快速排序算法的优化。</p>
<a id="more"></a>

<h2 id="经典快排"><a href="#经典快排" class="headerlink" title="经典快排"></a>经典快排</h2><p>快速排序是基于冒泡排序的一种改进，如何理解这句话？冒泡排序基于相邻元素两两之间的比较，每一轮冒泡确定当前未排序列中的一个最值，这样来看冒泡的方向是单向的，并且每轮冒泡的数量是单个的，确实有些低效。我们考虑能否同时向两边冒泡，且每轮冒泡的数量可以是多个，要实现这个目的，我们必须定一个标准，为什么这么说？在冒泡排序中，我们只是单侧从头到尾的冒泡，这样即使每次比较没有统一的参照标准，两两比较也必然能够找出本轮的最值，但要想往两边冒泡，我们却只能从一边开始遍历的情况下，只能设定一个统一的比较标准，根据这个标准将当前序列中的数分为两部分，实现双向冒泡的同时使得每轮有多个元素进行冒泡。</p>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>经典快排的过程是将给定数组根据某一标准（通常是数组的第一个元素或最后一个元素）划分成两个部分，小于等于标准的元素放左边，大于标准的元素放右边，同时确定标准的最终位置；进而递归调用该方法，划分标准左侧的部分和标准右侧的部分。递归调用过程如图所示：</p>
<p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/quickSort2.jpg" alt="quickSort2"></p>
<p>如图所示，橙色位置的元素表示该元素已经完成了最终位置的交换，且此时整个序列中该元素以左一定小于该元素，以右一定大于该元素；第一次调用确定一个元素的位置，第二次调用再确定两个元素的位置……以此类推，呈指数级增长，直到划分出某个标准两侧出现单个元素时不再进行划分。</p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>下面我们来分析这个算法应当如何实现，首先既然是递归函数，依然遵循我们构建递归函数的流程，考虑以下两个问题：</p>
<ol>
<li>base case：递归的终止条件如上面所说，当要划分的区间为单个元素时停止；</li>
<li>依赖关系：当我们再去考虑依赖条件时会发现一件有趣的现象，那就是<strong>快排的递归函数根本不存在依赖关系</strong>，因为当我们要对子问题做划分的前提是我们先确定划分标准的位置，而当这个位置确定的时候，当前已经是关于划分点左右有序的次序关系了，因此左右两个子部分下一次递归划分的过程和结果不再会对上一轮已经确定的划分点位置产生影响；这就说明我们其实<strong>可以将子问题计算的过程从串行计算改成并行计算</strong>，对并行算法有研究的同学可以做一下这方面的尝试。</li>
</ol>
<p>下面我们来看一下经典快排的算法实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr==<span class="keyword">null</span>||arr.length&lt;<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	quickSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left&lt;right) &#123;</span><br><span class="line">		<span class="keyword">int</span> pivot = partition(arr, left, right);</span><br><span class="line">		quickSort(arr, left, pivot);</span><br><span class="line">		quickSort(arr, pivot+<span class="number">1</span>, right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，pivot变量代表每一次子部分的排序后划分点的下标位置，而left和right也限制了子问题的范围，当子部分的区间大小只有一个元素时停止划分。我们可以通过对比快排的递归函数和归并排序的递归函数发现为什么快排的递归过程不存在依赖关系而归并排序的递归过程存在依赖关系，从代码的执行顺序来看，归并排序是先调用递归函数，再进行合并；而快排是先进行排序，确定划分点，再调用递归函数。这件事情的实质是归并排序如果子部分还无序，那么是子部分之间是无法进行合并的；而快排是即便子部分还是无序，子部分之间的划分点位置已经确定，不再受子部分的排序结果影响，这才是递归函数依赖关系的核心。</p>
<p>下面我们来分析一次排序的过程，即partition这个函数的实现，前面我们一直在说划分标准这件事，但是上面的递归函数中并没有相关的代码逻辑，那么在确定划分点这个函数中我们首先要确定划分标准，这里不妨用子部分中的最后一个元素来做划分标准，最后确定好划分点位置之后将该元素交换过来即可。剩余的部分我们需要考虑如何将每次比较的结果保存下来，由于经典排序的一次只确定一个数的位置，我们可以将整个子部分按照从左往右的顺序分成四部分：</p>
<ol>
<li>小于等于部分：元素值小于等于划分标准的部分</li>
<li>未排序部分：元素还未排序的部分</li>
<li>大于部分：元素值大于划分标准的部分</li>
<li>划分标准：排序阶段，最后一个元素作为划分标准不参与其他元素的交换</li>
</ol>
<p>整个排序的过程如下图所示：</p>
<p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/quickSort3.jpg" alt="quickSort3"></p>
<p>图中根据不同分布使用不同颜色进行区分，在排序的过程中大致可以分为这几种情况：</p>
<ol>
<li>初始值的设定：未排序部分的指针位于第一个元素处，即小于等于部分还没有元素；大于部分的指针指向不参与排序的划分标准处，即大于部分还没有元素；</li>
<li>当比较结果为小于等于时（smaller），当前指针向后移动，该元素归入小于等于部分；</li>
<li>当比较结果为大于时（bigger），more指针向前移动，交换more和current指向的元素，current指针驻停，被交换的元素归入大于部分；</li>
<li>当current指针和more指针相邻时结束遍历，交换more指针指向元素和划分标准的位置，返回more的数组下标。</li>
</ol>
<p>下面我们来看一下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//情况1</span></span><br><span class="line">	<span class="keyword">int</span> current = left;</span><br><span class="line">	<span class="keyword">int</span> more = right;</span><br><span class="line">	<span class="comment">//情况4（终止条件）</span></span><br><span class="line">	<span class="keyword">while</span>(current &lt; more) &#123;</span><br><span class="line">		<span class="comment">//情况3</span></span><br><span class="line">		<span class="keyword">if</span>(arr[current] &gt; arr[right])</span><br><span class="line">			swap(arr, current, --more);</span><br><span class="line">		<span class="comment">//情况2</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			current++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//情况4</span></span><br><span class="line">	swap(arr, more, right);</span><br><span class="line">	<span class="keyword">return</span> more;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info"><p>注意：代码中的current遍历完全可以使用形参中的left替代，这里为了和分析图中的遍历保持一致多申请了current这个变量。</p></div>

<h3 id="算法剖析"><a href="#算法剖析" class="headerlink" title="算法剖析"></a>算法剖析</h3><p>代码的逻辑非常简单，即上述图中所解释的几种情况，下面我们来分析一下算法的时间复杂度和空间复杂度。经典快排的时间和空间复杂度是取决于要排序的数据状况的，且数据状况越接近有序，经典快排的时间和空间复杂度越差，这又是什么原因呢？</p>
<p>回顾上面我们在描述经典快排算法思想的递归调用过程图，仔细思考一下我们会发现经典快排有一个严重的问题，就是它非常依赖于划分点在整个序列最终确定的位置，如果每一次划分点的位置都接近序列的中间位置，那么整个递归调用过程的次数就会很少，需要申请用于存储划分点位置的额外空间也会相应减少，反之则整个算法的时间复杂度和空间复杂度都会变差。</p>
<p>首先我们来看算法的空间复杂度，虽然这一算法在递归调用过程中不存在依赖关系，但也不代表子过程不需要父过程中的任何有效信息，不论是观察调用图还是递归函数结构，我们都可以发现划分点的位置信息，在两个子过程中都有传递，那么该信息其实在递归调用过程中是申请了非常数级的额外空间的，即只有将每一个子过程的划分点位置保留下来，函数才能够在左部分递归完毕后找到右部分开始递归的位置。</p>
<p>那么这个额外的空间复杂度是多少呢？这里就涉及到所要排序的序列是一个什么样的数据状况了，<strong>如果每一次的划分都正好将子部分均分，那么这个算法的空间复杂度就是整个序列能够被二分多少次的次数，即以2为底的N的对数，空间复杂度为O(log(N))；</strong>反之如果每一次划分点的位置都很偏向整个序列的边缘，那么基本上每个元素都将作为子部分的划分点被记录下来，故需要额外申请N个辅助空间来存储，空间复杂度为O(N)。</p>
<p>时间复杂度的推导也是同理，<strong>如果每一次的划分都正好将子部分均分，那么这个算法的时间复杂度就可以用master公式去估计（符合子问题等规模划分的前提），其中a=b=2 =》 log(a,b)=1且d=1 =》 算法的时间复杂度T(N)=O(N*log(N))；</strong>反之如果每一次划分点的位置都很偏向整个序列的边缘，那么后序的划分中较短的一侧很快会划分到单个元素，而另一次却要经历更多的子过程划分才能划分为单个元素的子部分。举一个极端的例子，如果待排序的整个序列呈逆序，那么使用快排一次只能确定出最边缘的一个元素的位置，整个算法退回O(N<sup>2</sup>)的时间复杂度，这样的情况显然是我们不想看到，因此我们有必要对经典快排做一些修改和优化。</p>
<ul>
<li>空间复杂度：最好O(log(N))，最差O(N)</li>
<li>时间复杂度：最好O(N*log(N))，最差O(N<sup>2</sup>)</li>
</ul>
<h2 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h2><p>讨论快排之前，我们先来引入一个经典的荷兰国旗问题，这个算法的思想接下来会为我们优化快排提供思路。</p>
<ul>
<li><p>题目：给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。</p>
</li>
<li><p>要求：额外空间复杂度O(1)，时间复杂度O(N)</p>
</li>
<li><p>对数器：使用额外空间对数组进行拷贝，三次遍历原数组分别找出小于、等于和大于给定数的元素依次拷贝到辅助数组，再拷贝回原数组。</p>
</li>
<li><p>分析：荷兰国旗问题实质上是对序列的一种排序，并非序列中的每个元素都要严格按照从小到大的升序或从大到小的降序，而仅仅是对某一个值或某几个相等值的位置进行确定，这个位置指的是如果整个序列有序，那么给定值的位置应该处于哪里（有可能给定值位于序列之外）。由于这个最重要确定位置的值是已知的，那么我们就要思考如何利用这一有效信息，来尽可能的让每一次的比较信息都有所保留，这样才能降低算法的时间复杂度。在经典的冒泡排序算法中，由于缺少一个参照的对象，只能从头到尾依次比较，将每一轮的最大值或最小值冒泡出来，但是这样进行冒泡除了能够确定下一次的最值之外，无法提供更多的有效信息，因为最值的位置无疑是确定的，即从边界向中间不断推进，即使我们不清楚这一轮的最值是多少，也知道他的位置已经其余元素和最值之间的相对次序关系；而在我们将最值逐渐冒泡到边界的过程中，我们不只是比较了最值和其他元素的大小关系，同时也比较了部分非最值之间的大小关系，而这些信息在冒泡排序的过程中没有能够很好的利用。在荷兰国旗问题中，已知要确定位置的值的情况下，充分利用序列中的元素每一次和该值比较所得的相对次序，是解决这一问题的核心。</p>
</li>
<li><p>思路：我们可以在遍历序列的过程中，有意识的将整个数组划分为四个部分，分别是</p>
<ul>
<li><p>小于部分：其中的元素小于给定值</p>
</li>
<li><p>等于部分：其中的元素等于给定值</p>
</li>
<li><p>大于部分：其中的元素大于给定值</p>
</li>
<li><p>未排部分：其中的元素还未进行比较</p>
<p>初始情况下，整个数组都是未排部分，其余三个部分为空，而在逐渐遍历和比较整个数组所有元素的过程中扩充其他三个部分，直到未排部分的元素为空，则该序列关于要确定位置的值的相对次序也最终确定。如图所示：</p>
</li>
</ul>
</li>
</ul>
<p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/quickSort1.jpg" alt="quickSort1"></p>
<p>如图b所示，四个部分用三个指针进行分割，less指针以及之前的元素均为小于给定值的部分，more指针以及之后的元素均为大于给定值的部分，而current指针表示当前正在遍历比较的元素，其两侧分隔了等于给定值的元素和未比较的元素。</p>
<p>元素交换的逻辑也很简单，如图a所示，初始情况下所有元素都未经过比较因此都属于未排部分，less和more两个指针位于数组之外，current指针位于数组开始位置，current元素与给定值的比较无非分成三种情况：</p>
<ol>
<li>当前元素小于给定值：交换当前元素和less指针指向的下一个元素，并将less指针后移，小于部分扩充（图a绿线）</li>
<li>当前元素小于给定值：不交换元素，current指针后移，即等于部分扩充</li>
<li>当前元素大于给定值：交换当前元素和more指针指向的前一个元素，并将more指针前移，大于部分扩充（图a红线）</li>
</ol>
<p>到这里，我们对于该算法的框架已经设计得比较完善了，下面就是代码中的细节问题，如何控制current指针移动的逻辑是需要特别注意的，第一和第二种情况中小于部分和等于部分的扩充都是指针向后移动，而第三种情况大于部分的扩充是指针向前移动，这两种不同的情况实质上的区别在于本次元素交换的来源，第三种情况与当前元素交换的元素来自未排部分，因此current指针的移动逻辑要却别开来。下面我们来看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">partiton</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> less = -<span class="number">1</span> , more = arr.length;</span><br><span class="line">	<span class="keyword">boolean</span> stay = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> current = <span class="number">0</span> ; current &lt; arr.length ; current ++) &#123;</span><br><span class="line">		<span class="comment">//情况三</span></span><br><span class="line">		<span class="keyword">if</span>(arr[current]&gt;num) &#123;</span><br><span class="line">			more--;</span><br><span class="line">			swap(arr, current, more);</span><br><span class="line">			stay = <span class="keyword">true</span>;</span><br><span class="line">		<span class="comment">//情况一</span></span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[current]&lt;num) &#123;</span><br><span class="line">			less++;</span><br><span class="line">			swap(arr, less, current);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//情况三的current指针移动逻辑</span></span><br><span class="line">		<span class="keyword">if</span>(stay) &#123;</span><br><span class="line">			current--;</span><br><span class="line">			stay = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//循环终止条件</span></span><br><span class="line">		<span class="keyword">if</span>(current==more-<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info"><p>注意：代码中的元素交换函数由于不涉及本题的核心逻辑，采用伪代码实现，想要测试当前方法的同学请自行实现。</p></div>

<p>我们发现，代码中对于第三种情况，设置了布尔开关，即如果存在未排部分的元素与当前元素进行交换时，应该使current指针驻停，否则会导致未排部分元素的遗漏。同时，如果大于部分不为空，则遍历的终止条件是current指针和more指针的相邻（大于部分为空时也可以这么理解），代码中也给出了判断。</p>
<ul>
<li>总结：荷兰国旗问题的解法向我们充分展示了如何将每一次的比较结果都记录下来，不论是大于，等于还是小于当前结果都会有合适的区间来保存比较结果，以便于后序对这些相对次序的再次利用，这个思路和归并排序中从组内有序到整体有序的合并过程也有着异曲同工之妙。</li>
</ul>
<h2 id="经典快排优化策略"><a href="#经典快排优化策略" class="headerlink" title="经典快排优化策略"></a>经典快排优化策略</h2><h3 id="荷兰国旗问题划分"><a href="#荷兰国旗问题划分" class="headerlink" title="荷兰国旗问题划分"></a>荷兰国旗问题划分</h3><p>经典快排一次只能确定一个元素的位置，面对相等元素较多的序列这样去逐个确定位置无疑是低效的，我们可以采用荷兰国旗问题的分割逻辑对快排的partition过程进行优化，这样我们每一次的返回值就不再是单个元素的下标位置，而是值相等的元素序列的起始位置和终止位置两个信息。这样的优化，相较于一次只能确定一个元素位置的经典快排，无疑是能够起到加速作用。</p>
<h3 id="随机快排"><a href="#随机快排" class="headerlink" title="随机快排"></a>随机快排</h3><p>对于上面分析到的经典快排对于数据状况的依赖问题，可以采用概率的方式降低依赖性，操作方式为每一次开始划分之前都在子序列中随机挑选一个元素，作为本轮划分的划分标准，这样一来，虽然仍然有可能出现较差的数据状况，但是此时对于算法的时间和空间复杂度的估算只能通过概率来估计，用长期期望的方式来计算时间复杂度。根据严格的数学证明，各种等概率的情况累加后得到基于长期期望的表达式结果是：时间复杂度O(N*log(N))，空间复杂度O(log(N))。</p>
<p>最后，我们将两种优化手段结合后的快排代码展示给大家：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr==<span class="keyword">null</span>||arr.length&lt;<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	quickSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left&lt;right) &#123;</span><br><span class="line">		<span class="comment">//随机快排：划分值随机选择</span></span><br><span class="line">		FoundSort.swap(arr, left+(<span class="keyword">int</span>)(Math.random()*(right-left+<span class="number">1</span>)), right);</span><br><span class="line">		<span class="keyword">int</span>[] equal = partition(arr, left, right);</span><br><span class="line">		quickSort(arr, left, equal[<span class="number">0</span>]-<span class="number">1</span>);</span><br><span class="line">		quickSort(arr, equal[<span class="number">1</span>]+<span class="number">1</span>, right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认以最后一个数作为划分标准</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right) &#123;</span><br><span class="line">	<span class="keyword">int</span> less = left - <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//划分初始，默认的区域为arr【right】之前的所有范围，即划分完后整个区域分为四个部分</span></span><br><span class="line">	<span class="comment">//【小于arr[right]】【等于arr[right]】【大于arr[right]】【arr[right]】</span></span><br><span class="line">	<span class="keyword">int</span> more = right;</span><br><span class="line">	<span class="keyword">while</span>(left&lt;more) &#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[left]&lt;arr[right])</span><br><span class="line">			swap(arr, left++, ++less);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(arr[left]&gt;arr[right])</span><br><span class="line">			swap(arr, left, --more);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			left++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//收尾工作，将最后一位arr[right]纳入整个序列</span></span><br><span class="line">	swap(arr, more, right);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;less + <span class="number">1</span>,more&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr />
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP数据库编程学习笔记3</title>
    <url>/php9.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前面我们提到过，数据库编程中的SQL指令分为四种，最后一种dtl数据事务语句还没有讲到。熟悉数据库的朋友应该知道，数据库是一个并行系统，在系统运行的过程中，不可能同一时刻只有一个用户在访问某个数据，当不同用户对同一个数据进行访问时，系统必须保证数据的同步，这就涉及到事务。<br>事务用于保证数据的一致性，由一组相关的dml语句组成，该组语句要么全部成功要么全部失败。事务具有acid四大特性：原子性、一致性、隔离性、持久性。在mysqli扩展库中提供了相应的函数支持，用来处理事务。同时，该扩展库还支持预编译技术，用于对多条SQL语句进行批处理。</p>
<a id="more"></a>

<h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$mysqli=<span class="keyword">new</span> MySQLi(<span class="string">"localhost"</span>,<span class="string">"root"</span>,<span class="string">"mysql"</span>,<span class="string">"test"</span>);</span><br><span class="line"><span class="keyword">if</span> ($mysqli-&gt;connect_error) &#123;</span><br><span class="line">	<span class="keyword">die</span>(<span class="string">"connect failed"</span>.$mysqli-&gt;connect_error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭默认的直接提交</span></span><br><span class="line"><span class="comment"># 相当于mysql控制台执行以下步骤： start transaction; savepoint a;</span></span><br><span class="line">$mysqli-&gt;autocommit(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">$sql1=<span class="string">"update account set balance=balance-2 where id=1"</span>;</span><br><span class="line">$sql2=<span class="string">"update account set balance=balance+2 where id=2"</span>;</span><br><span class="line"></span><br><span class="line">$res1=$mysqli-&gt;query($sql1);</span><br><span class="line">$res2=$mysqli-&gt;query($sql2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($res1&amp;&amp;$res2) &#123;</span><br><span class="line">	<span class="comment"># 事务成功统一提交</span></span><br><span class="line">	<span class="comment"># 相当于mysql控制台执行以下步骤： commit;</span></span><br><span class="line">	$mysqli-&gt;commit();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment"># 失败全部回滚</span></span><br><span class="line">	<span class="comment"># 相当于mysql控制台执行以下步骤： rollback to a;</span></span><br><span class="line">	$mysqli-&gt;rollback();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$mysqli-&gt;close();</span><br></pre></td></tr></table></figure>

<h2 id="stmt预编译"><a href="#stmt预编译" class="headerlink" title="stmt预编译"></a>stmt预编译</h2><p>PHP向mysql数据库发送批量相同模板指令时，可以第一次发送先编译好，之后只需要发送数据即可,批处理有两个优点：</p>
<ul>
<li>效率高，节省数据库编译时间开销</li>
<li>安全性高，可以防止sql注入攻击</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟要添加的用户类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> $id;</span><br><span class="line">	<span class="keyword">public</span> $name;</span><br><span class="line">	<span class="keyword">public</span> $age;</span><br><span class="line">	<span class="keyword">public</span> $password;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($name,$age,$password)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;name=$name;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;age=$age;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;password=$password;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dml语句预编译处理方式"><a href="#dml语句预编译处理方式" class="headerlink" title="dml语句预编译处理方式"></a>dml语句预编译处理方式</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$mysqli=<span class="keyword">new</span> MySQLi(<span class="string">"localhost"</span>,<span class="string">"root"</span>,<span class="string">"mysql"</span>,<span class="string">"test"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于批量绑定的参数</span></span><br><span class="line">$u1=<span class="keyword">new</span> User(<span class="string">"n1"</span>,<span class="number">22</span>,<span class="string">"p1"</span>);</span><br><span class="line">$u2=<span class="keyword">new</span> User(<span class="string">"n2"</span>,<span class="number">23</span>,<span class="string">"p2"</span>);</span><br><span class="line">$u3=<span class="keyword">new</span> User(<span class="string">"n3"</span>,<span class="number">24</span>,<span class="string">"p3"</span>);</span><br><span class="line">$user_set=<span class="keyword">array</span>($u1,$u2,$u3);</span><br><span class="line"></span><br><span class="line">$sql_dml=<span class="string">"insert into user(name,age,password) values(?,?,?);"</span>;</span><br><span class="line"><span class="comment"># 创建预编译对象</span></span><br><span class="line">$mysqli_stmt=$mysqli-&gt;prepare($sql_dml);</span><br><span class="line"><span class="comment"># 绑定数据并执行</span></span><br><span class="line"><span class="keyword">foreach</span> ($user_set <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 绑定参数（使用可变参数，类似于printf的写法）</span></span><br><span class="line">	<span class="comment">## 类型（s 字符串 i 整数 d 浮点数）和参数需要严格对应</span></span><br><span class="line">	$mysqli_stmt-&gt;bind_param(<span class="string">"sis"</span>,$value-&gt;name,$value-&gt;age,$value-&gt;password);</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 执行</span></span><br><span class="line">	$res=$mysqli_stmt-&gt;execute();</span><br><span class="line">	<span class="keyword">if</span> (!$res) &#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"failed"</span>.$mysqli_stmt-&gt;error;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dql语句预编译处理方式"><a href="#dql语句预编译处理方式" class="headerlink" title="dql语句预编译处理方式"></a>dql语句预编译处理方式</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$mysqli=<span class="keyword">new</span> MySQLi(<span class="string">"localhost"</span>,<span class="string">"root"</span>,<span class="string">"mysql"</span>,<span class="string">"test"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于接受批量结果集的数组</span></span><br><span class="line">$res_set=<span class="keyword">array</span>();</span><br><span class="line"><span class="comment"># 用于批量绑定的参数</span></span><br><span class="line">$param_set=<span class="keyword">array</span>(<span class="number">20</span>,<span class="number">23</span>,<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">$sql_dql=<span class="string">"select * from user where age&gt;?;"</span>;</span><br><span class="line"><span class="comment"># 创建预编译对象</span></span><br><span class="line">$mysqli_stmt=$mysqli-&gt;prepare($sql_dql);</span><br><span class="line"><span class="comment"># 绑定数据并执行</span></span><br><span class="line"><span class="keyword">foreach</span> ($param_set <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">	<span class="comment"># 绑定参数</span></span><br><span class="line">	$mysqli_stmt-&gt;bind_param(<span class="string">"i"</span>,$value);</span><br><span class="line">	<span class="comment"># 绑定结果集（引用传参）</span></span><br><span class="line">	$mysqli_stmt-&gt;bind_result($id,$name,$age,$password);</span><br><span class="line">	<span class="comment"># 执行指令</span></span><br><span class="line">	$mysqli_stmt-&gt;execute();</span><br><span class="line">	<span class="comment"># 用于暂时存放一次结果集的数组</span></span><br><span class="line">	$res=<span class="keyword">array</span>();</span><br><span class="line">	<span class="comment"># 取出绑定的结果集</span></span><br><span class="line">	<span class="keyword">while</span> ($mysqli_stmt-&gt;fetch()) &#123;</span><br><span class="line">		$u=<span class="keyword">new</span> User($name,$age,$password);</span><br><span class="line">		$u-&gt;id=$id;</span><br><span class="line">		array_push($res, $u);</span><br><span class="line">	&#125;</span><br><span class="line">	array_push($res_set, $res);</span><br><span class="line">	<span class="comment"># 释放资源（返回的结果集）</span></span><br><span class="line">	$mysqli_stmt-&gt;free_result();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 关闭预编译语句</span></span><br><span class="line">$mysqli_stmt-&gt;close();</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量结果集输出</span></span><br><span class="line"><span class="keyword">foreach</span> ($res_set <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"&lt;br&gt;new result"</span>;</span><br><span class="line">	<span class="keyword">foreach</span> ($value <span class="keyword">as</span> $key1 =&gt; $value1) &#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"&lt;br&gt;--"</span>.$value1-&gt;id.$value1-&gt;name.$value1-&gt;age.$value1-&gt;password;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mysqli扩展库中对表格信息的访问"><a href="#mysqli扩展库中对表格信息的访问" class="headerlink" title="mysqli扩展库中对表格信息的访问"></a>mysqli扩展库中对表格信息的访问</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$sql=<span class="string">"select * from user;"</span>;</span><br><span class="line">$res=$mysqli-&gt;query($sql);</span><br><span class="line"><span class="comment">## 获取返回结果集的总行数和总列数</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;--"</span>.$res-&gt;num_rows.$res-&gt;field_count;;</span><br><span class="line"><span class="comment">## 返回表头信息</span></span><br><span class="line"><span class="keyword">while</span> ($field=$res-&gt;fetch_field()) &#123;</span><br><span class="line">	<span class="comment"># 字段属性名</span></span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"--"</span>.$field-&gt;name;<span class="comment">//--id--name--age--password</span></span><br><span class="line">	<span class="comment"># 字段最大长度</span></span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"--"</span>.$field-&gt;max_length;<span class="comment">//--2--9--2--32</span></span><br><span class="line">	<span class="comment"># 其他查手册</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr />
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>数据库连接</tag>
        <tag>mysqli扩展库</tag>
      </tags>
  </entry>
  <entry>
    <title>备战纳新</title>
    <url>/recruit.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>时间很快又到了纳新季，回想起第一次纳新的惨痛经历，因为是新申请的社团，给我们安排场地的时候临时加在了纳新区的最角落，旁边还是一个敲锣打鼓的音乐社团，他们一开始表演，我们这边吵的话都听不清……于是这一次大佬为了一雪前耻，多招些新同学，给我们争取到了一个很有牌面的场地，人家的场地一个帐篷宽，我们的场地两个帐篷宽，属实有牌面。于是我作为纳新素材的设计人员更觉得要在设计海报上面多花心思，争取壮大社团。<br>下图中这张泛黄的海报是第一次纳新的时候做的，现在看来这个艺术字真的有点突兀，如果换成平面的字体或许还会看起来协调一些，另一个问题还是之前提到的只会一味的居中再居中，这种单调的对齐方式用多了就会失去美感。有了后来的设计经验，这次纳新的作品就成熟了很多，并且为了突出新意，和其他社团采用宣传单或宣传海报的方式有所区分，我决定采用名片来做宣传，并且为每一个加入社团的会员设计可以折叠的会员卡，记录每次会员的观影记录，在学期末为支持我们社团观影活动的会员准备礼物，这个想法得到了大家的认可，我就着手开始准备了。</p>
<a id="more"></a>

<h2 id="纳新展板海报"><a href="#纳新展板海报" class="headerlink" title="纳新展板海报"></a>纳新展板海报</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/recruit1.jpg" alt="纳新展板海报"></p>
<h2 id="纳新名片（正面）"><a href="#纳新名片（正面）" class="headerlink" title="纳新名片（正面）"></a>纳新名片（正面）</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/recruit2.jpg" alt="纳新名片（正面）"></p>
<h2 id="纳新名片（背面）"><a href="#纳新名片（背面）" class="headerlink" title="纳新名片（背面）"></a>纳新名片（背面）</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/recruit3.jpg" alt="纳新名片（背面）"></p>
<h2 id="会员卡（封面）"><a href="#会员卡（封面）" class="headerlink" title="会员卡（封面）"></a>会员卡（封面）</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/recruit4.jpg" alt="会员卡（封面）"></p>
<h2 id="会员卡（封底）"><a href="#会员卡（封底）" class="headerlink" title="会员卡（封底）"></a>会员卡（封底）</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/recruit5.jpg" alt="会员卡（封底）"></p>
<hr />
]]></content>
      <categories>
        <category>平面设计</category>
      </categories>
      <tags>
        <tag>海报</tag>
        <tag>影协</tag>
        <tag>名片</tag>
      </tags>
  </entry>
  <entry>
    <title>递归&amp;Master公式</title>
    <url>/recursion.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>评价一个算法的优劣，时间复杂度应该是最重要的指标，时间复杂度不止可以判断两个算法计算起来用时更短，甚至可以区分这个算法是否是计算机可以解决的。但是如何估计一个算法的时间复杂度有时也不是那么显而易见的，例如递归算法的时间复杂度，其中涉及到系统的压栈和弹栈时间，需要用到本文介绍主项公式来辅助求解。</p>
<a id="more"></a>

<h2 id="从算法的时间复杂度说起"><a href="#从算法的时间复杂度说起" class="headerlink" title="从算法的时间复杂度说起"></a>从算法的时间复杂度说起</h2><p>我们都知道，虽然时间复杂度这一指标以时间为名，但并不是一个时间单位，其本质是样本量的增长对计算时间的影响。任何一个算法都要有输入和输出，不管输入的数据是一组数还是对象（这不是算法所关心的），所输入的数据的数量称为样本量（n），随着样本量的增长计算时间也会相应的增长，这很好理解；但是，常数级的算法即便样本量增加，计算时间也不会发生变化（听起来似乎不可思议），而线性时间复杂度的算法计算时间的增长和样本量的增长是同等规模的，O(N<sup>2</sup>)的算法样本量增长9倍，计算时间就要增长99倍……（以此类推）</p>
<p>时间复杂度通常主要由次数和常数项两部分构成，而其中最重要的指标还是最高项的次数，即便常数项较小，但只要最高项的次数高于其他算法，那么该算法随着样本量的增大计算时间总会超过其他算法（将时间复杂度的函数图像画出来就一目明了）。而当两个算法的最高次相同时，就可以通过比较常数项来判断谁的计算时间更长，例如位运算和加减乘除运算都是常数级的时间复杂度，但是位运算的常数项更小，因此许多算法中的<code>x/2</code>通常写作<code>x&gt;&gt;1</code>，<code>2^x</code>通常写作<code>1&lt;&lt;x</code>。</p>
<h2 id="P问题和NP问题"><a href="#P问题和NP问题" class="headerlink" title="P问题和NP问题"></a>P问题和NP问题</h2><p>P&amp;NP问题作为千禧年七大数学难题之首，其实质就是在讨论算法的时间复杂度问题，即便是云计算已经如此普及的今天，对于计算机而言一个非多项式复杂度的算法也需要耗费大量的时间，这正是我们如此看重算法时间复杂度的原因（真的等不起）。关于多项式级复杂度，主要包括O(1),O(log(n)),O(n^a)等几种，与之相对的非多项式级复杂度有O(a^n)和O(n!)，这也是P&amp;NP问题的划分标准。</p>
<p>时间复杂度上的差别使得我们在求解这两类问题时的思路截然不同，对于P问题，我们其实可以明确的确定一系列计算步骤来将输入数据一步步转化为输出数据，这也是我们在学习算法过程中最主要练习的部分；但是NP问题，我们不一定能够将其转化为多项式的过程将其解决的。虽然如此，但是NP问题有一个重要的特点，就是我们可以在多项式的时间内验证问题的一个解，因此就可以用递归算法来尝试求解，只要这个算法的样本量有限，就一定能在有限时间内解决这个问题。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>学递归的时候老师说，任何递归算法都可以改成非递归的版本，因为递归的实质是系统帮你把分一步计算结果压栈，之后再弹栈，系统方法栈不仅可以将中间结果压栈，同时可以将每一步方法中的参数压栈，功能十分强大。但是，我们在日常学习算法和思考问题的时候总是习惯于从条件到结果的顺序依赖关系，即遇到一个问题时我们习惯于用解决P问题的方式去思考，一旦遇到NP问题就会显得有些束手无策，因此我们要通过学习递归函数的构建来训练如何用计算机的逻辑来思考问题，这也是算法能力很重要的一部分。</p>
<p>写一个递归函数，我们首先要考虑的是递归的终止条件，也叫base case，即样本量一旦小到什么程度，我们就能够用多项式级的算法来解决该问题；确定了终止条件，接下来考虑每一步递归过程中的依赖关系，即最初始的样本量是如何依赖下一级的样本量来得到最终结果的，依赖关系也确定之后，就可以输入初始值开始求解。</p>
<p>这里以著名的汉诺塔问题为例，样本量为n的问题从初始杆借助辅助杆移动到终止杆上。我们将问题抽象一下，我们将前n-1个圆盘看做整体，那么一次递归过程可以分为三个步骤：</p>
<ol>
<li>将前n-1个圆盘移动到辅助杆上</li>
<li>将第n个圆盘移动到最终杆上</li>
<li>将前n-1个圆盘移动到最终杆上</li>
</ol>
<p>通过上述三个步骤，我们可以得出，递归的终止条件是当n-1=1时，即剩余的圆盘可以通过一步操作进行移动，就没有必要再对该过程进行划分；而依赖关系则是每一次递归时，n-1这个整体逐渐减小，而三个杆又分别作为源头，目的地和辅助空间进行圆盘的移动，即第一个步骤中辅助杆作为最终n-1个圆盘要到达的“终止杆”，原本的终止杆作为了子过程的辅助杆，而第三步中n-1个圆盘所在的辅助杆成为了子过程中圆盘移动的“初始杆” ，原本父过程中的初始杆成为了“辅助杆”，如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">划分次数</th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center">递归树</th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">n-1=3</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">左——&gt;右</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">n-1=2</td>
<td align="center"></td>
<td align="center">左——&gt;中</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">中——&gt;右</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">n-1=1</td>
<td align="center">左——&gt;右</td>
<td align="center"></td>
<td align="center">右——&gt;中</td>
<td align="center"></td>
<td align="center">中——&gt;左</td>
<td align="center"></td>
<td align="center">左——&gt;右</td>
</tr>
</tbody></table>
<p>表中的递归树表示“源点——&gt;终点”，剩余的一个杆作为辅助杆。我们发现，n层汉诺塔问题的递归树展开实际上是一棵深度为n的满二叉树，而汉诺塔的解法则是对这棵树进行中序遍历的过程（似乎我们也可以用建立二叉树的方式来解决汉诺塔问题，将其改为非递归版本有点动态规划的思路），下面是汉诺塔问题的递归代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Hanoi</span></span>&#123;</span><br><span class="line">	<span class="comment">//三条轴</span></span><br><span class="line">	<span class="keyword">int</span>[] left;</span><br><span class="line">	<span class="keyword">int</span>[] middle;</span><br><span class="line">	<span class="keyword">int</span>[] right;</span><br><span class="line">	<span class="keyword">int</span> length;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Hanoi</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">		length = num;</span><br><span class="line">		middle = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">		right = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">		left = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; left.length; i++) &#123;</span><br><span class="line">			left[i] = i + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 汉诺塔的解法入口函数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		process(left, right, middle, length);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 递归求解汉诺塔的移动步骤</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> from	从哪一个轴上取</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> to	放到哪个轴的顶部</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> help	辅助轴</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> index	要移动的圆盘号</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] from,<span class="keyword">int</span>[] to,<span class="keyword">int</span>[] help,<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//base case</span></span><br><span class="line">		<span class="keyword">if</span>(index==<span class="number">1</span>) &#123;</span><br><span class="line">			move(from, to, index);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//先递归移动n-1个从初始轴到辅助轴</span></span><br><span class="line">			process(from, help, to, index - <span class="number">1</span>);</span><br><span class="line">			<span class="comment">//再移动第n个从初始轴到目的地轴</span></span><br><span class="line">			move(from, to, index);</span><br><span class="line">			<span class="comment">//最后递归移动n-1个从辅助轴到目的地轴</span></span><br><span class="line">			process(help, to, from, index - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 移动圆盘操作</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> from</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> to</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span>[] from,<span class="keyword">int</span>[] to,<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		to[index-<span class="number">1</span>] = index;</span><br><span class="line">		from[index-<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		show();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 打印当前的三根轴的状态，0表示空，大于0表示第几号圆盘在该轴上</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"------------------"</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; left.length; i++) &#123;</span><br><span class="line">			System.out.print(left[i]+<span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; middle.length; i++) &#123;</span><br><span class="line">			System.out.print(middle[i]+<span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; right.length; i++) &#123;</span><br><span class="line">			System.out.print(right[i]+<span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">		System.out.println(<span class="string">"------------------"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们来讨论一下汉诺塔问题的时间复杂度问题，观察我们的递归函数，可以发现每一次递归要对n-1规模的问题再递归两次，同时执行一次常数级的操作（挪动第n个圆盘），表达式为<strong>T(N)=2T(N-1)+O(1)</strong>，化简一下就会发现这是一个等比数列的展开，利用等比数列的求和公式最终<strong>T(N)=2^N-1</strong>,因此这是一个时间复杂度为O(2^N)的算法，印证了我们之前所说的汉诺塔问题是一个NP问题。其实观察表格中的递归树我们也可以计算，由于树中的每一个节点都代表一次对圆盘的移动操作，因此满二叉树的总结点的个数为2^N-1。</p>
<h2 id="主项公式"><a href="#主项公式" class="headerlink" title="主项公式"></a>主项公式</h2><p>递归行为如何分析时间复杂度，这个问题十分复杂，也并没有通式可以全部解释和涵盖，这里介绍一种最通用的情况下该如何计算，利用主项（master）公式：</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p><strong>T(N)=aT(N/b)+O(N^d)</strong></p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<ol>
<li><p>T(N)：样本量为N的情况下递归函数的时间复杂度</p>
</li>
<li><p>a：划分后要处理几次子样本（即是否要对划分后的子样本再次递归该函数）</p>
</li>
<li><p>b：总体过程在一次递归过程中被划分为了几部分</p>
</li>
<li><p>d：除了调用子过程之外的操作复杂度的数量级</p>
<p> 这里的a，b直接通过“数代码”即可确定，即只关心一次递归行为，不用分析整个系统栈（树）的划分过程</p>
</li>
</ol>
<p>这里有三种情况：</p>
<ol>
<li><strong>log(b,a)&gt;d</strong>时，<strong>T(N)=O(N^log(b,a))</strong></li>
<li><strong>log(b,a)=d</strong>时，<strong>T(N)=O(N^d*log(N))</strong></li>
<li><strong>log(b,a)&gt;d</strong>时，<strong>T(N)=O(N^d)</strong></li>
</ol>
<div class="note warning"><p>master公式仅仅适用于子样本的划分大小规模相等的情况，如上文中的汉诺塔问题就不能使用master公式估计时间复杂度。</p></div>
<hr />
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>单句写作：词类</title>
    <url>/scienceEnglish1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对于非英语专业的学生（尤其是理工科学生）及科技人员来说，急需学习如何把中文的论文翻译成正确且地道的英文文本，通过对多年来英文科技论文稿件中出现的大量错误进行分析得出，根本问题在于单句没写好。正确的句子即便不够完美，至少可以与外国读者正确交流科技信息，另外写作方面理论并不多，要通过大量实践才能掌握必要的写作的技巧。</p>
<a id="more"></a>


<h2 id="冠词"><a href="#冠词" class="headerlink" title="冠词"></a>冠词</h2><ul>
<li>艾米特博士2001年毕业于哈佛大学。<br>Dr.Emmit graduated form Harvard University in 2001.</li>
<li>李教授1988年在西安理工大学获得机械工程博士学位。<br>Professior Li earned his Ph.D. degree in mechanical engineering from Xi’an University of Technology in 1988.</li>
<li>现在我们转向讨论一下局域网。<br>Now we shall <strong>turn to</strong> the discussion of local area networks.</li>
<li>Bainbridge质谱仪是与光谱仪一样重要的仪器。</li>
<li><em>The*</em> Bainbridge mass spectrometer is <strong>as important an instrument as</strong> the optical spectrometer.</li>
<li>做这个实验需要多长时间？<br>How much time is required to this experiment?</li>
<li>压力的增加总会引起体积的减少。</li>
<li><em>An increase of*</em> pressure always causes <strong>a decrease</strong> in volume.</li>
<li>图2-5画出了式2-2所表示的情况。</li>
<li><em>Fig. 2-5*</em> shows what is expressed by <strong>Eq. 2-2</strong>.</li>
<li>电感的单位是亨利。</li>
<li><em>The unit of*</em> inductance is henry.</li>
</ul>
<h2 id="连接词"><a href="#连接词" class="headerlink" title="连接词"></a>连接词</h2><ul>
<li>该电路由一个电池、一个电感器和一个电容器组成。<br>This circuit contists of a battery, an inducor and a capacitor.</li>
<li>试计算在A,B,C三点处的电场。<br>Compute the electric field <strong>at points A,B and C</strong>.</li>
<li>这颗卫星用于美国与英国、法国、意大利之间的通信。<br>This satellite is used for communication <strong>between US and UK,France and Italy</strong>.</li>
<li>我们假设该天线是垂直的，且其损耗为零。<br>We assume <strong>that</strong> the antenna is vertical <strong>and that</strong> its loss is zero.  </li>
<li>第6、7、8章论述传输线。</li>
<li><em>Chapters 6,7 and 8*</em> deal with transmission lines.</li>
</ul>
<h2 id="数词"><a href="#数词" class="headerlink" title="数词"></a>数词</h2><ul>
<li>这两个参数之差为百万分之十九。<br>The difference between this two parameters is <strong>nineteen parts per million</strong>.</li>
<li>该数值约比理想值大3.5倍。<br>This value <strong>is nearly 3.5 times greater than</strong> the ideal one.</li>
<li>这个元件上的电流为零点零几安。<br>The electric current <strong>through</strong> the component is <strong>a few hundredths of an ampere</strong>. </li>
<li>该电阻器上的电压为总电压的2/5。<br>The voltage <strong>across</strong> this resister is <strong>two fifths that of</strong> the total voltage.</li>
<li>已证明用三角形来描述电信号是很有价值的。<br>Using trigonometry to describe electrical signals <strong>has proved</strong> very valuable.</li>
<li>其误差为千亿分之六。<br>Its error is <strong>six parts in 10<sup>11</sup></strong>.</li>
<li>这台计算机所存储的信息比那台多三倍。<br>This computer stores <strong>four times more information than</strong> that one does.</li>
<li>不久的将来对这种设备的需求量为现在的20倍。<br>The demand for this kind of equipment in the near future will be <strong>20 times what it is</strong>.</li>
<li>这个元件上的电压为零点几伏特。<br>The voltage across this component is <strong>a few tenths of a volt</strong>. </li>
<li>现在其内部的压力被减少了15倍。<br>Now its internal pressure is <strong>one sixteenth what it was</strong>.</li>
</ul>
<h2 id="介词"><a href="#介词" class="headerlink" title="介词"></a>介词</h2><ul>
<li>发射这颗卫星是为了获取有关地球的信息。<br>The satellite was launched to obtain information <strong>on the earth</strong>.</li>
<li>我们必须解出这个方程把那个未知数求出来。<br>We have to solve this equation <strong>for</strong> the unkonwn.</li>
<li>第三、四章介绍了设计天线的新方法。<br>Chapters 3 and 4 introduce a new method <strong>for</strong> designing atenna.</li>
<li>物理对了解宇宙是至关重要的。<br>Physica is vital <strong>to</strong> understand universe.</li>
<li>这个现象说明了牛顿的运动定理。<br>This phenomenon illustrates <strong>Newton’s laws of motion</strong>.</li>
<li>这种新型计算机与普通计算机相比有很多优点。<br>This new type of computer has many advantages <strong>over</strong> the general type.</li>
<li>在这新的五章中，第一章论述负反馈的基本原理。</li>
<li><em>Of*</em> this five new chapters, the first one deals with the basic principles <strong>of</strong> negetive feedback.</li>
<li>这时电流与电压相位相差90度。</li>
<li><em>At*</em> this point, current <strong>differs in</strong> phase <strong>from</strong> voltage <strong>by</strong> 90°.</li>
<li>通过分析该仪器的参数，我们就能够了解他的性能。</li>
<li><em>By analysing / Through analysis of*</em> the parameters of the instrument, we can understand it <strong>in</strong> performance. </li>
<li>我们要求出他在这一段距离上的平局速度。<br>We will find out its average velocity <strong>over</strong> this distance.</li>
<li>他们极为困难的解出了这道题。<br>They solve this problem <strong>with</strong> great difficult.</li>
<li>在A,B,C三点钟只有A点接地。</li>
<li><em>Among*</em> points A,B,C, only point A connects ground.</li>
<li>他俩身高相同。<br>They are <strong>of</strong> same height.</li>
<li>频率用赫兹来衡量。<br>Frequency is measured <strong>by</strong> hertz.</li>
<li>万有引力就是所有物体相互吸引的趋势。<br>Gravity is the tendency of all objects <strong>to</strong> attract, and be attracted <strong>by</strong>, each other.</li>
</ul>
<h2 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h2><ul>
<li>有许多问题有待于解决，既包括技术问题，也包括财政问题。<br>There are many problem remains to be solved, both technical problems and financial problems.</li>
</ul>
<h2 id="副词"><a href="#副词" class="headerlink" title="副词"></a>副词</h2><ul>
<li>他对这个领域的贡献怎么强调都不过分。<br>The contribution he made in this field cannot be <strong>overemphasized</strong>.</li>
<li>这个系数的典型值是0.35。<br>The value of this coefficient is <strong>typically</strong> 0.35.</li>
</ul>
<h2 id="形容词"><a href="#形容词" class="headerlink" title="形容词"></a>形容词</h2><ul>
<li>涉及的问题很多。<br>The problems <strong>involved</strong> are many.</li>
<li>速度快，安全性高，高铁为我们提供更便利的出行方式。</li>
<li><em>High*</em> in speed, <strong>safe</strong> in quality, CHR provide us a more convenient mean of transport.</li>
</ul>
]]></content>
      <categories>
        <category>科技英语写作</category>
      </categories>
      <tags>
        <tag>外语</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法的稳定性分析</title>
    <url>/stable.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>学习排序算法，稳定性是一个绕不开的话题；稳定的算法不仅能够节省排序的成本，在工程实践中也有着重要的意义，那么究竟如何判断一个算法是不是稳定的呢，本文通过研究和分析一些常用算法的稳定性，对稳定性的实质做一定探讨。</p>
<a id="more"></a>

<h2 id="稳定性的定义"><a href="#稳定性的定义" class="headerlink" title="稳定性的定义"></a>稳定性的定义</h2><p>排序算法的稳定性指依据当前比较原则进行排序前和排序后，相等元素的相对次序保持不变。这句话的意思显而易见，即如果对【5,3<sup>1</sup>,7,3<sup>2</sup>,4】进行排序，结果必须是【3<sup>1</sup>,3<sup>2</sup>,4,5,7】,才能说该算法是稳定的，反之出现【3<sup>2</sup>,3<sup>1</sup>,4,5,7】则说该算法是不稳定的。</p>
<p>那么，要求算法有这样的特性有什么意义呢。我们设想一下这样的场景：在一张大表内包含了整个年级所有的班的同学的考试成绩，当然为了区别每个同学是来自哪个班的，相应的也有班级这个字段来标识。现在，我们依据总成绩这个字段来将全年级的同学进行一个排名，排序的结果当然是各个班级的学生穿插在一起，大致如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">姓名</th>
<th align="left">班级</th>
<th align="left">成绩</th>
</tr>
</thead>
<tbody><tr>
<td align="left">张三</td>
<td align="left">2</td>
<td align="left">95</td>
</tr>
<tr>
<td align="left">李四</td>
<td align="left">1</td>
<td align="left">93</td>
</tr>
<tr>
<td align="left">王五</td>
<td align="left">2</td>
<td align="left">90</td>
</tr>
<tr>
<td align="left">赵六</td>
<td align="left">3</td>
<td align="left">80</td>
</tr>
<tr>
<td align="left">丁七</td>
<td align="left">3</td>
<td align="left">70</td>
</tr>
<tr>
<td align="left">……</td>
<td align="left">……</td>
<td align="left">……</td>
</tr>
</tbody></table>
<p>在得到这样的排序结果之后，我们可以大致了解到每个同学在全年级中的名次，那么如果想要得到每个同学在班级中的名次呢，我们能否在现有排序的基础上，以班级这个字段为依据进行排序呢？如果，我们所采用的排序算法不稳定，那么很可能我们在对班级字段进行排序后得到下面这个结果：</p>
<table>
<thead>
<tr>
<th align="left">姓名</th>
<th align="left">班级</th>
<th align="left">成绩</th>
</tr>
</thead>
<tbody><tr>
<td align="left">李四</td>
<td align="left">1</td>
<td align="left">93</td>
</tr>
<tr>
<td align="left">王五</td>
<td align="left">2</td>
<td align="left">90</td>
</tr>
<tr>
<td align="left">张三</td>
<td align="left">2</td>
<td align="left">95</td>
</tr>
<tr>
<td align="left">赵六</td>
<td align="left">3</td>
<td align="left">80</td>
</tr>
<tr>
<td align="left">丁七</td>
<td align="left">3</td>
<td align="left">70</td>
</tr>
<tr>
<td align="left">……</td>
<td align="left">……</td>
<td align="left">……</td>
</tr>
</tbody></table>
<p>我们发现，在班级这个字段进行重排的过程中，张三这条字段虽然调整到李四之后，但是他和王五的相对次序与原表中发生了改变，这样第一次排序中产生的成绩降序这个实际意义在班级这个小的序列中就无法作为参考依据，那么如果我们希望查询学生在班级中的名次，在原大表中不论怎么重排都是无法做到的，任何一个字段的排序就会使得之前排好的其他字段的排序关系失效，我们不得不开辟新的空间来存储各个班的学生数据，花费额外的时间成本和空间成本，这样无疑是非常浪费的。</p>
<p>通过这个案例我们可以看出稳定的排序算法能够对多次排序的结果有记忆功能，帮助我们节省大量的时间和空间成本，从上述案例我们似乎可以发现，稳定与否的关键在于一次排序过程中，数据的位置交换有没有跨越值相等的元素，如果没有跨越，那么结果一定是稳定的，否则是不稳定的。那么到底是不是这样的，我们来通过一些具体的算法来分析一下。</p>
<h2 id="常用算法的稳定性分析"><a href="#常用算法的稳定性分析" class="headerlink" title="常用算法的稳定性分析"></a>常用算法的稳定性分析</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒牌排序可以按照递增、递减以及大数冒泡和小数冒泡交叉分为四种情况，这里我们以递增顺序，大数向后冒泡为例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序：大数向后冒泡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length; i &gt; <span class="number">0</span> ; i--) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;  j &lt; i-<span class="number">1</span> ; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])</span><br><span class="line">				swap(arr, j, j+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设原序列为【1,5,3<sup>1</sup>,2,7,4,6,3<sup>2</sup>】，那么每一次冒泡的结果如下：</p>
<ol>
<li>【1,3<sup>1</sup>,2,5,4,6,3<sup>2</sup>,7】</li>
<li>【1,2,3<sup>1</sup>,4,5,3<sup>2</sup>,6,7】</li>
<li>【1,2,3<sup>1</sup>,4,3<sup>2</sup>,5,6,7】</li>
<li>【1,2,3<sup>1</sup>,3<sup>2</sup>,4,5,6,7】</li>
<li>【1,2,3<sup>1</sup>,3<sup>2</sup>,4,5,6,7】</li>
<li>【1,2,3<sup>1</sup>,3<sup>2</sup>,4,5,6,7】</li>
<li>【1,2,3<sup>1</sup>,3<sup>2</sup>,4,5,6,7】</li>
</ol>
<p>我们看到，排序结果中两个3的相对次序没有发生变化，说明这个算法是稳定的，分析一下代码可以发现，当两个元素比较是否应该改变相对次序时的代码为<code>if(arr[j]&gt;arr[j+1])</code>，因为用的是大于号，而不是大于等于号，所以结果是稳定的，但是如果将其改成大于等于号的话，也不会影响冒泡排序的结果，但是原本相等元素的相对次序就会被打乱，因此可以说冒泡排序可以被设计成稳定的。</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序也可以根据递增、递减以及选择大数和选择小数分为四种情况，这里以递增顺序，选择小数为例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序：选小数往前放</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr.length ; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> min_index = i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span> ; j &lt; arr.length ; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[j]&lt;arr[min_index])</span><br><span class="line">				min_index = j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(min_index!=i)</span><br><span class="line">			swap(arr, i, min_index);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设原序列为【3<sup>1</sup>,1,7,4,6,3<sup>2</sup>,5,2】，那么每一次选择的结果如下：</p>
<ol>
<li>【1,3<sup>1</sup>,7,4,6,3<sup>2</sup>,5,2】</li>
<li>【1,2,7,4,6,3<sup>2</sup>,5,3<sup>1</sup>】</li>
<li>【1,2,3<sup>2</sup>,4,6,7,5,3<sup>1</sup>】</li>
<li>【1,2,3<sup>2</sup>,3<sup>1</sup>,6,7,5,4】</li>
<li>【1,2,3<sup>2</sup>,3<sup>1</sup>,4,7,5,6】</li>
<li>【1,2,3<sup>2</sup>,3<sup>1</sup>,4,5,7,6】</li>
<li>【1,2,3<sup>2</sup>,3<sup>1</sup>,4,5,6,7】</li>
</ol>
<p>可以看到排序结果中两个3的相对次序发生了变化，并且在第二次选择的过程中就已经出现了相对次序的混乱，原因是，第二次选择时最小的数位于原本相对次序靠后的3之后，交换时第一个3直接跨过了第二个3和2进行了交换，而在之后的过程中，<code>if(arr[j]&lt;arr[min_index])</code>这行代码使得最小值元素的下标在遇到相同元素时不会发生变化，所以第一个3再也没有机会换到第二个3之前。</p>
<p>那么我们尝试修改代码的细节，看是否能改变算法的不稳定性，首先我们需要明确的是，待排序的数据状况是随机的，我们不能要求小数一定位于相等的大数的前面，因此一定会出现上述案例中小数跨越中间的大数和前面的大数交换的情况。因此我们只能考虑是否能在之后的交换过程中调整回原本的顺序，将这一句代码<code>if(arr[j]&lt;arr[min_index])</code>中的小于号改为小于等于号，这样原本序列的选择排序结果就如下：</p>
<ol>
<li>【1,3<sup>1</sup>,7,4,6,3<sup>2</sup>,5,2】</li>
<li>【1,2,7,4,6,3<sup>2</sup>,5,3<sup>1</sup>】</li>
<li>【1,2,3<sup>1</sup>,4,6,3<sup>2</sup>,5,7】</li>
<li>【1,2,3<sup>1</sup>,3<sup>2</sup>,6,7,5,4】</li>
<li>【1,2,3<sup>1</sup>,3<sup>2</sup>,4,7,5,6】</li>
<li>【1,2,3<sup>1</sup>,3<sup>2</sup>,4,5,7,6】</li>
<li>【1,2,3<sup>1</sup>,3<sup>2</sup>,4,5,6,7】</li>
</ol>
<p>结果看起来似乎是成功了，我们来看问题出在哪，第三步选择时，上一个代码选择了从前往后遇到的第一个3进行交换，而这个代码选择了最后一个3进行交换，这样就将第二步选择时造成的乱序修正了，但是这样的修改是普遍适用的吗，我们再来看一个例子：</p>
<ol>
<li>【1,3<sup>1</sup>,7,4,3<sup>2</sup>,6,3<sup>3</sup>,5,2】</li>
<li>【1,2,7,4,3<sup>2</sup>,6,3<sup>3</sup>,5,3<sup>1</sup>】</li>
<li>【1,2,3<sup>1</sup>,4,3<sup>2</sup>,6,3<sup>3</sup>,5,7】</li>
<li>【1,2,3<sup>1</sup>,3<sup>3</sup>,3<sup>2</sup>,6,4,5,7】</li>
<li>【1,2,3<sup>1</sup>,3<sup>3</sup>,3<sup>2</sup>,6,4,5,7】</li>
<li>【1,2,3<sup>1</sup>,3<sup>3</sup>,3<sup>2</sup>,4,6,5,7】</li>
<li>【1,2,3<sup>1</sup>,3<sup>3</sup>,3<sup>2</sup>,4,5,6,7】</li>
<li>【1,2,3<sup>1</sup>,3<sup>3</sup>,3<sup>2</sup>,4,5,6,7】</li>
<li>【1,2,3<sup>1</sup>,3<sup>3</sup>,3<sup>2</sup>,4,5,6,7】</li>
</ol>
<p>奇怪的是这次选择排序的结果虽然我们依据了修改后的代码逻辑，但是依然出现结果的不稳定性，这是为什么？仔细分析一下代码，我们可以发现之所以在上一个案例中选择排序的结果能够保证稳定性，其实是对排序过程中的数据状况也有隐含的要求，即被打乱的相等数据在开始确定最终站位之前，必须要保持原相对次序的逆序。因为相同的数字在确定最终站位时必然是依次确定的，那么你希望排序结果的相对次序是正序，那么排序之前的相对次序一定是逆序，这是很容易理解的。这个案例中，第三步开始，第一个3的位置已经确定，而在这一步之前三个3的相对次序还不是逆序，因此确定的结果必然也是乱序的。</p>
<p>通过上述分析，我们发现不论对原程序的逻辑做何种意义上的修改，都是要求其数据状况遵循一定的规律，在此代码逻辑的基础上这显然是不可能的。如果我们强行要保证这一算法的稳定性，似乎只能在每次交换元素之前，遍历跨度区间，找出与被交换元素相等的元素，进行依次的后移操作，以保证被交换的元素是相等元素中相对次序最靠前的元素。但是这无疑增加了算法的时间成本，选择排序本来作为一个O(N<sup>2</sup>)的算法，这样再套一层遍历，直接变成一个O(N<sup>3</sup>)的算法，为了保证稳定性而如此增加时间复杂度，无疑是得不偿失的。</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序同样可以根据递增、递减以及向前插入和向后插入分为四种情况，这里以递增顺序，向前插入为例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序：从前往后选数字顺序插入</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; arr.length ; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> index = i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; i ; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[i]&lt;arr[j]) &#123;</span><br><span class="line">				index = j;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(index!=i) &#123;</span><br><span class="line">			<span class="keyword">int</span> temp = arr[i];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i ; j &gt; index ; j--)</span><br><span class="line">				swap(arr, j-<span class="number">1</span>, j);</span><br><span class="line">			arr[index] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//show(arr,true);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设原序列为【3<sup>1</sup>,1,7,4,6,3<sup>2</sup>,5,2】，那么每一次插入的结果如下：</p>
<ol>
<li>【1,3<sup>1</sup>,7,4,6,3<sup>2</sup>,5,2】</li>
<li>【1,3<sup>1</sup>,7,4,6,3<sup>2</sup>,5,2】</li>
<li>【1,3<sup>1</sup>,7,4,6,3<sup>2</sup>,5,2】</li>
<li>【1,3<sup>1</sup>,4,7,6,3<sup>2</sup>,5,2】</li>
<li>【1,3<sup>1</sup>,4,6,7,3<sup>2</sup>,5,2】</li>
<li>【1,3<sup>1</sup>,3<sup>2</sup>,4,6,7,5,2】</li>
<li>【1,3<sup>1</sup>,3<sup>2</sup>,4,5,6,7,2】</li>
<li>【1,2,3<sup>1</sup>,3<sup>2</sup>,4,5,6,7】</li>
</ol>
<p>我们看到，排序结果中两个3的相对次序没有发生变化，说明这个算法是稳定的，分析一下代码可以发现，当查找下一个未排序的元素该插入到哪个元素之前时的代码为<code>if(arr[j]&lt;arr[j+1])</code>，因为用的是小于号，而不是小于等于号，所以结果是稳定的，但是如果将其改成小于等于号的话，也不会影响插入排序的结果，但是原本相等元素的相对次序就会被打乱，因此可以说插入排序可以被设计成稳定的。</p>
<h2 id="稳定性实质"><a href="#稳定性实质" class="headerlink" title="稳定性实质"></a>稳定性实质</h2><p>通过分析这些常见的稳定和不稳定的排序算法，我们发现，排序的过程无非可以分成两个步骤（这里指的是只借助O(1)辅助空间的算法），比较和交换。比较是排序的依据，交换是排序的过程，稳定的算法往往在交换元素时不会跨越元素，只是两两之间交换，这样当遇到相等的元素时，我们就可以很容易通过代码逻辑避免这种交换的出现，从而保证算法的稳定性。其实回想一下我们学过的算法，凡是涉及到跨元素进行交换的排序算法，例如快排和堆排，都是不稳定的排序算法。</p>
<p>综上我们在判断一个算法的稳定性时，只要多关注元素在交换的过程中是否有跨元素，便能够很好的进行判断。</p>
<hr />
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>稳定性</tag>
      </tags>
  </entry>
  <entry>
    <title>暴力美学</title>
    <url>/violence.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>近日整理旧文件的时候，偶然发现自己以前在影协中任职时制作的许多平面设计，一边感慨白驹过隙，一边唏嘘不已。本科的时候，因为会P图这个技能，在学院和社团没少承担起这方面的工作，因为没有设计方面的理论基础，很多时候都是从优秀的作品中汲取灵感（用现在流行的话说叫偷，可是读书人的事，能算偷吗~），然后硬着头皮上。一来二去，审美水平提升了许多，也渐渐掌握了一些基础的设计理念，后来以致于胜任了电影节的平面设计工作，不过这都是后话了。<br>这次先po上几张初期社团在图书馆做日常放映的时候设计的一系列海报，都是比较简单的海报设计，不足之处还请多指正。</p>
<a id="more"></a>

<h2 id="暴力美学"><a href="#暴力美学" class="headerlink" title="暴力美学"></a>暴力美学</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/violence1.jpg" alt="暴力美学"></p>
<h2 id="罪恶之城"><a href="#罪恶之城" class="headerlink" title="罪恶之城"></a>罪恶之城</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/violence2.jpg" alt="罪恶之城"></p>
<h2 id="喋血双雄"><a href="#喋血双雄" class="headerlink" title="喋血双雄"></a>喋血双雄</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/violence3.jpg" alt="喋血双雄"></p>
<h2 id="撕裂的末日"><a href="#撕裂的末日" class="headerlink" title="撕裂的末日"></a>撕裂的末日</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/violence4.jpg" alt="撕裂的末日"></p>
<h2 id="杀死比尔"><a href="#杀死比尔" class="headerlink" title="杀死比尔"></a>杀死比尔</h2><p><img data-src="https://shitsurei-pictures.oss-cn-beijing.aliyuncs.com/pics/violence5.jpg" alt="杀死比尔"></p>
<hr />
]]></content>
      <categories>
        <category>平面设计</category>
      </categories>
      <tags>
        <tag>海报</tag>
        <tag>电影</tag>
      </tags>
  </entry>
</search>
